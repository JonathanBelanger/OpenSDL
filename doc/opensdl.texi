\input texinfo    @c -*-texinfo-*-
@comment $Id@w{$}
@comment %**start of header
@include version.texi
@settitle Open Structure Definition Langauage @value{VERSION}
@syncodeindex pg cp
@comment %**end of header

@allowcodebreaks false
@setchapternewpage odd

@titlepage
@title Guide to the Open Structure Definition Language

@subtitle This manual describes the Open Structure Definition Language
(OpenSDL) and the OpenSDL translator.

Revision/Update Information: This revised manual supersedes HP and VAX SDL
(Structure Definition Language) Version 3.2.

Operating System and Version: @value{OS} @value{OSVERSION} or later

Software Version: OpenSDL Version @value{VERSION}
@end titlepage
@page
@copying
This manual is for OpenSDL (version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2018 Jonathan D. Belanger.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation

First Printing, June 1981
Revised, June 1985
Revised, November 1987
Revised, May 1989
Revised, October 2007
Revised, September 2018
@end copying
@page
@contents


@ifnottex
@node Top
@top OpenSDL Guide
This manual describes the Open Structure Definition Language (OpenSDL) and the
OpenSDL translator
@end ifnottex

@unnumbered Preface
@cindex preface

This manual describes the Open Structure Definition Language (OpenSDL) and the
OpenSDL translator for use on any compatible operating systems. OpenSDL source
code can be translated to output files in one or more target programming
languages. OpenSDL is suitable for systems and application programming
environments that use executable programs consisting of modules written in one
or multiple programming languages.

@unnumberedsec Intended Audience

This manual is intended for users who are familiar with one or more programming
languages and who are currently involved in the design and development of
multilanguage programming applications; however, users are not required to have
previous experience with OpenSDL in order to use this manual.

@unnumberedsec Document Structure

This manual contains the following chapters and appendixes.

Chapter 1 provides a brief overview of OpenSDL and the translation process.@*
Chapter 2 describes how to create, edit, and process an OpenSDL source file
using the Language-Sensitive Editor (LSE) templates and the SDL command
options.@*
Chapter 3 describes the OpenSDL language elements that compose OpenSDL
declarations.@*
Chapter 4 describes the function and format of OpenSDL declarations.@*
Appendix A provides a list and descriptions of OpenSDL diagnostic messages.@*
Appendix B shows translation summaries for all output languages supported by
OpenSDL.@*
Appendix C is a table showing the ASCII character set.@*

If OpenSDL is installed on your system, an online copy of this manual is
contained in the help/manpage folders. You can print a copy of the manual file
on a PostScript or other supported printer.

@unnumberedsec Associated Documents

If OpenSDL is installed on your system, an online example of an OpenSDL source
file is contained in EXAMPLE.SDL in the public directory SDL$EXAMPLES.

@unnumberedsec Conventions

The following conventions are used in this document.

@multitable @columnfractions .3 .7
@headitem Convention @tab Meaning

@item @code{@{ STRUCTURE @}}
@item @code{@{ UNION @}}
@tab Stacked items within braces indicate that you must select one of the
items.

@item @code{[ ]}
@tab Simple square brackets indicate that the enclosed item(s) are optional.

@item @code{[ COMMON ]}
@item @code{[ GLOBAL ]}
@tab Stacked items within brackets indicate that only one item may be selected.

@item @code{MODULE name;}
@tab Names shown in uppercase letters in examples and format descriptions are
OpenSDL keywords that must be entered as shown. Names and syntactic elements
shown in lowercase letters represent user-specified names and identifiers.

@item @code{arg,...}
@tab A comma followed by an ellipsis means that the preceding item may be
repeated one or more times, with commas separating two or more items.

@item @code{.}
@item @code{.}
@item @code{.}
@tab A vertical ellipsis in an example or figure indicates that not all the
statements or elements are shown.

@item @code{@strong{common storage}}
@tab Boldface words in text are used to introduce or define a new term, or to
refer to a term used in a code example.

@item @command{$ LSEDIT USER.SDL}
@tab In interactive examples, user input is @strong{underlined}.
@end multitable

@unnumberedsec Software and Documentation Reporting and Distribution

If OpenSDL is installed on your system, an online copy of this manual is
contained in SYS$HELP.

@unnumberedsec Summary of Technical Changes

The technical changes for this version of OpenSDL are described in the online
release notes file SDL023.RELEASE_NOTES in SYS$HELP (if OpenSDL is installed on
your system) and in the OpenSDL kit area. You can also access the release notes
through the HELP file by typing the following command:

@command{$ TYPE SYS$HELP:SDL023.RELEASE_NOTES @key{RET}}

The following is a summary of technical changes in OpenSDL Version
@value{VERSION}. (For detailed descriptions and a summary of bug fixes, see the
online release notes file.)

@itemize @bullet

@item The BASIC$data-type record definitions generated in BASIC language output
have been conditionalized in order to prevent re-definition of these record
structures within a BASIC program.

@item DIMENSION * now yields name[] instead of name[1] in C language output.

@item In Pascal language output, the [UNSAFE] attribute is now generated for
LIST parameters that are conformant strings.

@item The header that is optionally included at the beginning of an output file
now indicates that the file was created by OpenSDL instead of "HP" SDL or
"VAX" SDL.

@item The DEFAULT clause may now be specified for a parameter of an AGGREGATE
type (i.e. STRUCTURE or UNION).

@item Macro names generated for ENTRY definitions without an ALIAS clause
specified now conform to OpenVMS macro naming conventions. These macro naming
changes apply only to BLISS and MACRO language output.

@item SDL no longer generates CHARACTER*1 in FORTRAN language output for
aggregate members of type CHARACTER LENGTH 0. Instead, an informational comment
is generated for the aggregate member.

@item All behavior by the PL/I backend previously under the control of the
/VMS_DEVELOPMENT qualifier has now been placed instead under the control of a
new qualifier, /PLI_DEVELOPMENT.

@item The DESCRIPTOR and RTL_STR_DESC parameter passing mechanism attributes
are now translated to DESCRIPTOR(S) and DESCRIPTOR(SB), respectively, for ENTRY
arguments of type CHARACTER.

@item The PASCAL backend now coalesces contiguous TYPE and VAR sections under a
single incurrence of the keyword.
@end itemize

@unnumberedsec New Features

The following is a summary of new features in OpenSDL Version @value{VERSION}.
(For detailed descriptions, see the online release notes file
SDL032.RELEASE_NOTES in SYS$HELP (if OpenSDL is installed on your system) and
in the OpenSDL kit area.)

@itemize @bullet
@item User-defined data types --- SDL provides the TYPEDEF keyword to allow you
to define additional data types in some languages. TYPEDEF behaves like a
Storage Class.

@item Entry point return types --- This feature extends the syntax of the ENTRY
statement to allow you to specify a user-defined data type as a return type.

@item The CONSTANT declaration now includes string constants.

@item Conditional SDL compilation --- SDL now allows you to compile a section
of SDL code conditionally, depending on whether output is being generated for a
particular language or not.

@item Text pass-through --- SDL provides this feature to allow you to pass
literal text through to the output language file without translation. This
feature allows language-specific constructs that cannot be represented in SDL
to be emitted.

@item DECLARE statement --- SDL provides this statement to allow you to declare
a data item of a type that you define, which may be unknown in the current SDL
compilation.

@item READ statement --- SDL provides this statement to allow you to include a
.SDI intermediate file in the current compilation, without causing it to be
emitted to the output stream.

@item /SUPPRESS qualifier --- SDL provides this command line qualifier to allow
you to suppress the addition of prefixes and/or tags to names.
@end itemize

@comment Chapert 1 --- Overview

@chapter Overview

The Open Structure Definition Language (OpenSDL) is used to write source
statements that describe data structures and that can be translated to source
statements in other languages.  You can include the resulting output files in a
corresponding target language program for subsequent compilation.

Because OpenSDL is compiler- and language-independent, it is particularly
useful for maintaining multilanguage implementations. For example, you can
create and later modify a single OpenSDL source file that can be translated to
multilanguage output files; any number of these output files can then be
included in one or several multilanguage programming applications.

OpenSDL supports the following OpenVMS languages:
@itemize @bullet
@item Ada
@item BASIC
@item BLISS
@item C/C++
@item DATATRIEVE
@item OpenVMS DCL
@item FORTRAN
@item MACRO
@item Pascal
@item PL/I
@item SDML
@item DECTPU
@item UIL
@end itemize

@section The OpenSDL Translation Process
The translation of an OpenSDL source file occurs when you issue the SDL command
(@ref{Processing an OpenSDL Source File}). The SDL command activates the
OpenSDL "front-end" translator (SDL$MAIN.EXE), which is stored in the directory
SYS$SYSTEM. The front end parses the OpenSDL source code and, if you specify
the /LANGUAGE qualifier, passes the parse tree to one or more of the OpenSDL
"back-end" translators. The following table is a list of the back ends that are
stored in the directory SYS$SHARE.

@multitable @columnfractions .4 .6
@headitem Language @tab Back End
@item Ada @tab SDL$ADA.EXE
@item BASIC @tab SDL$BASIC.EXE
@item BLISS @tab SDL$BLISS.EXE
@item @tab SDL$BLISSF.EXE@footnote{The BLISSF back end generates BLISS
FIELDSETS for OpenSDL aggregates.}
@item C/C++ SDL$CC.EXE
@item DATATRIEVE SDL$DTR.EXE
@item OpenVMS DCL SDL$DCL.EXE
@item FORTRAN SDL$FORTRAN.EXE
@item MACRO SDL$MACRO.EXE
@item Pascal SDL$PASCAL.EXE
@item PL/I SDL$PLI.EXE
@item SDML SDL$SDML.EXE
@item DECTPU SDL$TPU.EXE
@item UIL SDL$UIL.EXE
@end multitable

Each back end translates only those OpenSDL declarations that can (or need) be
expressed in that language. OpenSDL declarations, described in detail in
Chapter 4, translate to the following types of data items:

@itemize @bullet
@item Scalar or dimensioned scalar data items (ITEM declarations)
@item Nonscalar data items (AGGREGATE and subaggregate declarations)
@item Named constants (CONSTANT declarations)
@item External entries(ENTRY declarations)
@end itemize

Figure 1–1 shows each step in the OpenSDL translation process, and the key
following the example describes each step. @ref{Processing an OpenSDL Source
File} describes the SDL command in detail.

Figure 1–1: OpenSDL Translation Process

Key to Figure 1–1:
@enumerate

@item The front end (SDL$MAIN.EXE) parses the statements contained in the
OpenSDL source file TEST.SDL as a result of issuing the SDL command in one of
the following four ways:

@enumerate a
@item @command{$ SDL/LIST/PARSE/LANGUAGE=BAS TEST.SDL}@*
If you specify the /LANGUAGE qualifier (for example, /LANGUAGE=BAS), the front
end parses the source code and passes the parse tree to the back end for the
specified language (for example, SDL$BASIC.EXE). (The function of the /LIST
qualifier is described at the end of step 1. The /PARSE qualifier is shown here
for completeness, but it is the default for this command and does not need to
be specified.)

@item @command{$ SDL/PARSE=TEST/LIST TEST.SDL}@*
If you do not specify the /LANGUAGE qualifier, but specify instead the /PARSE
qualifier and an output file name, the front end parses the source code and
writes the parse tree to an intermediate file with a default file type of .SDI.

@item @command{$ SDL/PARSE=TEST/LIST/LANGUAGE=BAS TEST.SDL}@*
If you specify the /PARSE qualifier with an output file name and the /LANGUAGE
qualifier, the front end parses the source code, writes the parse tree to the
specified intermediate file (for example, TEST), and passes the parse tree to
the specified back end.

@item @command{$ SDL/PARSE/LIST TEST.SDL}@*
If you specify the SDL command with the optional /PARSE and /LIST qualifiers
and do not specify an intermediate file name, the front end parses the source
code (checking for errors) but does not generate an intermediate file.
@end enumerate

The front end produces a .LIS file as a result of specifying the /LIST qualifier
on all the SDL commands described in steps 1a. through 1d. The .LIS file
contains a line-numbered copy of your source code and describes any errors or
warnings encountered during the translation process.

@item If you specify the /PARSE qualifier and an output file name, as in step 1b.
or step 1c., you may later decide to translate the intermediate (already
parsed) code to one or more language output files (for example, TEST.BAS) by
entering the following command:@*
@command{$ SDL/NOPARSE/LANGUAGE=BAS TEST.SDI}

@quotation NOTE
In cases where OpenSDL translation must be performed at a customer site, the
intermediate .SDI file is included in the software HP sends to customers.
@end quotation

@item If you enter the command in step 2, the alternate front end (SDL$NPARSE.EXE)
passes the parse tree (in TEST.SDI) to the specified back end (SDL$BASIC.EXE).

@item The specified back end (SDL$BASIC.EXE) produces an output file with the
default file type of .BAS.
@end enumerate

You can specify any or all of the language options on the /LANGUAGE qualifier,
and OpenSDL produces separate output files for each language specified.

@subsection Description of a Sample OpenSDL Source File

Example 1–1 is a typical OpenSDL source file, and the key following the example
describes each of the numbered language elements. (Chapter 3 describes all the
language elements in detail.)  You may want to familiarize yourself with this
example because it shows the source file you will be creating in the LSE
tutorial in @ref{Getting Started with LSE Templates for OpenSDL}.

Example 1–1: Sample OpenSDL Source File
@example
MODULE opr_descriptor IDENT "Version 2.0";@footnote{All OpenSDL declarations
are grouped within modules, and you must assign a name to each module. The
IDENT keyword precedes any commented information that you may want to add to
describe the MODULE declaration.}

/* define constants and node structure for operators;@footnote{Output comments
begin with a slash and an asterisk (/*) and are written to the language output
file unless the /NOCOMMENTS qualifier is specified.}
#max_args = 10;@footnote{Local symbols begin with a pound sign (#) and are not
written to the output file. Local symbols may be used to express values in
declarations.  For example, the symbol #max_args is used in the declaration of
the array operands.}

CONSTANT (fixed_binary,floating,char,untyped) EQUALS 1 INCREMENT 1;@footnote{
CONSTANT declarations produce declarations of named constants. When the
INCREMENT option and an increment value are specified, OpenSDL automatically
increments the initial value for each of the declared output constants. In the
example, fixed_binary will be assigned the value 1, floating will be assigned
the value 2, and so on.}

AGGREGATE operator STRUCTURE@footnote{AGGREGATE declarations define data
structures and their members.}
    PREFIX "opr_";@footnote{When the PREFIX option and a prefix are specified,
OpenSDL concatenates the prefix and a data type code to the declared aggregate
member names in the language output files.  Compare these aggregate member name
declarations with the PL/I output shown in Example 1–2.}
    flink ADDRESS;@footnote{Aggregate members are declared using reserved
OpenSDL data type keywords.}
    blink ADDRESS;
    opcount WORD;
    optype CHARACTER LENGTH 1;
    id WORD;
    operands LONGWORD DIMENSION 0:#max_args-1;@footnote{An aggregate member or
a scalar data item can be declared to be an array by specifying the DIMENSION
option. In this example, the array operands has 10 elements, with subscripts 0
through 9.}
END operator;

#opsize = .;@footnote{The period (.) represents the current byte offset within
an AGGREGATE declaration.  The local symbol assignment #opsize = .; captures
the size of the constant portion of the structure operator. The value of this
local symbol is then used in the declaration of the constant opr_node_size.}

CONSTANT opr_node_size EQUALS #opsize / 2;

ITEM current_node_ptr@footnote{ITEM declarations, such as the declaration of
current_node_ptr, define scalar data items.} ADDRESS@footnote{The ADDRESS
keyword specifies a data type that is an address, or pointer.} GLOBAL;@footnote{
The GLOBAL keyword specifies global storage to override the default language
storage class for an ITEM or an AGGREGATE declaration.}

END_MODULE opr_descriptor;@footnote{The END_MODULE keyword ends a MODULE
declaration; you may optionally specify the MODULE name after the END_MODULE
keyword.}
@end example

Example 1–2 shows the PL/I output file that results from translation of the
OpenSDL source file shown in Example 1–1.

Chapter 3 describes all the OpenSDL language elements, and Chapter 4 describes
the function and format of each of the OpenSDL declarations.

Example 1–2: PL/I Output File for the Sample OpenSDL Source File
@example
/**************************************************************************
/* Created 17-AUG-2007 11:23:49 by OpenVMS SDL EV2-3
Source: 13-AUG-2007 08:37:41 FOO$:[DIR]TEST.SDL
/**************************************************************************
/*** MODULE opr_descriptor IDENT Version 2.0 ***/
/* define constants and node structure for operators; */
%replace fixed_binary by 1;
%replace floating by 2;
%replace char by 3;
%replace untyped by 4;
%replace opr_s_operator by 53;
dcl 1 operator based,
     2 opr_a_flink pointer,
     2 opr_a_blink pointer,
     2 opr_w_opcount fixed binary(15),
     2 opr_t_optype character(1),
     2 opr_w_id fixed binary(15),
     2 opr_l_operands (0:9) fixed binary(31);
%replace opr_node_size by 26;
dcl current_node_ptr pointer globalref;
@end example

@chapter Creating, Editing, and Processing an OpenSDL Source File

This chapter describes how to create an OpenSDL source file using the
recommended HP Language-Sensitive Editor (LSE) text editor and how to process
your source file using the SDL command and all its qualifiers.

You can use any text editor to create your source file, including EDT and
TPU/EVE. LSE offers the advantages of being layered on TPU and of giving you
the option of selecting either an EDT- or EVE-style keypad. In addition, LSE
increases your productivity as a programmer by providing you with OpenSDL
language-specific templates to help you write your OpenSDL source code.

@ref{Entering Source Code Using Placeholders and Tokens} describes how to use
the LSE templates to enter source code.  @ref{Getting Started with LSE
Templates for OpenSDL} provides a tutorial to get you started using the LSE
templates to write OpenSDL source code.  @ref{Compiling Source Code}
describes how to compile your source code and use split-screen mode to review
your .LIS and output files from within the LSE editing environment.

@ref{Processing an OpenSDL Source File} describes the SDL command and the uses
of the SDL command qualifiers.

For more information on the advanced features of LSE, see the @cite{Guide to HP
Language Sensitive Editor} and @cite{HP Source Code Analyzer}.

@section Creating an OpenSDL Source File with LSE

To invoke LSE, issue the LSEDIT command followed by a file name with an .SDL
file type at the DCL prompt. For example:@*
@command{$ LSEDIT USER.SDL}

@quotation NOTE
If you are unable to access OpenSDL or LSE support for OpenSDL, contact your
system manager to ensure that they are installed on your system.
@end quotation

@ref{Entering Source Code Using Placeholders and Tokens} describes how to enter
source code using LSE, and @ref{Getting Started with LSE Templates for
OpenSDL} provides a tutorial on using the LSE templates to generate OpenSDL
source code.  @ref{Compiling Source Code} describes LSE’s compiler interface
features.

@node Entering Source Code Using Placeholders and Tokens
@subsection Entering Source Code Using Placeholders and Tokens
LSE simplifies the tasks of developing and maintaining software systems. LSE
provides the functions of a traditional text editor, plus these additional
powerful features: language specific placeholders and tokens, aliases, comment
and indentation control, and templates for subroutine libraries.

@strong{Placeholders} are markers in the source code that indicate locations
where you can provide program text.  Placeholders help you to supply the
appropriate syntax in a given context.  Generally, you do not need to type
placeholders; rather, they are inserted for you by LSE.

Placeholders are either optional or required. Required placeholders, which are
delimited by braces ( @{@} ), represent places in the source code where you
must provide program text.  Optional placeholders, which are delimited by
brackets ( [ ] ), represent places in the source code where you can either
provide additional constructs or delete the placeholder.

The following table describes the three types of LSE placeholders.

@multitable @columnfractions .4 .6
@headitem Type of Placeholder @tab Description

@item Terminal @tab Provides text that describes valid replacements for the
placeholder

@item Nonterminal @tab Expands into additional language constructs

@item Menu @tab Provides a list of options corresponding to the placeholder
@end multitable

You can move forward or backward from placeholder to placeholder. In addition,
you can delete or expand placeholders as needed.  @ref{Getting Started with 
LSE Templates for OpenSDL} shows examples of expanding placeholders.  Tokens
typically represent keywords in OpenSDL.  When expanded, tokens provide
additional language constructs.  You can type tokens directly into the buffer.
Generally, you use tokens when you want to add language constructs and there
are no placeholders in an existing program.  For example, typing AGGREGATE and
issuing the EXPAND (CTRL/E) command causes a template for an AGGREGATE
declaration to appear on your screen. You can also use tokens to bypass long
menus in cases where expanding a placeholder, such as @{statement@}, will
result in a lengthy menu.

You can use tokens to insert text when editing an existing file by typing the
name for a function or keyword and pressing @key{CTRL/E}.

LSE commands allow you to manipulate tokens and placeholders. The following
table shows the LSE commands and their default key bindings.

@multitable @columnfractions .4 .15 .35
@headitem Command @tab Key Binding @tab Function
@item @code{EXPAND} @tab @key{CTRL/E} @tab Expands a placeholder
@item @code{UNEXPAND} @tab @key{PF1} - @key{CTRL/E} @tab Reverses the effect of
the most recent placeholder expansion
@item @code{GOTO PLACEHOLDER/FORWARD} @tab @key{CTRL/N} @tab Moves the cursor
to the next placeholder
@item @code{GOTO PLACEHOLDER/REVERSE} @tab @key{CTRL/P} @tab Moves the cursor
to the previous placeholder
@item @code{ERASE PLACEHOLDER/FORWARD} @tab @key{CTRL/K} @tab Erases a
placeholder
@item @code{UNERASE PLACEHOLDER} @tab @key{PF1} - @key{CTRL/K} @tab Restores
the most recently erased placeholder
@item None @tab V @tab Moves the indicator down through a menu
@item None @tab ^ @tab Moves the indicator up through a menu
@item None @tab @{ ENTER @} or @tab Selects a menu option
@item @tab @{ RETURN @}
@end multitable

You can display a list of all defined tokens and placeholders, or a particular
token or placeholder, with the LSE commands SHOW TOKEN and SHOW PLACEHOLDER.
To copy the listed information into a separate file, first issue the
appropriate SHOW command to put the list into the $SHOW buffer. Then issue the
following commands:

@command{LSE> GOTO BUFFER $SHOW}
@command{LSE> WRITE filename}

To obtain a hard copy of the list, use the @command{PRINT} command at DCL level
to print the file you created.

@node Getting Started with LSE Templates for OpenSDL
@subsubsection Getting Started with LSE Templates for OpenSDL

This section provides a tutorial on using some common tokens and placeholders
to write SDL source code. The tutorial shows expansions of the following
OpenSDL declarations and language elements:

@itemize @bullet
@item MODULE declaration
@item Output comment
@item Local symbol declaration
@item CONSTANT declaration
@item AGGREGATE declaration
@item ITEM declaration
@end itemize

Example 2–1 shows the sample OpenSDL source file described in Chapter 1. You
will be creating this sample source file in the following tutorial. The
numbered callouts in the example correspond to the source code you will be
entering in each step.  Following each step, intermediate and resulting screen
displays highlight the source code you just entered.

As you step through the tutorial, refer to @ref{Entering Source Code Using
Placeholders and Tokens} for the commands that manipulate tokens and
placeholders. You can also access online help by typing @command{HELP} at the
@command{LSE>} prompt.  Remember that braces ( @{@} ) enclose required
placeholders; brackets ( [ ] ) enclose optional placeholders. When you erase an
optional placeholder, LSE also deletes any associated text before and after
that placeholder.

Example 2–1: Creating a Sample OpenSDL Source File Using LSE

@example
MODULE opr_descriptor IDENT "Version 2.0";@footnote{Move to the required
placeholder @{module-name@} by pressing @key{CTRL/N} and type opr_descriptor.
Then move to the optional placeholder [ident-string]. As you move the cursor,
notice that LSE inserts the opr_descriptor module name for the END_MODULE name
as well. Expand [ident-string] and type Version 2.0 over the resulting
placeholder "[ident-text]". Your screen will look as follows:}

/* define constants and node structure for operators@footnote{Move to the
placeholder [statement] and press CTRL/E. LSE displays a menu of options.
Press the down arrow (V) key to move the pointer to the menu option
@{output-comment@} and press RETURN. Type define constants and node structure
for operators over the placeholder [TBS]. Your screen will look as follows:}

#max_args = 10;@footnote{Move to the placeholder [statement] and press
@key{CTRL/E}. LSE displays a menu of options.  Press the down arrow (V) key to
move the pointer to the menu option @{local-assignment@} and press
@key{RETURN}.  Type max_args over the current placeholder @{local-symbol@}.
Move to the placeholder @{expression@} and type the value 10. Your screen will
look as follows:}

CONSTANT (fixed_binary,floating,char,untyped) EQUALS 1 INCREMENT 1;@footnote{
Move to the placeholder [statement] and press @key{CTRL/E}. Press @key{RETURN}
to select the menu option @{constant-declaration@} displayed on your screen.
Your screen will look as follows:

Press @key{CTRL/E} to expand the current placeholder @{constant-definition@}.
Press the down arrow (V) key to move the pointer to the menu option
"([constant-name]...) EQUALS @{CONSTANT-expression@} [increment-expression]"
and press @key{RETURN}. Your screen will look as follows:

Type fixed_binary, floating, char, and untyped over the current placeholder
[constant-name].  Press @key{CTRL/K} to delete the last occurrence of the placeholder
[constant-name].  Move to the placeholder @{CONSTANT-expression@} and type the
value 1. Move to the placeholder [increment-expression] and press @key{CTRL/E}. Move
to the resulting placeholder @{expression@} and type the value 1. Your screen
will look as follows:

Move to the three optional placeholders [prefix-declaration],
[tag-declaration], and [counter-declaration] and delete each of them by
pressing @key{CTRL/K}.}

AGGREGATE operator STRUCTURE
    PREFIX "opr_";@footnote{Expand the current placeholder [statement]. Press
the down arrow (V) key to move the pointer to the menu option
@{aggregate-declaration@} and press @key{RETURN}.  Your screen will look as
follows:

Move to the placeholder @{aggregate-name@} and type operator.

Move to the placeholder @{aggregate_type@} and press @key{CTRL/E}. Press
@key{RETURN} to select the menu option "STRUCTURE" displayed on your screen.

Press @key{CTRL/E} to expand the current placeholder [aggregate-options]. Press
@key{RETURN} to select the menu option @{member-options@} : PREFIX, TAG, OR
DIMENSION displayed on your screen.  Press @key{RETURN} again to select the new
menu option @{PREFIX-DECLARATION@} : PREFIX.

Type "opr_" over the current placeholder @{prefix_string@}. Your screen will
look as follows:}

    flink ADDRESS;@footnote{Move to the placeholder [aggregate-options] and
press @key{CTRL/K} to delete it.

Expand the current placeholder [member-declaration]. Press @key{RETURN} to
select the menu option @{member-name@} @{member-type@} [member-options]
displayed on your screen. Your screen will look as follows:

Type the first member name flink over the current placeholder @{member-name@}.
Move to the placeholder @{member-type@} and press @key{CTRL/E}. Press the down
arrow (V) key to move the pointer to the menu option @{address-declaration@} :
Address (pointer) datatype declaration and press @key{RETURN}. Press
@key{RETURN} again to select the menu option "ADDRESS". Your screen will look
as follows:}
    blink ADDRESS;
    opcount WORD;
    optype CHARACTER LENGTH 1;
    id WORD;
    operands LONGWORD@footnote{Delete the current placeholder [member-options].
The cursor is now on the current placeholder [member-declaration]. Follow the
steps described in the previous paragraph for the blink, opcount, optype, id,
and operands members shown on each line in the example callout '. Note the
differences in syntax required for some of the member names.  Your screen will
look as follows:} DIMENSION 0:#max_args-1;@footnote{Press @key{CTRL/E} to
expand the current placeholder [member-options].  Press the down arrow (V) key
to select the menu option @{dimension-declaration@}.

Press @key{RETURN} again to select the menu option "DIMENSION [lower-bound]
@{upper-bound@}". Your screen will look as follows:

Press @key{CTRL/E} to expand the current placeholder [lower-bound]. Expand the
resulting current placeholder @{bound-specifier@} and type 0 over the resulting
current placeholder @{expression@}:.  Move to the placeholder @{upper-bound@}
and press @key{CTRL/E}. Type #max_args-1; over the resulting current
placeholder @{expression@}. Your screen will look as follows:

Move to the optional placeholders [member-options] and [member-declaration]
and press @key{CTRL/K} to delete each of them.}

END operator;

#opsize = .;@footnote{Expand the current placeholder [statement]. Press the
down arrow (V) key to move the pointer to the menu option @{local-assignment@}
and press @key{RETURN}.  Your screen will look as follows:

Type opsize over the current placeholder @{local-symbol@}. Move to the
placeholder @{expression@} and press @key{CTRL/E}. Press the down arrow (V) key
to move the pointer to the menu option @{offset-location-symbol@} and press
@key{RETURN}.  Press @key{RETURN} again to select the new menu option
@{origin-byte-offset-symbol@}. Your screen will look as follows:}

CONSTANT opr_node_size EQUALS #opsize / 2;@footnote{Expand the current
placeholder [statement]. Press RETURN to select the menu option
@{constant-declaration@} displayed at the top of the screen. Press @key{CTRL/E}
to expand the current placeholder @{constant-definition@}. Press @key{RETURN}
to select the menu option "@{constant-name@} EQUALS @{CONSTANT-expression@}".
Your screen will look as follows:

Type opr_node_size over the current placeholder @{constant-name@}.  Move to the
placeholder @{CONSTANT-expression@} and press @key{CTRL/E}. Press the down
arrow (V) key to move the pointer to the menu option @{expression@} / 
@{expression@} and press @key{RETURN}. Type the expression #opsize over the
resulting current placeholder @{expression@}. Move to the next placeholder
@{expression@} and type the value 2.  Your screen will look as follows:

Move to the three optional placeholders [prefix-declaration],
[tag-declaration], and [counter-declaration] and delete each of them by
pressing @key{CTRL/K.}}

ITEM current_node_ptr ADDRESS GLOBAL;@footnote{Expand the current placeholder
[statement]. Press the down arrow (V) key to move the pointer to the menu
option @{item-declaration@} and press @key{RETURN}.
Your screen will look as follows:

Type current_node_ptr over the current placeholder @{item-name@}. Move to the
placeholder @{item-data-type@} and press @key{CTRL/E}. Select the menu option
@{address-declaration@} and then press @key{RETURN} to select the menu option
"ADDRESS". Press @key{CTRL/E} to expand the current placeholder
[storage-class].  Move to the menu option "GLOBAL" and press @key{RETURN}.
Press @key{CTRL/K} to delete the current placeholder [item-options]. Move to
the placeholders [statement] and [module] and press @key{CTRL/K} to delete
them.}

END_MODULE opr_descriptor;
@end example

Before starting the tutorial, invoke LSE and create a new OpenSDL source file.
The initial string, @strong{[module]...;}, appears at the top of the screen.
Expand the initial string by pressing @key{CTRL/E}, and the following appears
on your screen:

@example
[copyright-statement]
MODULE @{module-name@} [ident-string];
[statement]...;
END_MODULE [module-name];
[module]...;
@end example

You may expand the [copyright-statement] placeholder, but for the purposes of
this tutorial, it has been deleted by pressing CTRL/K.

Your resulting screen display should be the OpenSDL source file shown in
Example 2–1.

@node Compiling Source Code
@subsubsection Compiling Source Code

You can compile your source code, review compilation errors, and view your
output file without leaving the editing session by using the LSE command
COMPILE with the SDL command and the /LIST qualifier. If you enter only the
COMPILE command, a DCL command that invokes the OpenSDL compiler is issued in a
subprocess. For example:

@example
LSE> COMPILE

STARTING COMPILATION: SDL/PARSE/LIST USER.SDL
COMPILATION OF BUFFER USER.SDL COMPLETED
@end example

The compiler generates a .LIS file of compile-time diagnostic information that
you can review by entering the following command:

@command{LSE> GOTO FILE USER.LIS}

You have the option of entering split-screen mode first by typing the LSE
command CHANGE WINDOW_MODE and then the GOTO FILE USER.LIS command. This allows
you to view and compare your compilation errors in one window and then return
to the other window to correct your source code.

To generate an output file from within LSE, you must use the COMPILE command
with the SDL command as follows:

@example
LSE> COMPILE SDL/LIST/LANG=BASIC

STARTING COMPILATION: SDL/LIST/LANG=BASIC USER.SDL
COMPILATION OF BUFFER USER.SDL COMPLETED
@end example

You can then view your output file from within LSE by issuing the following
command:

@command{LSE> GOTO FILE USER.BAS}

LSE supports all of the OpenSDL compiler’s command qualifiers as well as
user-supplied command procedures.  You can specify DCL qualifiers, such as
/LIBRARY, when invoking the compiler from LSE.

@ref{Processing an OpenSDL Source File} describes how to process an OpenSDL
source file using the SDL command and all its qualifiers.

@quotation NOTE
OpenSDL does not support the LSE command REVIEW. The OpenSDL-generated .LIS
file, which you can view from within LSE, gives you the capability to review
compilation errors.
@end quotation

@node Processing an OpenSDL Source File
@subsection Processing an OpenSDL Source File

The SDL command invokes the OpenSDL translator from DCL command level to
produce output files for one or more target languages. The SDL command has the
following format:

@command{SDL[/qualifier[...]] file-spec[/qualifier[...]],...}

Section 2.1.3 describes how the SDL command and all its qualifiers can be
entered from within LSE when used with the LSE command COMPILE.

Command Parameter
@file{file-spec,...}
Specifies one or more OpenSDL source files to be translated. A file
specification must specify a file name; if it does not include a file type,
OpenSDL uses the default file type .SDL. You can specify multiple input files,
separated by commas. OpenSDL translates each source file individually and
creates separate output files for each.  Wildcards are not allowed in the file
specification.

Command Qualifiers
Command qualifiers may be specified following the SDL command, or they may be
used to qualify individual file specifications. Table 2–1 lists all the
optional SDL command qualifiers and their defaults.

Table 2–1: SDL Command Qualifiers and Their Defaults
@multitable @columnfractions .4 .6
@headitem Qualifier @tab Default
@item /ALIGNMENT @tab No alignment
@item /ALPHA_AXP @tab /ALPHA_AXP on Alpha and IA64 systems
@item /B64 @tab none
@item /BACKEND_OPTION @tab none
@item /[NO]CHECK_ALIGNMENT @tab /NOCHECK_ALIGNMENT
@item /[NO]COMMENTS @tab /COMMENTS
@item /[NO]COPYRIGHT @tab /NOCOPYRIGHT
@item /[NO]C_DEVELOPMENT @tab /NOC_DEVELOPMENT
@item /[NO]DUMP[=file-spec] @tab /NODUMP
@item /[NO]GLOBAL_DEFINITION @tab /NOGLOBAL_DEFINITION
@item /[NO]HEADER @tab /HEADER
@item /LANGUAGES=(language[=file-spec],...) @tab No languages
@item /[NO]LIST @tab /NOLIST (interactive)
@item @tab /LIST (batch)
@item /[NO]MEMBER_ALIGN @tab /NOMEMBER_ALIGN
@item /[NO]MODULE @tab /MODULE
@item /[NO]PARSE[=file-spec] @tab /PARSE
@item [/NO]PLI_DEVELOPMENT @tab /NOPLI_DEVELOPMENT
@item /[NO]SUBFIELDS @tab /NOSUBFIELDS
@item /[NO]SUPPRESS @tab /NOSUBFIELDS
@item /SYMBOLS @tab No symbols
@item /VAX @tab /VAX on VAX systems
@item /[NO]VMS_DEVELOPMENT @tab /NOVMS_DEVELOPMENT
@end multitable

/ALIGNMENT=value@*
The assumed alignment. Integer value greater than zero. If specified,
diagnostic messages are emitted for data items that do not fall on the assumed
alignment.

/ALPHA_AXP@*
Note the following:

@itemize @bullet
@item The size of certain data types (HARDWARE_ADDRESS, INTEGER_HW,
HARDWARE_INTEGER, POINTER_HW) is 8 bytes if /ALPHA_AXP is specified and 4 bytes
otherwise.

@item BITFIELDs can have 64 bits if /ALPHA_AXP is specified and only 32 bits
otherwise.

@item BASIC defines the data type HUGE as BASIC$HFLOAT_AXP if /ALPHA_AXP is
specified and as HFLOAT otherwise and HUGE_COMPLEX as
BASIC$H_FLOATING_COMPLEX_AXP if /ALPHA_AXP is specified and as
BASIC$H_FLOATING_COMPLEX otherwise.

@item CC writes alignment pragmas to the output file only if /ALPHA_AXP is
specified.

@item CC generates 64-bit pointers only if /ALPHA_AXP is specified.

@item CC generates QUADWORD data types as __int64 if /ALPHA_AXP is specified
and as int[2] otherwise.
@end itemize

/[NO]B64@*
This qualifier is only valid for the languages BLISS and BLISSF.
The default extension for the output file is .R64 if /B64 is specified and .R32
otherwise.  The word size used in BITFIELDs is 64 bits if /B64 is specified and
32 bits otherwise.  The name used for conditional compilation changes from
BLISS or BLISSF to BLISS64 or BLISSF64, respectively.
You cannot specify the qualifiers /B64 and /VAX together.

/[NO]BACKEND_OPTION=@{language=language-option@}@*
@{(language=language-option,...)@}
The qualifier accepts a list of languages and a value for every language. The
syntax of the value is backend-specific.

At the moment, only the CC backend supports this qualifier. It accepts the
value INT64_FOR_QUAD, which indicates that the SDL quadword data type is always
mapped to the C __int64_t data type. This is done on 64 bit-systems only (i.e.
Alpha and IA64), not on VAX systems, since there is no __int64_t data type on
VAX systems.

/[NO]CHECK_ALIGNMENT@*
If specified, diagnostic messages are emitted for data items that do not fall
on their natural alignment.

/[NO]COMMENTS@*
Controls whether output comments are included in the output file. For more
compact target language representation, use the /NOCOMMENTS qualifier to save
file space. The default is /COMMENTS.

/[NO]COPYRIGHT@*
Controls whether a standard copyright header is produced in the output file.
The /COPYRIGHT qualifier causes the OpenSDL translator to precede the output
with a comment containing the standard Hewlett-Packard copyright claim. The
default is /NOCOPYRIGHT.

/[NO]C_DEVELOPMENT@*
Only used by the CC backend.

If an input file contains more than one module, C generates one .h file per
module if either /C_DEVELOPMENT or /VMS_DEVELOPMENT is specified and one file
containing all the modules otherwise.

C defines a macro with all lowercase characters to equal the same name in all
uppercase characters for every entry node if either /C_DEVELOPMENT or
/VMS_DEVELOPMENT is specified.

C creates function prototypes if either /C_DEVELOPMENT or /VMS_DEVELOPMENT is
specified (although the ones generated with /VMS_DEVELOPMENT only contain
"__unknown_params").

C generates most definitions twice if /C_DEVELOPMENT is specified, separated
with "#ifdef __NEW_STARLET" ... "else" ... "endif". The "__NEW_STARLET"
definitions contain complete function prototypes, the "OLD" definitions only
"__unknown_params". Also, the definitions of structs and unions are different.

The __member_alignment pragmas are only generated if both /ALPHA_AXP and
/C_ DEVELOPMENT are specified.

C generates "if !defined(__VAXC)" for special cases if /C_DEVELOPMENT or
/VMS_DEVELOPMENT is specified, otherwise "ifdef _ _cplusplus" is generated.

C generates "#ifndef __<module-name>_LOADED" ... if /C_DEVELOPMENT or
/VMS_DEVELOPMENT is specified.

C generates "__required_pointer_size" pragmas if either /VMS_DEVELOPMENT or
both /C_DEVELOPMENT and /ALPHA_AXP are specified.

Together with the /ALPHA_AXP qualifier and the /VMS_DEVELOPMENT qualifier this
qualifier influences the definition of certain data types and the generation of
certain pragmas, e.g. the data type QUADWORD is defined as __int64_t if
/ALPHA_AXP is specified and /VMS_DEVELOPMENT and not /C_DEVELOPMENT, and as
int[2] otherwise, and the HARDWARE_ADDRESS and POINTER_HW data types are
defined as __int64_t if /ALPHA_AXP and neither /C_DEVELOPMENT nor
/VMS_DEVELOPMENT are specified and as int[2] if /ALPHA_AXP is not specified,
and are not defined if /ALPHA_AXP and one of the qualifiers /C_DEVELOPMENT or
/VMS_DEVELOPMENT is specified.

/[NO]DUMP [=file-spec]@*
Controls whether the OpenSDL intermediate code is displayed on your screen. If
you specify the /DUMP qualifier with a file specification, the output is sent
to the specified file. The default is /NODUMP.

/[NO]GLOBAL_DEFINITION@*
Controls whether an item or aggregate declared with the GLOBAL option generates
a declaration indicating that the value of the global data item is defined in
this module. In some languages, this qualifier has no effect; see the
individual language translation summaries in Appendix B and online examples of
language output files as a result of processing the OpenSDL source file
EXAMPLE.SDL in SDL$EXAMPLES.

By default, global definitions are not generated; the GLOBAL option designates
global data whose value is defined elsewhere.

/[NO]HEADER@*
Controls whether a header containing the date and the source file name is
included at the beginning of the output file. The default is /HEADER.

/LANGUAGES=@{language[=file-spec]@}@*
@{(language[=file-spec],...)@}
Specifies one or more of the language options listed in Table 2–2 for which the
OpenSDL translator is to produce one or more source output files. By default,
OpenSDL writes output files into separate files in the current default
directory. The default file name for each output file is taken from the file
name of the corresponding source file and the default target file type for each
language name.

Table 2–2: OpenSDL Output Language Options and File Types
@multitable @columnfractions .33 33 .34
@headitem Language @tab Option @tab Target File Type
@item Ada @tab /LANGUAGES=ADA @tab .ADA
@item BASIC @tab /LANGUAGES=BASIC @tab .BAS
@item BLISS @tab /LANGUAGES=BLISS @tab .R32, .R64
@item @tab /LANGUAGES=BLISSF @tab .R32, .R64@footnote{The BLISSF back end
generates BLISS FIELDSETS for OpenSDL aggregates.}
@item @tab /LANGUAGES=BLISS64 @tab .R64@footnote{The BLISS64 back end
generates the same code as the BLISS backend when the /B64 qualifier has been
specified.}
@item C/C++ @tab /LANGUAGES=CC @tab .H
@item OpenVMS DCL @tab /LANGUAGES=DCL @tab .COM
@item DATATRIEVE @tab /LANGUAGES=DTR @tab .DTR
@item FORTRAN @tab /LANGUAGES=FORTRAN @tab .FOR
@item MACRO @tab /LANGUAGES=MACRO @tab .MAR
@item Pascal @tab /LANGUAGES=PASCAL @tab .PAS
@item PL/I @tab /LANGUAGES=PLI @tab .PLI
@item SDML @tab /LANGUAGES=SMDL @tab.SDML
@item DECTPU @tab /LANGUAGES=TPU @tab .TPU
@item UIL @tab /LANGUAGES=UIL @tab .UIL
@end multitable

OpenSDL builds the language image name by concatenating the prefix SDL to the
language option specified on the SDL command. For example, if you specify\
/LANGUAGE=FORTRAN, OpenSDL searches for and activates the SDL$FORTRAN.EXE back
end.  You may abbreviate most language options, but OpenSDL uses the first
image it finds that matches the generated file specification. For example, if
you wish to invoke the BLISSF back end instead of the BLISS back end, you must
specify /LANGUAGE=BLISSF.

The /LANGUAGE qualifier also allows you to override the default output file
specification for one or more language output files. You can specify a language
option followed by the destination file specification for that language. You
must separate the language from the destination file specification with an
equal sign (=) and separate specifications for different languages with commas.

/[NO]LIST@*
Controls whether a listing file is produced.

If the SDL command is executed from interactive mode, /NOLIST is the default.
If the SDL command is executed from batch mode, /LIST is the default.

The /LIST qualifier causes the OpenSDL translator to produce a listing file
with numbered lines of source code and descriptions of any compilation errors.
The listing file has the same name as the related source file and a file type
of .LIS.

/[NO]MEMBER_ALIGN@*
Specifies that every item in aggregates should be aligned. This is the same as
specifying ALIGN on all aggregates.

/[NO]MODULE@*
Controls whether an Ada package or a Pascal module is generated in the output
file.  The default is /MODULE. The /[NO]MODULE qualifier affects only the
Pascal and  Ada languages.

/[NO]PARSE [=file-spec]@*
Controls whether OpenSDL reads or writes an OpenSDL intermediate file. An OpenSDL
intermediate file contains OpenSDL source code that has already been parsed
using the SDL/PARSE command. The default file type for the OpenSDL intermediate
file is .SDI.

The intermediate file produced as a result of the SDL/PARSE command can later
be used instead of OpenSDL source code as input to the back end. This is done
using the SDL/NOPARSE command. When this qualifier appears in an SDL command
line, the input file specification is assumed to be that of an SDL intermediate
file with a default file type of .SDI. Examples 4 and 5 at the end of this
section show the uses of the /[NO]PARSE qualifiers.

/[NO]PLI_DEVELOPMENT@*
Only used by the PLI backend.
This qualifier specifies the definition of certain data types, e.g. most
integral data types are defined as fixed binary (n) if /PLI_DEVELOPMENT is
specified and as bit(n) aligned otherwise.

In addition, the type names of certain parameters are changed, e.g. "ASTADR" to
"entry value" and "MASK_BYTE" to "bit (8) aligned".

Default parameters that are not optional are marked as "optional" if
/PLI_DEVELOPMENT is specified

/[NO]SUBFIELDS@*
When this qualifier is given, the BLISSF backend handles subfields of members
declared with a named type differently.

/SUPPRESS =@{suppress-option@}@*
@{(suppress-option,...)@}@*
The /SUPPRESS qualifier has the following format:
@command{SDL /SUPPRESS=(PREFIXES, TAGS)}

Note the following:

@itemize @bullet
@item The suppress-options can be either PREFIXES or TAGS.

@item The qualifier may appear anywhere in the command line where a qualifier
is valid.

@item Output in all languages in that compilation is affected. It is not
possible to make the qualifier position-dependent (CDU constraint).

@item Either PREFIXES or TAGS, or both, may be included in the list.

@item If both prefixes and tags are suppressed, the connecting underscore is
also suppressed.

@item The effect on the intermediate tree is as though null prefixes and/or
tags had been specified throughout the source. There are therefore no changes
to the back ends.
@end itemize

/SYMBOLS=@{symbol=value@}@*
@{(symbol=value,...)@}
It is possible to specify symbols and values which can be used in the IFSYMBOL
statement (kind of conditional compilation).
See IFSYMBOL.

/VAX@*
For modules, FORTRAN writes the following comment to the output file:
!DEC$ OPTIONS/ALIGN=(RECORDS=PACKED,COMMONS=PACKED)/NOWARN

CC generates ‘‘double’’ as return type for functions if the actual return type
is quadword and /VAX but not /VMS_DEVELOPMENT is specified.

You cannot specify the qualifiers /ALPHA_AXP and /VAX together. You cannot
specify the qualifiers /B64 and /VAX together.

/[NO]VMS_DEVELOPMENT@*
Modifies the behavior of certain OpenSDL back ends so that the generated output
files conform to specific VMS development standards.

Ada defines the data types QUADWORD and INTEGER_QUAD as INTEGER_64 if
/ALPHA_AXP and /VMS_DEVELOPMENT is specified and as UNSIGEND_QUADWORD
otherwise.

For BLISS and BLISSF, the /VMS_DEVELOPMENT qualifier causes ENTRY declarations
to generate KEYWORD macros in the output (.R32) file and defines routines as
‘‘external routine routine-name : novalue’’ otherwise.

BLISS’ and BLISSF’s generation of certain ‘‘literal’’s for the sizes of
structures or unions depends on this qualifier.
The following rules apply when the /VMS_DEVELOPMENT qualifier is specified for 
BLISSF output:

@itemize @bullet
@item User fill fields are ignored.
@item Nested structures are ignored.
@item Macros are generated instead of fields for certain level one items.
@end itemize

CC handles user fill depending on /VMS_DEVELOPMENT.

CC handles references to aggregates within typedef’d aggregates different when
/VMS_DEVELOPMENT is specified.

For MACRO, the /VMS_DEVELOPMENT qualifier causes the VMS macros $EQU, $DEF,
$DEFINI, and $DEFEND to be generated in the output (.MAR) file.

For Pascal, the /VMS_DEVELOPMENT qualifier causes "$TYPE" to be appended to the
names of structures and unions in the output (.PAS) file.
The following rules apply when the /VMS_DEVELOPMENT qualifier is specified for
Pascal output:

@itemize @bullet
@item ‘‘read node’’ modules are prefixed with ‘‘PASCAL$’’.
@item The generation of certain fill fields is suppressed.
@item ‘‘$TYPE’’ is appended to data types that have no ‘‘$’’ in their name.
@item An error message is emitted if a complex data type is encountered.
@item The type ‘‘$DEFPTR’’ is generated for user data types instead of the
actual data type.
@end itemize

The following rules apply when the /VMS_DEVELOPMENT qualifier is specified for 
PL/I output:

@itemize @bullet
@item UNSIGNED BYTE,UNSIGNED WORD, and UNSIGNED LONGWORD yield FIXED
BINARY(7), FIXED BINARY(15), and FIXED BINARY(31), respectively.
@item Special VMS TYPENAME values are recognized.
@item DEFAULT n for n<>0 generates OPTIONAL.
@end itemize

The default is /NOVMS_DEVELOPMENT.

Examples

The following are examples and descriptions of the SDL command.
@enumerate
@item @command{$ SDL BLOCKNODE/LANGUAGE=(PLI=PLI$:[PL1.PSRC],CC=C$:[C.CSRC])}@*
OpenSDL translates the declarations in BLOCKNODE.SDL to PL/I and C, writes
the PL/I output to PLI$:[PL1.PSRC]BLOCKNODE.PLI, and writes the C output to
C$:[C.CSRC]BLOCKNODE.H.

@item @command{$ SDL VTREE.SRC/LANGUAGE=(PLI=[PLI.PSRC])}@*
OpenSDL translates the declarations in VTREE.SRC and writes the PL/I output to
[PLI.PSRC]VTREE.PLI.

@item @command{$ SDL/LANGUAGE=(MACRO,BLISS) IODEF,SSDEF}@*
OpenSDL translates the declarations in IODEF.SDL and SSDEF.SDL and writes the
output to IODEF.MAR, IODEF.R32, SSDEF.MAR, and SSDEF.R32.

@item @command{$ SDL/PARSE=INTER TEST)}@*
OpenSDL translates the declarations in the source file TEST.SDL and writes the
output to a OpenSDL intermediate file called INTER.SDI.

@item @command{$ SDL/NOPARSE/LANG=(MACRO,BLISS) INTER}@*
OpenSDL translates the declarations that have already been parsed by the
OpenSDL front end in INTER.SDI and writes the output to INTER.MAR and
INTER.R32.
@end enumerate

@chapter OpenSDL Language Elements

This chapter describes the function and syntax of the following OpenSDL
language elements that compose the OpenSDL declarations described in Chapter 4:

@itemize @bullet
@item User-specified names, which can be either local symbol names or source
program identifiers
@item Reserved OpenSDL keywords
@item Expressions
@end itemize

The following can also be used within a MODULE declaration; although they are
not OpenSDL language elements (see Section 3.4 through Section 3.6):

@itemize @bullet
@item Local and output comments
@item INCLUDE statement
@item READ statement
@item Conditional compilation
@item Text pass-through
@item DECLARE statement
@end itemize

The space, tab, or carriage return character delimits the language elements,
and a semicolon (;) terminates each declaration. In MODULE and AGGREGATE
declarations, the semicolon also terminates separate parts of the declaration.

Appendix B shows language translation summaries of all the OpenSDL language elements.

@section Names
An OpenSDL name can be either a user-specified local symbol name that is not
translated to the output file or a user-specified source program identifier
that is translated to the output file. Names are composed of upper- and
lowercase letters (A - Z, a - z), numbers (0 - 9), the dollar sign ($), and the
underscore (_).  Specifying a name is subject to the following rules:

@enumerate
@item Local symbol names must begin with a pound sign (#).
@item Source program identifiers must begin with an alphabetic character
(A-Z, a-z), a dollar sign ($), or an underscore (_).
@item Source program identifiers that are reserved OpenSDL keywords or that
contain invalid  SDL characters must be enclosed in quotation marks (" ").
(For more information on reserved OpenSDL keywords, see Section 3.2.)
@item OpenSDL passes all source program identifiers to the output file in the same
case in which they are defined.
@end enumerate

@subsection Local Symbol Names
A local symbol name is known only within an OpenSDL source file and cannot be
translated directly to the output file. A local symbol name can be assigned a
value anywhere within a source file, but must begin with the pound sign
(#). A local symbol is declared when it is first assigned a value. This
value can be any valid expression (see Section 3.3).  If you reference a local
symbol before assigning it a value, OpenSDL displays an error message and does
not produce an output file. A local symbol assignment has the following syntax:

@code{#local-name = expression;}

#local-name@*
Is any valid OpenSDL name.

expression@*
Is any valid OpenSDL expression resulting in a longword integer value.
Signed integer longword data types are described in Section 3.2.3.9.
The following are examples of local symbol assignments:

@example
#max_args = 255;
#counter = #counter + 1;
@end example

The values of these local symbols may be referenced by subsequent declarations,
as shown in the following example:

CONSTANT block_node_size EQUALS #max_args + #counter;

@subsection Source Program Identifiers

Source program identifiers (identifiers) specify declaration names, AGGREGATE
member names, and ENTRY parameter names that are passed to the output file.
Optional user-specified prefixes and tags can be appended to these identifiers.
If a prefix is specified without a tag, OpenSDL concatenates a default tag
(corresponding to the data type) to the identifier in the output file.
(Section 3.2.2.2 describes the PREFIX and TAG keyword options.) The identifier
block_node_size in the following example names the CONSTANT declaration:

@code{CONSTANT block_node_size EQUALS #max_args + #counter;}

To avoid compilation errors, each reference to a particular OpenSDL identifier
must be a case sensitive match because an identifier is passed to the output
file in the same case in which it appears in the source file.  You can use
reserved OpenSDL keywords and characters that are not valid in identifiers if
you enclose them in quotation marks (" "). For example:

@code{ITEM "length" LONGWORD;}

This declaration produces the identifier length, which is a reserved OpenSDL
keyword typically used to specify the length of a bit-string or
character-string data type (see Section 3.2.3.3 and Section 3.2.3.5).

@section Keywords
Reserved OpenSDL keywords are used to specify the following:
@itemize @bullet
@item Declarations (@ref{Declaration Keywords})
@item Declaration modifiers (@ref{Declaration Modifier Keywords})
@item Prefixes, markers, and tags (see Section 3.2.2.2)
@item Alignment (see Section 3.2.2.3)
@item Storage classes (see Section 3.2.2.4)
@item Arrays (see Section 3.2.2.7)
@item Datatypes (see Section 3.2.3)
@end itemize
You can use keywords as identifiers if they are enclosed in quotation marks
(" "). For example:

ITEM "length" LONGWORD;

This declaration produces the identifier length, which names this particular
ITEM declaration.  The length identifier is a reserved OpenSDL keyword that is
typically used to specify the length of a bit-string or character-string data
type (see Section 3.2.3.3 and Section 3.2.3.5).

Reserved OpenSDL keywords can be entered in either upper- or lowercase letters,
but they cannot be truncated.

The following sections describe the format and function of each of the reserved
OpenSDL keywords.

@node Declaration Keywords
@subsection Declaration Keywords

Table 3–1 alphabetically lists and defines the keywords for the declarations
described in detail in Chapter 4.

Table 3–1: Keywords That Identify or End Declarations
@multitable @columnfractions .3 .7
@headitem Keyword @tab Definition
@item AGGREGATE @tab Declaration that produces a structure or union body
@item CONSTANT @tab Declaration of a named constant
@item END @tab Delimiter for the end of an aggregate body
@item END_MODULE @tab Delimiter for the end of a module
@item ENTRY @tab Declaration of an entry
@item ITEM @tab Declaration of an item
@item MODULE @tab Declaration of a module
@item STRUCTURE @tab Declaration that is a type of aggregate or subaggregate
@item UNION @tab Declaration that is a type of aggregate or subaggregate
@end multitable

@node Declaration Modifier Keywords
@subsection Declaration Modifier Keywords

Table 3–2 lists and defines other keywords that are used in declarations. The
prefix and tag, storage class, and array keywords have special functions that
are described in detail in the sections following Table 3–2. All the other
keywords defined in Table 3–2 are described in greater detail in Chapter 4.

Table 3–2: Keywords Used in Declarations

MODULE Declaration
Keyword Description
IDENT Optional keyword used to pass information describing the MODULE declaration to
the output file

ITEM Declaration
Keyword Description
ALIGN,
NOALIGN,
BASEALIGN
Optional keywords used to specify alignment; see Section 3.2.2.3
COMMON and
GLOBAL
Optional keywords used to specify common and global storage; see Section 3.2.2.4
DIMENSION Optional keyword used to specify that the ITEM declaration is an
array; see Section 3.2.2.7
PREFIX Optional keyword used to concatenate a user-defined prefix to ITEM
names, AGGREGATE member names, and named constants; see Section 3.2.2.2
TAG Optional keyword used to override the default OpenVMS code assigned to a
name and to assign a user-defined tag instead; see Section 3.2.2.2

AGGREGATE Declaration
Keyword Description
COMMON,
GLOBAL,
BASED,
TYPEDEF
Optional keywords used to specify common, global, or based storage, or a
TYPEDEF; see Section 3.2.2.4
DIMENSION Optional keyword used to specify that the AGGREGATE declaration is an
array; see Section 3.2.2.7
FILL Optional keyword used to indicate whether the associated aggregate or
member occurs only as a fill to force byte alignment on the following member or
aggregate, respectively
MARKER Optional keyword used to assign a user-defined prefix to the aggregate
name; see Section 3.2.2.2
ORIGIN Optional keyword used to define the beginning of an aggregate with
respect to an aggregate member
PREFIX Optional keyword used to concatenate a user-defined prefix to AGGREGATE
member names, ITEM names, and named constants; see Section 3.2.2.2
TAG Optional keyword used to override the default OpenVMS code assigned to a
name and to assign a user-defined tag instead; see Section 3.2.2.2

CONSTANT Declaration
Keyword Description
COUNTER Optional keyword that saves the last assigned value in a local symbol
declaration for subsequent use
EQUALS Required keyword used in assigning the value to the first named constant
STRING Optional keyword specified immediately after EQUALS to indicate the
definition of a string constant.
INCREMENT Optional keyword used to specify constants with incremental values
PREFIX Optional keyword used to concatenate a user-defined prefix to aggregate
member names and named constants; see Section 3.2.2.2
TAG Optional keyword used to override the default OpenVMS code assigned to a
name and to assign a user-defined tag instead; see Section 3.2.2.2
TYPENAME Optional keyword used only by the Ada and PL/I back ends to specify a
user-defined data type name; see Section 3.2.2.1

ENTRY Declaration
Parameter-
Passing
Mechanism
Keywords Description
DESCRIPTOR Optional parameter-passing mechanism keyword used to specify that a
parameter must be passed BY DESCRIPTOR
REFERENCE Optional parameter-passing mechanism keyword used to specify that a
parameter must be passed BY REFERENCE; REFERENCE is the default
RTL_STR_DESC Optional parameter-passing mechanism keyword used to specify that
a parameter must be passed by any of the classes of string descriptors
VALUE Optional parameter-passing mechanism keyword used to specify that the
parameter must be passed BY immediate VALUE
Parameter
Mode
Keywords Description
IN Parameter description keyword used to indicate that a parameter is an input
parameter; can be used with OUT to indicate that the parameter is both an input
and an output parameter; IN is the default
OUT Parameter description keyword used to indicate that a parameter is an
output parameter; can be used with IN to indicate that the parameter is both an
input and an output parameter
Other
Parameter
Modifier
Keywords Description
DEFAULT Optional parameter description keyword used to specify a default
parameter value
DIMENSION Optional keyword used to specify that the parameter is an array; see
Section 3.2.2.7
LIST Optional parameter description keyword used to indicate that the routine
may be called with one or more parameters of the type being described
NAMED Optional parameter description keyword used only by the Ada back end to
name the parameter
OPTIONAL Optional parameter description keyword used to specify that the
parameter may or may not appear in the sequence of parameters using the entry
point name
TYPENAME Optional parameter description keyword used only by the Ada and PL/I
back ends to specify a user-defined data type name; see Section 3.2.2.1

ENTRY Declaration
Entry
Return Value
Keywords Description
NAMED Optional keyword used to specify the name of the parameter (in an Ada
IMPORT_VALUED_PROCEDURE) into which the return value is returned
RETURNS Optional keyword used to specify the data type returned by the external
entry
TYPENAME Optional keyword used only by the Ada and PL/I back ends to specify
a user-defined name that is the data type returned by the external entry; see
Section 3.2.2.1

Entry
Description
Keywords Description
ALIAS Optional keyword used to indicate an alternate internal name that can be
used to designate the entry point
LINKAGE Optional keyword used only by the MACRO back end to indicate that a
special call macro will be used in the expansion of the entry macro
PARAMETER Optional keyword used to describe the parameters of the external
entry
VARIABLE Optional keyword used to indicate that the entry point can be invoked
with a variable number of parameters; see also the LIST parameter modifier
keyword

@subsubsection User-Specified TYPENAME keyword
The TYPENAME keyword is used to specify a data type name that is not an OpenSDL
data type. Depending on which back end is specified, this name may or may not
override the OpenSDL data type. The Ada and PL/I back ends use these data type
names as parameter data types, as return value data types, and as CONSTANT
declaration data types.

The TYPENAME keyword has the following syntax:
TYPENAME name
The Ada language translation (as a result of processing the OpenSDL source file
EXAMPLE.SDL in SDL$EXAMPLES) shows an example of the TYPENAME keyword. The
following is an example of the TYPENAME keyword on each of the parameters in an ENTRY
declaration:
@example
ENTRY SYS$FAO
    ALIAS $FAO
    PARAMETER (CHARACTER DESCRIPTOR NAMED CTRSTR IN TYPENAME CHARDESC,
        WORD UNSIGNED NAMED OUTLEN OUT DEFAULT 0 TYPENAME NUMBER,
        CHARACTER DESCRIPTOR NAMED OUTBUF OUT TYPENAME CHARDESC,
        LONGWORD VALUE NAMED P1 OPTIONAL LIST TYPENAME VARIES)
    RETURNS LONGWORD TYPENAME CONDVALU;
@end example

@subsubsection PREFIX, MARKER, and TAG Keywords
User-defined prefixes, markers, and tags are optional character strings that
help to uniquely identify the names associated with a particular facility or
system. When the /SUPPRESS qualifier is specified on the command line, the
inclusion of prefixes and/or tags on output symbol names is suppressed.  See
Section 2.2 for a description of the /SUPPRESS qualifier.

PREFIX Keyword
The PREFIX option may be specified on an AGGREGATE, subaggregate, CONSTANT, or
ITEM declaration to cause OpenSDL to concatenate a user-specified prefix and
the name specified in the declaration.
When you specify a prefix for an aggregate, OpenSDL concatenates the prefix and
the name of each member or named constant declared within the aggregate.  The
name of the aggregate itself is not altered by the use of the PREFIX option.
The PREFIX option has the following syntax:

@code{PREFIX prefix-string}

prefix-string
Is a 0- to 32-character string that can be any valid OpenSDL identifier.
If you specify the PREFIX option, OpenSDL constructs the identifier of each
member by concatenating the prefix, a tag, an underscore, and the member name.

You can override a prefix that is currently in effect by specifying a new
prefix for a particular aggregate member. If this member happens to be a
subaggregate, the new prefix is applied to all the members of that
subaggregate.  Otherwise, if no prefix is specified for the subaggregate, all
subaggregate members are assigned the same prefix as that specified on the
level-1 aggregate.

MARKER Keyword
You can use the MARKER keyword to assign a user-defined prefix to the aggregate
name. The MARKER option has the following syntax:

@code{MARKER marker-string}

marker-string
Is a 0- to 32-character string that can be any valid OpenSDL name that may or
may not be enclosed in quotation marks (" ") and may be null.

TAG Keyword
The TAG option overrides the default tags that OpenSDL uses in forming
identifiers. You can specify tags for CONSTANT, ITEM, and AGGREGATE
declarations and aggregate members.
The tag that you specify, however, affects only the outer-level identifier. For
example, a tag you supply in an AGGREGATE declaration affects only the
aggregate name; if you wish to change all the tags in an aggregate, you must do
it on a member-by-member basis.  The TAG option has the following syntax:

@code{TAG tag-string}

tag-string
Is a 0- to 32-character string specifying the tag to use in forming the name.
If the TAG option is not specified, OpenSDL uses a default code based on the
data type of the name.
If you specify the TAG option, OpenSDL appends the tag-string, which may be
null (" "), and an underscore character (_) to the current prefix-string.  A
tag consisting of a single underscore character produces a single underscore
character in any resulting identifier.
The following is an example of the PREFIX, TAG, and MARKER keywords:

@example
AGGREGATE operator STRUCTURE MARKER doowop$ PREFIX beebop$ TAG shoo;
    flink ADDRESS;
    blink WORD;
END;
@end example

Table 3–3 shows the default tags that OpenSDL uses when the TAG option is not
specified on an aggregate member.

Table 3–3: Default Tags Used by OpenSDL
@multitable @columnfractions .4 .6
@headitem Data Type @tab Default Tag
@item CONSTANT @tab K
@item BYTE [UNSIGNED] @tab B
@item WORD [UNSIGNED] @tab W
@item LONGWORD [UNSIGNED] @tab L
@item QUADWORD @tab Q
@item OCTAWORD @tab O
@item T_FLOATING @tab F
@item S_FLOATING @tab D
@item T_FLOATING @tab COMPLEX FC
@item S_FLOATING @tab COMPLEX DC
@item DECIMAL @tab P
@item BITFIELD @tab V for BITFIELD offset
@item @tab S for BITFIELD size@footnote{Identifiers with size and mask (if
MASK is specified) tags are generated regardless of whether a PREFIX or TAG
option is specified.}
@item @tab M for BITFIELD mask
@item CHARACTER @tab T
@item ADDRESS @tab A
@item BOOLEAN @tab B
@item VOID @tab Z
@item INTEGER @tab IS
@item INTEGER_BYTE @tab IB
@item INTEGER_WORD @tab IW
@item INTEGER_LONG @tab IL
@item INTEGER_QUAD @tab IQ
@item INTEGER_HW @tab IH
@item POINTER_HW @tab PH
@item POINTER_LONG @tab PL
@item POINTER @tab PS
@item POINTER_QUAD @tab PQ
@item HARDWARE_ADDRESS @tab HA
@item HARDWARE_INTEGER @tab HI
@item STRUCTURE @tab R
@item UNION @tab R
@end multitable

The following example shows the use of a user-specified prefix on an AGGREGATE
declaration:

@example
AGGREGATE operator STRUCTURE
    PREFIX opr$;

    id WORD;
    "typename" CHARACTER;
    CONSTANT (fixed_bin_,float_) EQUALS 0 INCREMENT 1;
    bits STRUCTURE;
        variable_size BITFIELD;
        size_units BITFIELD LENGTH 3;
    END bits;
END operator;
@end example

In the previous example, the member name "typename" is enclosed in quotation
marks because it is an OpenSDL keyword.

The previous declaration produces the
following names, with the prefix opr$ and default tags, in the PL/I output
file:

@example
%replace opr$k_fixed_bin_ by 0;
%replace opr$k_float_ by 1;
%replace opr$s_operator by 4;
dcl 1 operator based,
     2 opr$w_id fixed binary(15),
     2 opr$t_typename character(1),
     2 opr$r_bits ,
      3 opr$v_variable_size bit(1),
      3 opr$v_size_units bit(3),
      3 opr$v_fill_0 bit(4);
@end example

The name opr$v_fill_0 in the previous list is the result of a BITFIELD
declaration that SDL supplied because the subaggregate did not end on a byte
boundary. The name (opr$v_fill_0) ensures that the next aggregate begins on a
byte boundary.  Section 4.5.7 describes data alignment in detail. OpenSDL uses
default codes followed by an underscore (_) for the tag portion of a prefix
when the TAG option is not specified. You can override the default OpenVMS
codes by specifying a tag, which may be null (" "). For example:

@example
CONSTANT (abc,def,ghi) EQUALS 0 INCREMENT 1
    PREFIX new
    TAG "";
@end example

This declaration results in the names new_abc, new_def, and new_ghi.

@subsubsection Alignment Keywords
Both the ALIGN and BASEALIGN keywords can ensure that items are properly
aligned. The BASEALIGN keyword takes an argument, which specifies the
alignment, whereas the ALIGN keyword uses the natural alignment of the item.

@itemize @bullet
@item If the ALIGN keyword is included in the definition of an aggregate, every
member will be aligned. Both i1 and i2 will be aligned.
@example
AGGREGATE MyStruct STRUCTURE ALIGN;
    c1 CHARACTER;
    i1 LONGWORD;
    c2 CHARACTER;
    i2 LONGWORD;
END;
@end example

@item If the ALIGN keyword is included in the definition of a member of an
aggregate, this member will be aligned, even if the AGGREGATE itself does not
have the ALIGN attribute. i2 will be aligned whereas i1 will not be aligned.
@example
AGGREGATE MyStruct STRUCTURE NOALIGN;
    c CHARACTER;
    i1 LONGWORD;
    i2 LONGWORD ALIGN;
END;
@end example

@item If the NOALIGN keyword is included in the definition of a member of
an aggregate, no action will be taken to ensure that this member will be
aligned, even if the AGGREGATE has the ALIGN attribute. i2 will be aligned, i1
will not be aligned.
@example
AGGREGATE MyStruct STRUCTURE ALIGN;
    c CHARACTER;
    i1 LONGWORD NOALIGN;
    i2 LONGWORD;
END;
@end example

@item If the NOALIGN keyword is included in the definition of an aggregate,
no action will be taken to ensure that any member of this aggregate will be
aligned. Neither i2 nor i1 will be aligned.
@example
AGGREGATE MyStruct STRUCTURE NOALIGN;
    c CHARACTER;
    i1 LONGWORD;
    i2 LONGWORD;
END;
@end example

@item If the BASEALIGN keyword is included in the definition of a member of an
aggregate, this member will be aligned according to the given alignment. In
this case, i2 will have an offset of 256 (28),
@example
AGGREGATE MyStruct STRUCTURE NOALIGN;
    c CHARACTER;
    i1 LONGWORD;
    i2 LONGWORD BASEALIGN(8);
END;
@end example

@item If the BASEALIGN keyword is included in the definition of an aggregate or
an item, the aggregate or item itself will be padded, so that in an array of
elements of this aggregate or item type, all elements will be aligned
according to the given alignment. The syntax is as follows:
@example
AGGREGATE MyStruct STRUCTURE BASEALIGN (2);
    c CHARACTER;
    i1 LONGWORD;
    i2 LONGWORD;
END;
@end example
@end itemize

The size of the aggregate will be a multiple of 4 (22), in this case 12, and
neither i1 nor i2 will be aligned.  In the following example, the item will
have a size of 8 (23).

@code{ITEM MyItem LONGWORD UNSIGNED BASEALIGN (3);}

@subsubsection Storage Class Keywords

Storage class refers to the way in which the target language compiler allocates
storage for scalar items and aggregates. In general, declarations produce a
template describing data for which the compiler allocates storage dynamically
at run time, rather than at compile time.  This type of storage is the default
and is specified using the BASED option in some languages, although the default
storage class option is language-dependent. The PL/I back end generates the
BASED storage class option, which has the following syntax:

@code{BASED (pointer-name)}

In languages that support the construct, you can use the BASED pointer-name
option on an AGGREGATE declaration to bind a named pointer to that aggregate.
In all target languages, the aggregate resulting from such a declaration has
the default storage class (BASED).

A subaggregate always acquires the storage class of the aggregate to which it
belongs.  The default storage class associated with any declaration is
language-dependent.  You can override the default storage class by specifying
either of the following storage classes:

@itemize @bullet
@item @strong{Common storage"} is allocated in an external program section
(Psect) with the OVR option and is shared by all routines that reference it.
You declare data in common storage by using the COMMON option on an AGGREGATE
or ITEM declaration. For example, the MACRO back end places all declarations in
an absolute program section by default and associates the names with the offset
values.

@item @strong{Global storage} represents data in a global storage location whose
value is defined elsewhere. You declare global data by using the GLOBAL option
on an AGGREGATE or ITEM declaration.

For some languages, the /GLOBALDEF qualifier on the SDL command affects the
operation of the GLOBAL option. When this qualifier is used, GLOBAL generates a
reference to global data whose value is defined in this module. You can see the
effect of /GLOBALDEF for each output language by processing the OpenSDL source
file EXAMPLE.SDL in SDL$EXAMPLES.

@item @strong{TYPEDEF} behaves like a storage class. In C, examples of storage
classes are static, globaldef/ref, extern, etc. Syntactically, you can replace
a ‘static’ in any declaration with ‘typedef’ and have it compiled. Storage
classes (including TYPEDEF) are mutually exclusive in an SDL declaration.
@end itemize

Example of C type definition:
@example
typedef struct @{int jg$l_i1; int jg$l_i2;@} MyStruct ;
static MyStruct foo ;
@end example
is equivalent to:
@example
static struct @{int jg$l_i1; int jg$l_i2;@} foo ;
@end example
or:
@example
static struct MyStruct @{int jg$l_i1; int jg$l_i2;@} foo ;
@end example
or:
@example
struct MyStruct @{int jg$l_i1; int jg$l_i2;@} ;
static struct MyStruct foo ;
@end example

If COMMON and GLOBAL appear together in a declaration, a DUPCONATT (duplicate
or conflicting attributes) error is given. The COMMON, GLOBAL and TYPEDEF
storage classes are mutually exclusive.

@subsubsection SDL Storage Classes and Typedef Syntax
Explicit SDL Storage classes are COMMON and GLOBAL. To maintain orthogonal
syntax, TYPEDEF is permitted wherever COMMON and GLOBAL are permitted.

The Storage class definition in SDL is included as an option on an ITEM or
AGGREGATE declaration. This means that an AGGREGATE TYPEDEF for the preceding
example would be:

@example
AGGREGATE MyStruct STRUCTURE TYPEDEF PREFIX jg$ ;
    i1 LONGWORD ;
    i2 LONGWORD ;
END ;
@end example

@subsubsection Data Types
In most cases it is possible to refer to a user-defined Data Type where a
standard built-in SDL Data Type (BYTE, LONGWORD etc.) can be referenced.
Reference to the type MyStruct defined in the preceding example is made as
follows:

@code{ITEM foo MyStruct ;}

@subsubsection DIMENSION Keyword

You can apply a dimension to AGGREGATE (as well as members of aggregates and
subaggregates) and ITEM declarations, which means that you can define an array
of structures, a structure that contains one or more arrays, or an array of
structures each of which contains one or more arrays. The DIMENSION option is
valid when specified with any of the data types described in Section 3.2.3 and
has the following syntax:

@code{DIMENSION [lbound:]hbound}

lbound@*
Is any valid OpenSDL expression giving the value of the lowest-numbered element
of the array.  If lbound is not specified, OpenSDL supplies a default lbound of
1.

hbound@*
Is any valid OpenSDL expression giving the number of elements in the array, or,
if lbound is specified, the highest-numbered element.

The following is an example of the DIMENSION option specified on an AGGREGATE
declaration:

@example
AGGREGATE array_info STRUCTURE;
    bound STRUCTURE DIMENSION 8;
        lower LONGWORD;
        upper LONGWORD;
        multiplier LONGWORD;
        constant_lower BITFIELD LENGTH 1;
        constant_upper BITFIELD LENGTH 1;
        constant_multiplier BITFIELD LENGTH 1;
        reserved BITFIELD LENGTH 13;
    END bound;
END array_info;
@end example

The subaggregate bound has eight elements. Each element consists of the members
upper, lower, multiplier, and so on. Because bound is an array, each of its
members (upper, lower, multiplier, and so on) can also be considered an array
of eight elements.  When you specify a single value after the DIMENSION
keyword, as in the previous example, the specified back end assumes that the
value represents the high bound value and supplies a default low bound value of
one. You can override this default by specifying both a low bound and a high
bound value as follows:

@code{ITEM node_pointers DIMENSION 0:255 ADDRESS;}

This declaration results in a declaration of the array node_pointers, whose low
bound is 0 and whose high bound is 255. Only one dimension can be specified for
an AGGREGATE or ITEM declaration. This restriction ensures that there is no
interlanguage conflict in an array declaration.

You can see how OpenSDL translates the DIMENSION option for each output
language by processing the OpenSDL source file EXAMPLE.SDL in SDL$EXAMPLES.

@subsection Data Type Keywords

Data type keywords specify the data types of scalar objects, which can be
declared as members of aggregates or as individual items. Data type keywords are
also used to describe the data types of parameters, as well as the return value
of an ENTRY. They can also be used in an AGGREGATE declaration to generate an
implicit union. The data type declaration also specifies, either implicitly or
explicitly, the size of a member.

The following sections describe the data types and the keywords you use to
specify them.

@subsubsection Pointer Data Types
The keywords ADDRESS, POINTER, POINTER_LONG, POINTER_QUAD, POINTER_HW,
and HARDWARE_ADDRESS specify a data type that is an address, or pointer. The
ADDRESS data type has the following syntax:

@code{pointer-type [ (object-type [ basealign-attribute ] ) ]}@*

pointer-type@*
is one of the keywords ADDRESS, POINTER, POINTER_LONG, POINTER_QUAD,
POINTER_HW, and HARDWARE_ADDRESS.

ADDRESS, POINTER, POINTER_LONG are 4-byte-addresses.
POINTER_HW and HARDWARE_ADDRESS are 4-byte-addresses if /VAX us specified and
8-byte-addresses if /ALPHA is specified.
POINTER_QUAD is an 8-byte-address.

object-type@*
is the optional data type of the object to which the address refers. This
construct is ignored for languages in which pointers are distinct data types.
Object-type is either a built-in object type, like LONGWORD or ANY, or a
user-defined object type, optionally followed by a DIMENSION specification, or
an ENTRY declaration.

basealign-attribute@*
Here, a BASEALIGN attribute can be specified, as described in Section 3.2.2.3.

The following is an example of an aggregate with a member of pointer type:

@example
AGGREGATE any_node STRUCTURE;
    flink ADDRESS (any_node);
    blink ADDRESS (any_node);
END;
@end example

@subsubsection ANY Data Type

The ANY keyword specifies that the parameter being described in an ENTRY
declaration can be of any data type. The ANY data type can be used only within
the context of a parameter description and has the following syntax:

@code{ANY}@*

ANY@*

Specifies that the parameter can be of any data type.
The following is an example of the use of the ANY data type:
ENTRY sys$abc PARAMETER (ANY);

@subsubsection BITFIELD Data Type
The BITFIELD keyword specifies a bit field variable that must be a member of an
AGGREGATE declaration. The BITFIELD data type has the following syntax:

@code{BITFIELD [LENGTH n] [MASK] [SIGNED]}@*

[LENGTH n]
Is any valid OpenSDL expression giving the number of bits in the bitfield. If
no length is specified, OpenSDL uses a default length of 1 bit.

[MASK]
Is a keyword specifying that OpenSDL generate both a bitfield variable and a
constant bit mask representing the bits defined in this field.

[SIGNED]
Is a keyword specifying that OpenSDL treat the output as a signed field.
Bitfields must be AGGREGATE declaration members. They cannot be scalar items,
objects of ADDRESS declarations, parameters, or return data types of entries.
The following is an example of the BITFIELD keyword used in an AGGREGATE
declaration that specifies a structure with two bitfield members:

@example
AGGREGATE flags STRUCTURE PREFIX tst$;
    resolved BITFIELD MASK SIGNED;
    spare_bits BITFIELD LENGTH 5;
END;
@end example

The declaration of resolved in the previous example results in two declarations
in the output file: a declaration for the bitfield itself and a declaration of
a constant mask whose value is 1. Because the PREFIX option is specified for
this aggregate, the source output file identifiers produced for this
declaration are tst$v_resolved and tst$m_resolved, where the tag v_ indicates
the bitfield variable and the tag m_ indicates the mask. Prefixes and tags are
described in more detail in Section 3.2.2.2.

@subsubsection BOOLEAN Data Type

The BOOLEAN keyword specifies a Boolean data type that is a one-byte field that
can have one of two values, 0 or 1. The BOOLEAN data type has the following
syntax:

@code{BOOLEAN}

BOOLEAN
Produces a Boolean variable in the output file.

The following is an example of the BOOLEAN keyword used in an ITEM declaration:

@code{ITEM true BOOLEAN;}

@subsubsection CHARACTER Data Type

The CHARACTER keyword declares a character string of a given length. The
CHARACTER data type has the following syntax:

@example
CHARACTER [LENGTH @{n@}] [VARYING]
          [       @{*@}]
@end example

[LENGTH n]@*
Is the length of the character string. The length can be specified using any
valid OpenSDL expression. If no length is specified, OpenSDL uses a default
length of 1 character. You can specify a character string of unknown length
using LENGTH *.  An unknown length character string can be specified only for
parameter types. For example:

@code{ENTRY LIB$ROUTINE PARAMETER(CHARACTER LENGTH * NAMED foo);}

[VARYING]
Is a keyword indicating that the identifier represents a varying-length
character string (for languages that support this data type). In a
varying-length character string, the first word of the string contains its
current length; its declared length is the maximum length that it can have.

The following is an example of the CHARACTER data type used in an AGGREGATE
declaration.  The aggregate msg_buffer contains a character-string member named
message_text with a length of 256 characters.

@example
AGGREGATE msg_buffer STRUCTURE;
    message_text CHARACTER LENGTH 256 VARYING;
    severity WORD;
END;
@end example

@subsubsection COMPLEX Data Types
The COMPLEX keyword immediately follows any of the four floating-point data
type keywords to specify any of the four COMPLEX data types. The COMPLEX data
types have the following syntax:

@example
T_FLOATING COMPLEX
S_FLOATING COMPLEX
@end example

The following is an example of the T_FLOATING COMPLEX data type used in an ITEM
declaration:

@code{ITEM foo T_FLOATING COMPLEX;}

Section 3.2.3.8 describes floating-point data types.

@subsubsection DECIMAL Data Type
The DECIMAL keyword specifies a packed decimal data type and the size of the
data type.  The DECIMAL data type has the following syntax:

@code{DECIMAL PRECISION (precision,scale)}

PRECISION (precision,scale)@*
Is the fixed-point decimal member’s precision and scale, respectively.
Precision is the total number of decimal digits, and scale is the number of
fractional digits.

Both precision and scale must be specified using valid OpenSDL expressions. 
The following is an example of the DECIMAL keyword used in an ITEM declaration
that indicates a packed decimal data type consisting of three decimal digits,
two of which are fractional:

@code{ITEM percentage DECIMAL PRECISION (3,2);}

@subsubsection Floating-Point Data Types

The floating-point keywords, T_FLOATING, and S_FLOATING, declare storage units
for single-, and double-floating-point data, respectively.
The floating-point data types have the following syntax:

@example
T_FLOATING
S_FLOATING
@end example

The following is an example of the T_FLOATING data type used in an ITEM
declaration:

@code{ITEM foo T_FLOATING;}

Section 3.2.3.6 describes COMPLEX data types.

@subsubsection Integer Data Types
The keywords BYTE, WORD, LONGWORD, QUADWORD, and OCTAWORD declare storage units
of 8, 16, 32, 64, and 128 bits, respectively, to represent signed integer data.
You may also specify the keyword UNSIGNED with any of these data types to
indicate unsigned integer data.

It is also possible to specify the keyword SIGNED.

The keywords INTEGER_BYTE, INTEGER_WORD, INTEGER_LONG and INTEGER_QUAD
are synonyms for BYTE, WORD, LONGWORD, QUADWORD, respectively, although some
back ends treat INTEGER_QUAD and QUADWORD different (C, FORTRAN and PL/I). The
keyword INTEGER is also synonym for LONGWORD and INTEGER_LONG.  The keywords
INTEGER_HW and HARDWARE_INTEGER describe integer data types whose size depends
on the underlying hardware. If the qualifier /VAX is specified, they are 4
bytes wide, and if /ALPHA is specified, they are 8 bytes wide.

The integer data types have the following syntax:

@example
BYTE             [ UNSIGNED | SIGNED ]
INTEGER_BYTE     [ UNSIGNED | SIGNED ]
WORD             [ UNSIGNED | SIGNED ]
INTEGER_WORD     [ UNSIGNED | SIGNED ]
LONGWORD         [ UNSIGNED | SIGNED ]
INTEGER_LONG     [ UNSIGNED | SIGNED ]
INTEGER          [ UNSIGNED | SIGNED ]
QUADWORD         [ UNSIGNED | SIGNED ]
INTEGER_QUAD     [ UNSIGNED | SIGNED ]
OCTAWORD         [ UNSIGNED | SIGNED ]
INTEGER_HW       [ UNSIGNED | SIGNED ]
HARDWARE_INTEGER [ UNSIGNED | SIGNED ]
@end example

The following are examples of the LONGWORD and BYTE data types used in an ITEM
declaration:

@example
ITEM foo LONGWORD UNSIGNED;
ITEM bar BYTE;
@end example

@section Expressions

An OpenSDL expression evaluates to an arithmetic value and can consist of any of
the following syntax elements:

@itemize @bullet
@item Numeric values are, by default, expressed in decimal notation. You can
override this default by preceding a constant with one of the prefixes in the
following table.

@multitable @columnfractions .2 .3 .5
@headitem Prefix @tab Interpretation @tab Valid Characters
@item %X @tab Hexadecimal @tab 0-9, A-F, a-f
@item %O @tab Octal @tab 0-7
@item %B @tab Binary @tab 0 and 1
@item %A@footnote{The %A operator takes the ASCII value of any ASCII character
that follows it.} @tab ASCII value Any ASCII character (see Appendix C)
@end multitable

OpenSDL treats decimal constants as signed integer longword values.

You can also use a string of up to four characters as a numeric constant by
enclosing the string in quotation marks (" "). OpenSDL inserts the ASCII value
of each character into the byte field corresponding to that character’s
position in the string. If the string you specify has fewer than four
characters, OpenSDL pads the string with the null character, which has the
ASCII code of zero.
@item Local symbols and output constants are assigned integer longword values
that are available within the context (that is, during processing) of the input
file.
@item Operators perform arithmetic and logical operations on numeric values,
local symbols, and output constants. The following table lists the operators in
order of precedence, with the operators of higher precedence listed first.

@multitable @columnfractions .2 .8
@headitem Operator @tab Meaning
@item unary - @tab Arithmetic negation
@item * @tab Arithmetic multiplication
@item / @tab Arithmetic division
@item + @tab Arithmetic addition
@item - @tab Arithmetic subtraction
@item @@ @tab Logical shift–x@@y shifts the value of x to the left y places; if
y is negative, the value of x is shifted y places to the right
@item & @tab Logical AND
@item ! @tab Logical OR
@end multitable

@item Offset symbols are used in expressions specified in AGGREGATE
declarations:

@itemize @bullet
@item The period (.) represents the current byte offset from the origin in an 
AGGREGATE declaration. If the ORIGIN option is specified, the value of the
period is equal to the byte offset from the member specified using the ORIGIN
option.

@item The colon (:) represents the current byte offset relative to the first
member in an AGGREGATE declaration. The value is not affected by the presence
of an ORIGIN option.

@item The circumflex (^) represents the current bit offset relative to the most
recently declared aggregate or byte-aligned element.
Section 4.5.8 describes the use of offset symbols in AGGREGATE declarations in
more detail.
@end itemize

@item Parentheses group expressions to define the order of evaluation.
Expressions within the innermost set of parentheses are evaluated first.
The following is an example of an expression used in a CONSTANT declaration,
which appears in the context of an AGGREGATE declaration:

@code{CONSTANT foo EQUALS %Ag + 72 / (#abc * boo + .);}
@end itemize

@section Local Comments

A comment that is local to the OpenSDL source file is not written to the output
file. Local comments begin with the left brace (@{) and extend to the end of
the line. They can appear anywhere within the source file (not necessarily
within a module) where white space (a space, tab, or carriage return) is
allowed. The following is an example of a local comment:

@{Assigning the value 255 to #max_args.

@section Output Comments

Comments appearing on lines by themselves are typically written to the output
file as separate comment lines. Comments appearing at the end of a line are
output at the end of the corresponding target source line, if possible.

Output comments begin with a slash and an asterisk (/*) and terminate at the
end of the current line. They can appear in the following contexts:
@itemize @bullet
@item Outside MODULE declarations

@item At the end of a line containing a declaration, that is, following the 
semicolon terminator(;)

@item On lines by themselves between member, CONSTANT, ENTRY, ITEM, and
AGGREGATE declarations

@item Between declarations with in an aggregate

@item Following individual constant names with in a comma-delimited list of
CONSTANT declarations
@end itemize

The following is an example of an output comment:

@code{/* Get Job/Process Information System Service.}

@section Block Comments

Block comments are those that appear as a large multi-line comment and are
written to the output file as multiple comment lines.

Block comments begin with a slash and a plus sign (/+) and end with a slash and
a minus sign (/-).  Within these begin and end comments, lines beginning with a
double slash (//) will be prefixed with a middle comment (if the target
language supports it).  These comments can appear anywhere Output Comments can
appear.

The following is an example of a block comment:

@example
/+
// Get Job/Process Information System Service.
/-
@end example

@section INCLUDE Statement

The INCLUDE statement specifies that the contents of an external file are to be
incorporated in the OpenSDL input file directly following the INCLUDE
statement. The INCLUDE statement has the following syntax:

@code{INCLUDE "file-spec";}

"file-spec"@*
Is any valid VMS file specification enclosed in quotation marks (" "). An
INCLUDE statement cannot appear embedded within an AGGREGATE declaration, but
can appear anywhere else within the module. If a directory is not included in
the file specification, the current default directory is used.

When OpenSDL encounters an INCLUDE statement, it stops reading from the current
file and reads the statements in the included file. When it reaches the end of
the included file, OpenSDL resumes translation with the source statement
immediately following the INCLUDE statement.

@section READ Statement

The READ statement allows a .SDI intermediate file to be included in an SDL
source, without causing it to be emitted to the output stream. Apart from these
two differences, its operation is similar to INCLUDE.

The READ statement allows previously-compiled definitions, such as constants
and user-defined types, to be used by the current compilation, without
affecting the language output.

The READ statement has the following syntax:

@code{READ "file-spec" ;}

@section Conditional SDL Compilation

@subsection Conditional SDL Compilation using the IFLANGUAGE statement

This feature allows a section of SDL source code to be conditionally compiled,
depending on whether output is being generated for a particular language or
not.

The syntax for conditional compilation has the format:

@example
IFLANGUAGE language-name [ language-name ... ]
    .
    .
    .
[ELSE ;
    .
    .
    .
]
END_IFLANGUAGE [ language-name [ language-name ... ] ] ;
@end example

Note the following:

@itemize @bullet
@item The three keywords may appear wherever a statement is valid.

@item Conditional compilation statements may not be nested.

@item The list of language-names on the END_IFLANGUAGE is optional, but if it
Is included, it must match the list on the IFLANGUAGE statement. The languages
need not necessarily appear in the same order.

@item Language names may not be abbreviated.

@item The validity of language names is not checked.  This is in keeping with
the philosophy of SDL that new back ends may be added without changes to the
front end.

@item A comment on the same line as the IF_LANGUAGE statement is only output
for languages which satisfy the condition.  A comment on the same line as the
END_IFLANGUAGE statement is always output, as this is considered to be outside
the body of the conditional.
@end itemize

In the following example, SDL generates a translation of the ITEM statement if
output is being generated for Pascal, Ada, or FORTRAN. For other languages, SDL
does not generate a translation of the ITEM statement.

@example
IFLANGUAGE PASCAL ADA FORTRAN ;
    ITEM foo LONGWORD;
END_IFLANGUAGE PASCAL ADA FORTRAN;
@end example

@subsection Conditional SDL Compilation using the IFSYMBOL statement

This feature allows a section of SDL source code to be conditionally compiled,
depending on symbols specified with the command line qualifier /SYMBOLS.
The syntax for conditional compilation has the format:

@example
IFSYMBOL symbol-name ;
    .
    .
    .
@{ ELSE_IFSYMBOL symbol-name ;
    .
    .
    .
@}
[ELSE ;
    .
    .
    .
]
END_IFSYMBOL ;
@end example

Note the following:
@itemize @bullet
@item The four keywords may appear wherever a statement is valid.
@item Conditional compilation statements may not be nested.
@item A comment on the same line as the IFSYMBOL statement is only output if
this symbol is specified on the command line. A comment on the same line as the
END_IFSYMBOL statement is always output, as this is considered to be outside
the body of the conditional.
@end itemize

With the following example:

@example
IFSYMBOL s1;
    <sdl code 1>
END_IFSYMBOL;
IFSYMBOL s2;
    <sdl code 2>
ELSE_IFSYMBOL s3;
    <sdl code 3>
ELSE;
    <sdl code 4>
END_IFSYMBOL;
@end example

@command{$ SDL/LANG=<LANGUAGE>/SYMBOLS=(S1=0,S2=0,S3=0) <FILE-SPEC>}

produces

@example
<sdl code 4>
@end example

@command{$ SDL/LANG=<LANGUAGE>/SYMBOLS=(S1=1,S2=0,S3=0) <FILE-SPEC>}

produces

@example
<sdl code 1>
<sdl code 4>
@end example

@command{$ SDL/LANG=<LANGUAGE>/SYMBOLS=(S1=1,S2=1,S3=x) <FILE-SPEC>}

produces

@example
<sdl code 1>
<sdl code 2>
@end example

@command{$ SDL/LANG=<LANGUAGE>/SYMBOLS=(S1=1,S2=0,S3=1) <FILE-SPEC>}

produces

@example
<sdl code 1>
<sdl code 3>
@end example

@section Text Pass-through

Text pass-through allows literal text to be passed through to the output
language file without translation. It is normally used in conjunction with
conditional compilation for a specific target language. The purpose is to allow
language-specific constructs, which cannot be represented in SDL, to be
emitted.

The syntax for text pass-through is:

@example
LITERAL;
Any number of lines to be passed directly to
the output stream without translation
END_LITERAL;
@end example

Note the following:
@itemize @bullet
@item The keywords LITERAL and END_LITERAL may appear wherever a statement is
valid.
@item The keyword END_LITERAL terminates a literal construct, and therefore
cannot be included in a line of literal text.  Any text preceding END_LITERAL
on the same line is output as a line of literal text.
@end itemize

Literal text is processed identically in all back ends. The literal text is
merely written directly to the output file.

The following is an example of text pass-through for the C language.

@example
IFLANGUAGE CC
LITERAL
#define ctext "This appears in C language output only"
END_LITERAL
END_IFLANGUAGE CC
@end example

@section DECLARE Statement

The DECLARE statement allows you to declare a data item of a type that you
define, which may be unknown in the current SDL compilation. When you use
DECLARE, the type is made known when the target language source is compiled.

The DECLARE statement uses the SIZEOF clause to allow you to specify the size
of the user-defined data type being declared. The parameter you specify in the
SIZEOF clause may be a built-in SDL data type, a user-defined type defined in
the current SDL compilation, or an expression.

The DECLARE statement has the following syntax:

@example
DECLARE user-type SIZEOF @{ data-type @}     [ PREFIX prefix-string ]
                         @{ user-type @}     [ TAG tag-string ]
                         @{ ( expression ) @}
@end example

user-type@*
Represents the unknown data type name you wish to declare.

SIZEOF@*
A clause that must be appended to user-type. The SIZEOF clause may be specified
in several ways, as shown, to indicate the size of the user-defined type being
declared.

data-type@*
Represents either a built-in SDL data type, a user-defined type that is known
at SDL compile time, or a data type that has been sized by a previous SIZEOF
clause.

user-type@*
Represents a user-defined data type.

( expression )@*
Represents an expression. If specified, the expression must specify the number
of bytes to be reserved for this data type. If the data type is dimensioned,
the SIZEOF clause must specify the size of a single element. When you specify
an expression, always enclose it in parentheses, as shown in this syntax.

Notes:
@enumerate
@item DECLARE identifies the size of the data type when included in an
AGGREGATE declaration. (SDL needs to know its equivalent predefined type so
that the correct default tag letter, if required, can be output.)

@item You may declare a user-defined data type more than once (either
explicitly or implicitly), but any subsequent declaration must match the first.

@item The default tag letter for the unknown variable being sized is derived
from the type specified in the SIZEOF clause. If you use an expression in place
of a data type to reserve a fixed number of bytes, the default tag letter is T.
You may override the default tag by using an explicit TAG option.

@item SIZEOF clauses cannot be nested.

@item You cannot qualify a reference to the name of a previously-declared
aggregate using the SIZEOF clause.

@item Although DECLARE statements and implicit SIZEOF declarations appear in
the output tree for use by the back ends, these do not result in specific
generated code.

@item Do not use the SIZEOF clause for data types that are aggregate names.
Also, do not nest SIZEOF clauses where the syntax would otherwise allow
aggregate names. For example, the following statements are valid:
@end enumerate

@example
DECLARE type SIZEOF ADDRESS (CHARACTER);
ITEM type ADDRESS (bar SIZEOF LONGWORD);
@end example

However, the following statement generates an error message:

@code{DECLARE type SIZEOF ADDRESS (bar SIZEOF LONGWORD);}

@strong{Examples}@*

A database contains information on a number of forests in a region, each of
which contains a number of different types of trees. The definition of the tree
structure is held in a different SDL file from the other definitions. When the
second SDL file is compiled, the composition of the tree structure is unknown —
the definitions will only come together when the output files are included in a
compilation in the target language.  The following shows the two SDL files and
the corresponding output in C.

@*
@strong{TREE1.SDL:}@*
@example
AGGREGATE tree STRUCTURE TYPEDEF;
    flink ADDRESS (tree);
    blink ADDRESS (tree);
    height LONGWORD;
    age LONGWORD;
END;
@end example

@strong{TREE2.SDL:}@*
@example
DECLARE tree SIZEOF (16);
AGGREGATE forest STRUCTURE TYPEDEF;
    oak tree;
    ash tree;
    elm tree;
    conifers tree DIMENSION 6;
END;
ITEM tree_pointer ADDRESS (tree);
ITEM tree_storage tree DIMENSION 1000;
ITEM region forest DIMENSION 4; @{No SIZEOF, since ’forest’ defined here @}
@end example

@strong{TREE1.H:}@*
@example
typedef struct _tree
@{
    _tree *flink;
    _tree *blink;
    long int height;
    long int age;
@} tree;
@end example

@strong{TREE2.H:}@*
@example
typedef struct _forest
@{
    tree oak;
    tree ash;
    tree elm;
    tree conifers[6];
@} forest;
tree *tree_pointer;
tree tree_storage[1000];
forest region[4];
@end example

Note that the SIZEOF information is discarded by C, but is used by other
languages, such as MACRO.

@chapter OpenSDL Declarations
This chapter describes the function and format of each of the following OpenSDL
declarations:
@itemize @bullet
@item MODULE declaration
@item ITEM declaration
@item AGGREGATE and subaggregate declarations
@item CONSTANT declaration
@item ENTRY declaration
@end itemize

OpenSDL declarations are composed of the language elements described in
Chapter 3. The output generated by each OpenSDL declaration depends on which
back end is used for the translation.

Online examples of output files for each language are available by processing
the OpenSDL source file EXAMPLE.SDL in SDL$EXAMPLES. Appendix B provides
translation summaries for each output language.

MODULE Declaration

The following sections describe the function and format of a MODULE declaration.

@section MODULE Description

A MODULE declaration groups all related symbols and data structures. All
declarations (other than local symbol assignments and local and output
comments) must occur within a module, which is delimited by the MODULE and
END_MODULE keywords.  An OpenSDL source file may contain multiple MODULE
declarations, but modules may not be nested.  You must specify a module name on
the MODULE declaration; this name corresponds to the name of a macro or module
in a given output language. (Section 3.1 describes the syntax for names.) For
example:

@code{MODULE $modef;}

This declaration generates the beginning of the declaration for the macro or
module named $modef.

You can use the IDENT option on a MODULE declaration to pass a version number
or other information that must be enclosed in quotation marks (" ") to the
output file. For example:

@code{MODULE params IDENT "V2.0";}

You can optionally specify the module name on the END_MODULE statement; this is
particularly useful if you place more than one MODULE declaration in the same
OpenSDL source file.  The module name is case-sensitive and must match exactly
(in case) the name specified on the MODULE declaration.

@section MODULE Format
A MODULE declaration has the following syntax:

@example
MODULE module-name [ IDENT "ident-string" ];
    [ module-body ];
        .
        .
        .
END_MODULE [ module-name ];
@end example

MODULE module-name@*
Specifies any valid OpenSDL identifier you want to use to identify the module.

[IDENT "ident-string"]@*
Specifies any valid OpenSDL identifier, or a string of any characters, that
must be enclosed in quotation marks (" ") and that either further identifies
the module or is a version number.

[module-body]@*
Is one or more of the following:
@itemize @bullet
@item ITEM declaration
@item AGGREGATE declaration
@item CONSTANT declaration
@item ENTRY declaration
@item Local symbol assignment
@item Local or output comment
@item INCLUDE statement
@item DECLARE statement
@item READ statement
@item IFLANGUAGE construct
@item IFSYMBOL construct
@item LITERAL construct
@end itemize

END_MODULE [module-name]
Marks the end of the MODULE declaration. The module-name, if specified, must
match the name on the most recently specified MODULE declaration.

@unnumberedsec ITEM Declaration

The following sections describe the function and format of an ITEM declaration.

@section ITEM Description
An ITEM declaration defines scalar items and single-dimensional arrays of
scalar items that are not members of aggregates. You must specify an item name
and data type on the ITEM declaration. For example:

@code{ITEM block_list_id WORD;}

This declaration specifies the scalar item block_list_id of data type WORD.

@section ITEM Format

An ITEM declaration has the following syntax:

@example
ITEM item-name @{ data-type @}         [ COMMON ]
               @{ user-type sizeopt @} [ GLOBAL ]
                                       [ TYPEDEF ]
                                       [ BASEALIGN basealign-option ]
                                       [ DIMENSION [ lbound: ] hbound ]
                                       [ PREFIX prefix-string ]
                                       [ TAG tag-string ];
@end example

ITEM item-name@*
Specifies any valid OpenSDL name used to identify the item.

data-type@*
Is any valid OpenSDL data type (see Section 3.2.3).

user_type sizeopt@*
Is a user-defined data type using the DECLARE statement’s SIZEOF clause, shown
and described in Section 3.10.

[COMMON]@*
[GLOBAL]@*
[TYPEDEF]@*
Is the storage class of the item, if other than the default (based) storage
class (see Section 3.2.2.4).

[BASEALIGN basealign-option ]@*
BASEALIGN specifies the alignment of an ITEM. basealign-option is either an
integer expression in parentheses or the name of a data type.
BASEALIGN aligns the item on a multiple of the value of the basealign-option.

[DIMENSION [lbound:]hbound]@*
Specifies that the item is an array. If a single value is specified, that value
indicates the number of elements in the array.  Otherwise, lbound and hbound
represent lower and upper bounds of the array, respectively (see Section
3.2.2.7).

[PREFIX prefix-string]@*
Specifies a user-defined prefix that becomes part of the identifier. It can be
any valid OpenSDL name with 0 to 32 characters, may or may not be enclosed in
quotation marks (" ") and may be null (see Section 3.2.2.2).

[TAG tag-string]@*
Specifies the user-defined tag that follows the prefix used in forming the
identifier. It can be any valid OpenSDL name with 0 to 32 alphabetic or numeric
characters; the tag must be enclosed in quotation marks (" ") if it begins with
a numeric character (see Section 3.2.2.2).

@unnumberedsec AGGREGATE Declaration

The following sections describe the function and format of AGGREGATE and
subaggregate declarations.

@section AGGREGATE Description

An AGGREGATE declaration defines nonscalar items and dimensional arrays of
nonscalar items. An aggregate must contain at least one member declaration. The
body of an aggregate can also contain local symbol assignments, CONSTANT
declarations, and subaggregate declarations.

You must specify a valid aggregate name on the AGGREGATE declaration. For
example:

@example
AGGREGATE dcb STRUCTURE;
    type CHARACTER;
    size WORD;
    next ADDRESS;
END dcb;
@end example

You must terminate an AGGREGATE declaration with the END statement. You can
optionally specify the aggregate name on the END statement. The aggregate name
is case-sensitive and must match exactly (in case) the name specified on the
AGGREGATE declaration.

An aggregate that is the target of an ADDRESS declaration must have the default
(BASED) storage class.

@subsection Subaggregate Declaration

Subaggregates are declared using the keyword STRUCTURE or UNION. Within an
aggregate, subaggregates can be nested up to eight levels deep. For example:

@example
AGGREGATE tree_node STRUCTURE;
    opcode WORD;
    lang_bits UNION;
        pli_bits STRUCTURE;
            resolved BITFIELD;
            psv BITFIELD;
            mark1 BITFIELD;
            spare_bits BITFIELD LENGTH 5;
        END pli_bits;
        c_bits STRUCTURE;
            value_variable_size BITFIELD;
            psv BITFIELD;
            expanded BITFIELD;
            resolved BITFIELD;
            reduced BITFIELD;
            spare_bits BITFIELD LENGTH 3;
        END c_bits;
    END lang_bits;
END tree_node;
@end example

In this example, the structures pli_bits and c_bits are both subaggregates of
the union lang_bits. Because lang_bits is a union, c_bits and pli_bits occupy
the same storage.

The COMMON, GLOBAL, BASED pointer-name, and ORIGIN options are invalid for a
subaggregate. All other AGGREGATE options are valid.

@subsection STRUCTURE Declaration

STRUCTURE declarations produce aggregate or subaggregate declarations that are
structures.  The members are not overlaid; each member has a unique offset from
the beginning of the structure, which means that members occupy consecutive
storage locations.

The following shows the syntax of a first-level STRUCTURE declaration:

@code{AGGREGATE aggregate-name STRUCTURE [ options ];}

The following shows the syntax of a STRUCTURE declaration as an aggregate
member, that is, a subaggregate STRUCTURE declaration:

@code{member-name STRUCTURE [ options ];}

@subsection UNION Declaration

UNION declarations produce aggregate or subaggregate declarations that are
unions. The first-level members are overlaid, which means that they occupy the
same storage location.

Each first-level member begins at the beginning of the union and, thus, has an
offset of zero.  A UNION declaration lets you represent the same storage
location using different names and different data types.

The following shows the syntax of a first-level UNION declaration:

@code{AGGREGATE aggregate-name UNION [ options ];}

The following shows the syntax of a UNION declaration as an aggregate member,
that is, a subaggregate UNION declaration:

@code{member-name UNION [ options ]}

@subsection Implicit Union Declarations

You may specify data types on an AGGREGATE declaration to cause the AGGREGATE
declaration to become an implicit union declaration.  An implicit union
declaration has these features:

@itemize @bullet
@item Gives SDL the ability to detect subfield overflow without the need to 
define extraneous STRUCTURE and UNION declaration names.
@item Makes user-defined fill fields unnecessary. This feature is most useful
for data structures containing substructures that are required to begin at
fixed offsets.
@end itemize

The following OpenSDL source code shows the syntax of an implicit union
(structure B defines the implicit union declaration):

@example
AGGREGATE A STRUCTURE;
    B STRUCTURE LONGWORD;
        bit_string1 BITFIELD LENGTH 1;
        bit_string2 BITFIELD LENGTH 4;
    END B;
    last_item WORD;
END A;
@end example

This implicit union declaration would be more cumbersome if represented as
shown in the following STRUCTURE subaggregate:

@example
AGGREGATE A STRUCTURE;
    X UNION ;
        B LONGWORD;
        Y STRUCTURE ;
            bit_string1 BITFIELD LENGTH 1;
            bit_string2 BITFIELD LENGTH 4;
        END Y;
    END X;
    last_item WORD;
END A;
@end example

In the previous example, the names X and Y become OpenSDL generated ‘‘filler’’
names in the implicit union case.

You do not have to define the union X and the structure Y if an implicit union
declaration is used.  By giving the structure Y a type, OpenSDL creates a union
of field Y with the specified type overlaid with a structure containing the
fields in Y. In some language translations, such as BLISS and MACRO, the
OpenSDL-generated union and structure (X and Y above) can be suppressed in the
output because they are considered extraneous fields. In other languages, such
as PL/I and C, it is necessary to use the OpenSDL-generated union and structure
to generate the correct offsets within a structure. Because the union is of the
length specified in the structure type, no filler is necessary to ensure that
subsequent fields (for example, last_item) are at the correct offset.  If the
fields of a structure extend past the size specified, OpenSDL flags the
overflow.  The PL/I translation for the previous implicit union declaration
example is as follows:

@example
DCL 1 A BASED ,
     2 fill_0 union,
      3 B fixed binary(31),
      3 fill_1 ,
       4 bit_string1 bit(1),
       4 bit_string2 bit(4),
       4 fill_1$$v_fill_2 bit(3),
     2 last_item fixed binary(15);
@end example

The OpenSDL source file EXAMPLE.SDL in SDL$EXAMPLES shows an example of an
implicit union declaration.

@subsection Implicit Union Declarations with the Optional DIMENSION Keyword

The following is an example of an OpenSDL structure defined with a data type and
the DIMENSION keyword:

@example
AGGREGATE fid STRUCTURE WORD DIMENSION 3;
    first WORD;
    second WORD;
    third WORD;
END fid;
@end example

In the previous example, a single structure is overlaid by an array of elements
of the type specified by the structure type.

The fid structure is a three-word field that can be addressed as a single field
or by each individual word so that it is easily defined in OpenSDL as
represented above. The following is the PL/I translation for the OpenSDL source
code in the previous example:

@example
DCL 1 fill_0 union BASED ,
     2 fid (1:3) fixed binary(15),
     2 fill_1 ,
      3 first fixed binary(15),
      3 second fixed binary(15);
      3 third fixed binary(15);
@end example

The implicit union declaration allows structures to grow without the need to
modify any trailing fillers. OpenSDL detects any overflow that may occur if the
structure grows past the size of its data type. The size of the aggregate (in
bytes) is equal to the size of the data type (in bytes) multiplied by the upper
dimension (if any). If the size of the aggregate is greater than the sum of the
size of all its members, OpenSDL still translates the declaration. However, if
the size of the members exceeds the size of the aggregate, OpenSDL issues a
message that has the following format:

@code{%SDL-E-TOOMANYFIELDS, Structure fill_0 has too many fields [Line ?]}

In the previous example, fill_0 is the OpenSDL-generated name for the first
union aggregate.

@subsection Forcing Negative Offsets

The default origin of an aggregate is the beginning of the first aggregate
member. You may specify the ORIGIN option on a level-1 AGGREGATE declaration to
indicate that the origin is located at the beginning of any aggregate member.
The resulting declaration forces all aggregate members declared before the
specified origin to be located at negative offsets from the origin.  For
example:

@example
AGGREGATE nodes STRUCTURE ORIGIN qflink;
    flink ADDRESS;
    blink ADDRESS;
    qflink ADDRESS;
    qblink ADDRESS;
END;
@end example

This declaration defines the origin of the structure nodes to be at the member
qflink, so you may address flink and blink as negative offsets from qflink.
Specifying an origin does not change the values of the current bit and byte
offset symbols (^ and :). These are always calculated as being relative to the
beginning of the aggregate.

@subsection Forcing Data Alignment

OpenSDL forces all AGGREGATE and subaggregate declarations to begin on byte
boundaries.  Thus, if an aggregate or subaggregate ends with BITFIELD
declarations that do not end on byte boundaries, OpenSDL ensures that the next
aggregate begins on a byte boundary by supplying BITFIELD declarations as
fillers, if necessary.

When OpenSDL adds BITFIELD declarations, it determines the length required and
provides a unique name of the form string$V_FILL_n.  The string is the prefix
supplied in the AGGREGATE declaration, or the aggregate name if no prefix was
supplied. Within an aggregate, n begins at 0 and is incremented for each filler
required.

The subaggregate declarations shown in the following example declare filler
bitfields to force byte alignment at the end of each subaggregate; this
programming practice makes it unnecessary for OpenSDL to perform the alignment.

@example
AGGREGATE tree_node STRUCTURE;
    opcode WORD;
    lang_bits UNION;
        pli_bits STRUCTURE;
            resolved BITFIELD;
            psv BITFIELD;
            mark1 BITFIELD;
            spare_bits BITFIELD LENGTH 5;
        END pli_bits;
        c_bits STRUCTURE;
            value_variable_size BITFIELD;
            psv BITFIELD;
            expanded BITFIELD;
            resolved BITFIELD;
            reduced BITFIELD;
            spare_bits BITFIELD LENGTH 3;
        END c_bits;
    END lang_bits;
END tree_node;
@end example

The current bit offset is set at 0 at the beginning of each aggregate and is
incremented by the bit lengths of each structure member in the aggregate at that
level.  In the following example, OpenSDL forces the structure flags to be
aligned on a byte boundary.

@example
AGGREGATE dcb STRUCTURE PREFIX dcb$;
        .
        .
        .
    uflags STRUCTURE;
        context BITFIELD LENGTH 3;
        local BITFIELD;
    END uflags;
    flags STRUCTURE;
        extern BITFIELD;
        relo BITFIELD;
    END flags;
@end example

The PL/I translation of the OpenSDL AGGREGATE declaration in the previous
example is as follows:

@example
%replace dcb$s_dcb by 2;
dcl 1 dcb based,
     2 dcb$r_uflags ,
      3 dcb$v_context bit(3),
      3 dcb$v_local bit(1),
      3 dcb$v_fill_0 bit(4),
     2 dcb$r_flags ,
      3 dcb$v_extern bit(1),
      3 dcb$v_relo bit(1),
      3 dcb$v_fill_1 bit(6);
@end example

The bit offsets of the members of the structures in the previous OpenSDL
example are shown in the following table.

@multitable @columnfractions .2 .8
@headitem Member @tab Bit Offset
@item dcb$v_context @tab 0
@item dcb$v_local @tab 3
@item dcb$v_fill_0 @tab 4
@item dcb$v_extern @tab 0
@item dcb$v_relo @tab 1
@item dcb$v_fill_1 @tab 2
@end multitable

@subsection Using Offset Symbols

The period (.) represents the current byte offset from the origin in an
AGGREGATE declaration.  If the ORIGIN option is specified, the value of the
period is equal to the byte offset from the member specified using the ORIGIN
option. The current byte offset is useful for capturing the size of an
aggregate or a portion of it. For example, in the declaration of a
variable-length data structure, you can capture the size of the fixed-length
portion.

The colon (:) represents the current byte offset relative to the first member
in an AGGREGATE declaration. The value is not affected by the presence of an
ORIGIN option.

The circumflex (^) represents the current bit offset relative to the most
recently declared aggregate or byte-aligned element.

The following example shows the use of the byte offset symbols.

@example
AGGREGATE operator STRUCTURE PREFIX opr_;
    flink ADDRESS;
    blink ADDRESS;
    opcount WORD;
    optype CHARACTER LENGTH 1;
    id WORD;
    flags STRUCTURE;
        is_constant_size BITFIELD LENGTH 1;
        is_terminator BITFIELD LENGTH 1;
        context BITFIELD LENGTH 3;
        filler BITFIELD LENGTH 8-^;
    END;
    #opsize = .;
    operands LONGWORD DIMENSION(#max_args);
    #instruction_size = :;
END;

CONSTANT node_size EQUALS #opsize / 2;
CONSTANT inst_size EQUALS #instruction_size;
@end example

In the previous example, the local symbol #opsize captures the byte offset
following the fixed length portion of the structure operator. This value is
subsequently used in the CONSTANT declaration, which defines the size of the
constant portion of the structure in words.  The flags structure is byte
aligned by the field filler, which makes use of the current bit offset symbol
to compute the size of this field.  The CONSTANT inst_size defines the size of
the entire structure.

@section AGGREGATE Format

An AGGREGATE declaration has the following syntax:

@example
AGGREGATE aggregate-name @{ STRUCTURE @} [ data-type ]
                         @{ UNION @}
                                         [ COMMON ]
                                         [ GLOBAL ]
                                         [ TYPEDEF ]
                                         [ BASED pointer-name ]
                                         [ ALIGN ]
                                         [ NOALIGN ]
                                         [ BASEALIGN basealign-option ]
                                         [ DIMENSION [ lbound: ] hbound ]
                                         [ MARKER marker-string ]
                                         [ PREFIX prefix-string ]
                                         [ TAG tag-string ]
                                         [ ORIGIN member-name ]
                                         [ FILL ];
    aggregate-body
        .
        .
        .
END [ aggregate-name ];
@end example

AGGREGATE aggregate-name@*
Specifies any valid OpenSDL name used to identify the aggregate.

@{STRUCTURE@}@*
@{UNION@}@*
Is the type of aggregate (see Section 4.5).

[data-type]@*
If specified, causes the AGGREGATE declaration to become an implicit union
declaration (see Section 4.5).

[COMMON]@*
[GLOBAL]@*
[BASED pointer-name]@*
[TYPEDEF]@*
Is the storage class of the aggregate, if other than the default (BASED) (see
Section 3.2.2.4). If an aggregate is the object of an ADDRESS declaration, it
must have either the default or the BASED pointer-name storage class.

[ALIGN]@*
[NOALIGN]@*
[BASEALIGN basealign-option]@*
The ALIGN and NOALIGN keywords can be used to align (or de-align) the members
of an aggregate on their natural boundary. The BASEALIGN keyword ensures that
the size of an aggregate is a multiple of the given alignment. The BASEALIGN
keyword therefore takes an argument, which specifies the alignment, either an
expression in parenthesis or the name of a data type.

For example:

@code{AGGREGATE MyStruct STRUCTURE ALIGN;}

This aligns every member in the structure.

@code{AGGREGATE MyStruct STRUCTURE NOALIGN;}

No action will be taken to ensure that the members of the aggregate will be
aligned.

@code{AGGREGATE MyStruct STRUCTURE BASEALIGN (8);}

The aggregate will be padded, so that in an array of elements of this
aggregate, all elements will have a size that is a multiple of the given
alignment (256, 28).  Alignment attributes on aggregates can be partially
overridden by specifying alignment attributes on the members of the aggregate.
See also Section 3.2.2.3.

[DIMENSION [lbound:]hbound]@*
Specifies that the aggregate is an array. If a single value is specified, that
value indicates the number of elements in the array. Otherwise, lbound and
hbound represent lower and upper bounds of the array, respectively.

[MARKER marker-string]@*
Specifies the prefix used to form the aggregate name. It may be any valid
OpenSDL name with 0 to 32 characters, may or may not be enclosed in quotation
marks (" ") and may be null.

[PREFIX prefix-string]@*
Specifies the prefix used in forming the names of aggregate members. It may be
any valid  SDL name with 0 to 32 characters, may or may not be enclosed in
quotation marks (" ") and may be null (see Section 3.2.2.2).

[TAG tag-string]@*
Specifies the tag used to form the aggregate name. The tag is appended to the
prefix, if a prefix was specified. It can have 0 to 32 alphabetic or numeric
characters; the tag must be enclosed in quotation marks (" ") if it begins with
a numeric character (see Section 3.2.2.2).

[ORIGIN member-name]@*
Specifies the name of a member of this aggregate that is to be used as the
origin of the aggregate.

Member declarations produce declarations of the members of an aggregate and
have the following syntax:

@example
member-name @{ data-type @}         [ ALIGN ]
            @{ aggregate-name @}    [ NOALIGN ]
            @{ user-type sizeopt @} [ BASEALIGN basealign-option ]
                                    [ DIMENSION [ lbound: ] hbound ]
                                    [ PREFIX prefix-string ]
                                    [ TAG tag-string ]
                                    [ FILL ];
@end example

member-name@*
Is any valid OpenSDL name used to identify the member.

@{data-type@}@*
Is any valid OpenSDL data type (see Section 3.2.3).

@{aggregate-name@}@*
Is the name of the previously declared aggregate to be used as a type name. The
name must be the full (OpenSDL-expanded) aggregate name, including the prefix
and tag.

@{user-type sizeopt@}@*
Is a user-defined variable using the DECLARE statement’s SIZEOF clause, shown
and described in Section 3.10.

[ALIGN]@*
[NOALIGN]@*
[BASEALIGN basealign-option]@*
Alignment attributes on a structure can be overridden with alignment attributes
on a member declaration. For example:

@code{StructMember1 LONGWORD SIGNED ALIGN;}

This ensures that the member is aligned, even if it is within an aggregate that is not aligned.

@code{StructMember1 LONGWORD SIGNED NOALIGN;}

No action will be taken to ensure that this member will be aligned.

@code{StructMember1 LONGWORD SIGNED BASEALIGN (4);}

Here, StructMember1 will have an offset that is a multiple of 16 (24).

basealign-option can either be an expression in parentheses or the name of a
data type.  See also Section 3.2.2.3.

[DIMENSION [lbound:]hbound]@*
Specifies that the member is an array. If a single value is specified, that
value indicates the number of elements in the array. Otherwise, lbound and
hbound represent lower and upper bounds of the array, respectively (see Section
3.2.2.7).

[PREFIX prefix-string]@*
Specifies the prefix used to form the member name. For subaggregates, the
prefix is used to form the names of subaggregate members.  It may be any valid
OpenSDL name with 0 to 32 characters, may or may not be enclosed in quotation
marks (" ") and may be null (see Section 3.2.2.2).

[TAG tag-string]@*
Specifies the tag used to form the member name. The tag is appended to the
prefix, if a prefix was specified. It can have 0 to 32 alphabetic or numeric
characters; the tag must be enclosed in quotation marks (" ") if it begins with
a numeric character (see Section 3.2.2.2).

[FILL]@*
Indicates that the specified member or aggregate occurs only as a fill to force
byte alignment on the following member or aggregate, respectively.  In some
languages, filler member and aggregate declarations do not appear in the output
file.

aggregate-body@*
Is one or more of the following:
@itemize @bullet
@item Member declaration
@item Subaggregate declaration
@item CONSTANT declaration
@item Local symbol assignment
@end itemize

END [ aggregate-name ]@*
Marks the end of the AGGREGATE or subaggregate declaration. The aggregate-name,
if specified, must match the name on the most recently specified AGGREGATE or
subaggregate declaration.

@unnumberedsec CONSTANT Declaration

The following sections describe the function and format of a CONSTANT
declaration.

@section CONSTANT Description
A CONSTANT declaration generates a list of one or more named constants in the
output file.  You may specify a valid constant name or names and the constant
values to be assigned to them. For example:

@example
CONSTANT block_node_size EQUALS 24;

CONSTANT Strcon EQUALS STRING "This is a string constant" PREFIX Jg$
@end example

The first declaration creates the named constant block_node_size and assigns it
the value 24. The second declaration creates the named string constant Strcon
and assigns it the specified value.

The values of both declared constants (except string constants) and local
symbols may be used in OpenSDL expressions. However, there is an important
difference between declared constants and local symbols: declared constants are
translated directly to the output file, whereas local symbols are not passed
directly to the output file. For example, you can define the local symbol
#block_size as follows:

@code{#block_size = 24;}

A subsequent CONSTANT declaration may refer to #block_size and use the value
24, as follows:

@code{CONSTANT block_node_size EQUALS #block_size;}

CONSTANT declarations (except string constants) can also be specified in a
comma-delimited list, as follows:

@example
CONSTANT
    xyz EQUALS 10,
    alpha EQUALS 0,
    noname EQUALS 63;
@end example

To specify related constants with the same or incremental values, use a
CONSTANT declaration with the INCREMENT option. In this form, the EQUALS
expression gives the value to be assigned to the first named constant; values
for subsequent constants are derived by incrementing the first value by the
specified increment and assigning the result to the next name in the list. For
example:

@example
CONSTANT (
    bits,
    bytes,
    words,
    longs,
    quads,
    octas
    ) EQUALS 0 INCREMENT 1 PREFIX ctx$;
@end example

When OpenSDL assigns incremental values, it loops until values are assigned to
all the names in a list. If there is no INCREMENT clause, the increment value
is 0; thus, the same initial value is assigned to all the names. If names are
omitted from a comma-delimited list, SDL reserves the numbers that would be
assigned to names in those positions. This lets you reserve numeric values for
later assignment of names. For example:

@example
CONSTANT
    (bad_block,bad_data,,,,
     overlay,rewrite) EQUALS 0 INCREMENT 4;
@end example

In the previous example, OpenSDL assigns the values 0 and 4 to the names
bad_block and bad_data, reserves the values 8, 12, and 16, and assigns the
values 20 and 24 to the names overlay and rewrite.

The COUNTER option saves the last assigned value in a specified local symbol
for subsequent use. For example:

@example
CONSTANT (pli,c,bliss,macro)
    EQUALS 4 INCREMENT 4 PREFIX lang$
    COUNTER #lang;

CONSTANT (basic,pascal,fortran)
    EQUALS #lang + 4 INCREMENT 4 PREFIX lang$;
@end example

The following table shows the constant names produced by these two
declarations.

@multitable @columnfractions .3 .7
@headitem Constant Name @tab Value
@item lang$k_pli @tab 4
@item lang$k_c @tab 8
@item lang$k_bliss @tab 12
@item lang$k_macro @tab 16
@item lang$k_basic @tab 20
@item lang$k_pascal @tab 24
@item lang$k_fortran @tab 28
@end multitable

You can comment individual declarations in a CONSTANT declaration list. For
example:

@example
CONSTANT(
    pli, /* PL/I
    c, /* C
    macro /* MACRO-32
    ) EQUALS 4 INCREMENT 4 PREFIX lang$;
@end example

@strong{Defining Global Constants in MACRO}

OpenSDL does not directly generate definitions for global symbols (constants),
but instead generates local constant definitions. The MACRO back end, however,
generates all declarations within macros so that they can be invoked with
arguments that will produce global definitions.

OpenSDL also produces MACRO output declarations that can generate global
definitions when an invocation of the macro is assembled. In the following
example, the OpenSDL module $IODEF contains the following constant
declarations:

@example
CONSTANT (
    nop,
    unload,
    loadmcode,
    seek,
    spacefile,
    startmproc,
    recal,
    stop,
    drvclr,
    initialize) EQUALS 0 INCREMENT 1 PREFIX "io$";
@end example

The MACRO output generated by this declaration is a macro definition that must
be invoked as follows in order to result in global rather than local constant
definitions:

@code{$IODEF <= =>}

This argument results in global constant definitions rather than local constant
definitions.  To request that the locations of data fields be defined globally,
add the argument @code{<::>} following @code{<= =>}.

@section CONSTANT Format

A CONSTANT declaration has the following syntax:

@example
CONSTANT constant-name constant-class
    constant-class = @{ EQUALS expression numeric-options @}
                     @{ EQUALS STRING string string-options @}
    numeric-options = [ PREFIX prefix-string ]
                      [ TAG tag-string ]
                      [ COUNTER #local-name ]
                      [ TYPENAME type-name ] ;
    string-options =  [ PREFIX prefix-string ]
                      [ TAG tag-string ] ;

CONSTANT (constant-name,...) EQUALS expression
                      [ INCREMENT expression ]
                      [ PREFIX prefix-string ]
                      [ TAG tag-string ]
                      [ COUNTER #local-name ]
                      [ TYPENAME type-name ];

CONSTANT (constant-name,...) EQUALS expression,
        .
        .
        .
    ;
@end example

CONSTANT constant-name@*

Specifies any valid OpenSDL name used to identify the constant.
When more than one name is specified, separate the names with commas and
enclose the list in parentheses.

EQUALS expression@*
EQUALS STRING string@*
Specifies the value to be assigned to the constant.

[PREFIX prefix-string]@*
Specifies the prefix used to form the constant name. It may be any valid
OpenSDL name with 0 to 32 characters, may or may not be enclosed in quotation
marks (" ") and may be null (see Section 3.2.2.2).

[TAG tag-string]@*
Specifies the tag used to form the constant name. The tag is appended to the
prefix, if a prefix was specified. It can have 0 to 32 alphabetic or numeric
characters; the tag must be enclosed in quotation marks (" ") if it begins with
a numeric character (see Section 3.2.2.2).

[COUNTER #local-name]@*
Specifies the local symbol assigned to the last value that is assigned to a
constant in the list.

[TYPENAME type-name]@*
Specifies a named data type that is not an OpenSDL data type.

(constant-name,...)@*
Is a list of valid names.
A constant-name in this list can be null, though the list itself cannot be
null.  If a member of the list is null, the corresponding value is reserved.
If INCREMENT is not specified, all names are assigned the value specified in
the EQUALS expression.

[INCREMENT expression]@*
Specifies the value to be added to the EQUALS expression for each iteration of
OpenSDL’s generation of named CONSTANT declarations. It must be a valid OpenSDL
integer expression. OpenSDL assigns the value of the EQUALS expression to the
first constant name; the value of the INCREMENT expression is added to the
EQUALS expression and assigned to the next constant name.

@unnumberedsec ENTRY Declaration

The following sections describe the function and format of the ENTRY
declaration.

@section ENTRY Description

An ENTRY declaration produces an external procedure or function declaration in
the output file. You must specify a valid entry name on the ENTRY declaration.
You may also specify any or all of the ENTRY declaration options described in
Table 3–2 in Section 3.2.2 and shown within the context of an ENTRY declaration
in Section 4.10.

The following example shows the ENTRY declaration for the VMS system service
SYS$GETJPI:

@example
ENTRY SYS$GETJPI ALIAS $GETJPI PARAMETER (
    LONGWORD UNSIGNED VALUE NAMED EFN DEFAULT 0 TYPENAME EFNUM,
    LONGWORD UNSIGNED NAMED PIDADR IN OUT DEFAULT 0 TYPENAME PROCID,
    CHARACTER DESCRIPTOR NAMED PRCNAM IN DEFAULT 0 TYPENAME PROCNAME,
    ANY NAMED ITMLST IN TYPENAME ITEMLIST,
    QUADWORD UNSIGNED NAMED IOSB OUT DEFAULT 0 TYPENAME IOSB,
    ADDRESS(ENTRY) NAMED ASTADR DEFAULT 0 TYPENAME ASTADR,
    LONGWORD UNSIGNED VALUE NAMED ASTPRM DEFAULT 0 TYPENAME USERPARM
    ) RETURNS LONGWORD TYPENAME CONDVALU;
@end example

@section ENTRY Format

An ENTRY declaration has the following syntax:

@example
ENTRY entry-name [ ALIAS internal-name ]
                 [ PARAMETER (param-desc,...) ]
                 [ LINKAGE link-name ];
                 [ VARIABLE ]
                 [ RETURNS return-data-type [ NAMED param-name ] ]
                 [ TYPENAME type-name ];
@end example

ENTRY entry-name@*
Specifies any valid OpenSDL name used to name the external entry point.

[ALIAS internal-name]@*
Specifies an alternate internal name used to designate the entry point.

[PARAMETER (param-desc,...)]@*
Describes the parameters of the external entry, if any. Param-desc must be
specified as follows:

@example
@{ data-type @}      [ DESCRIPTOR ]    [ IN ]
@{ aggregate-name @} [ RTL_STR_DESC ]
                     [ VALUE ]         [ OUT ]
                     [ REFERENCE ]
                                       [ NAMED param-name ]
                                       [ DIMENSION expression ]
                                       [ DEFAULT constant-value ]
                                       [ TYPENAME type-name ]
                                       [ OPTIONAL ]
                                       [ LIST ]
@end example

@{data-type@}@*
Is any valid OpenSDL data type.

@{aggregate-name@}@*
Is the name of a previously declared aggregate that describes the data type of
the parameter.

[DESCRIPTOR]@*
Indicates that the parameter is passed by descriptor.

[RTL_STR_DESC]@*
Indicates that the parameter can be passed by any of the classes of string
descriptors. The data type must be CHARACTER. For example:

@code{ENTRY xyz PARAMETER ( CHARACTER RTL_STR_DESC );}

[VALUE]@*
Indicates that the parameter is passed by immediate value.

[REFERENCE]@*
Indicates that the parameter is passed by reference. REFERENCE is the default.

[IN]@*
Indicates an input parameter. IN is the default.

[OUT]@*
Indicates an output parameter.

[NAMED param-name]@*
Specifies the parameter name.

[DIMENSION expression]@*
Is the number of elements of an array parameter.
If expression is an asterisk (*), the number of dimensions depends on the
dimensions of the actual parameter.

[DEFAULT constant-value]@*
Specifies a default value for a parameter. In languages supporting this option,
the omission of an actual parameter is allowed.

[TYPENAME type-name]@*
Specifies a named data type that is not an OpenSDL data type.

[OPTIONAL]@*
Specifies that the parameter may or may not appear in the sequence of (keyword)
parameters for a call using the entry point name. This is supported only in
Ada, BASIC,  BLISS, MACRO, and PL/I output.

[LIST]@*
Indicates that the routine may be called with one or more parameters of the
type being described. LIST may be specified only for the last parameter.

@quotation NOTE
All the PARAMETER options, if specified, must follow the data type or aggregate
name in the declaration.
@end quotation

[LINKAGE link-name]@*
Specifies (for MACRO only) that a special call macro (spelled ‘‘link-name’’)
will be used in the expansion of the entry macro.

[VARIABLE]@*
Indicates that not all parameters are described; that is, the entry point has a
variable number of parameters and not all corresponding arguments need be
present in the argument list when the entry point is invoked. See also the
description of the LIST parameter option.

[RETURNS return-data-type [NAMED param-name]]@*
Specifies the data type and, optionally, the name of the parameter returned by
the external entry, if it is a function.

The VOID keyword cannot be used in a PARAMETER clause.

The syntax is:

@example
return-data-type = @{ data-type @}
                   @{ user-type sizeopt @}
                   @{ VOID @}
@end example

The argument user-type sizeopt specifies a user-defined type declared using the
DECLARE statement’s SIZEOF clause, shown and described in Section 3.10.

The return type VOID indicates that the procedure returns no value.

[TYPENAME type-name]@*
Specifies a named data type for the return value that is not an OpenSDL data
type.

@appendix A

@unnumberedsec OpenSDL Diagnostic Messages

This appendix summarizes the OpenSDL diagnostic messages. All messages
indicating errors in OpenSDL syntax specify the line number in the OpenSDL
source file at which the error occurred.

ABORT, Fatal internal error; unable to continue execution
Fatal: An internal error has occurred.
User Action: Please report the problem to HP.

ADROBJBAS, Address object object-name must have based storage class [Line n]
Error: An address item is pointing to an aggregate that is not based.
User Action: Change the storage class of the aggregate to BASED.

BADNODETYPE, internal node type is unknown for language language-name
Warning: A language backend has encountered a node type in the parsed SDL input
that reflects an SDL element which the language does not support. For example,
OpenVMS DCL does not support aggregates or entries, only constants.
User Action: Depending on your needs, ignore the warning or change the SDL
input file.

BASEALIGN, Invalid expression with BASEALIGN option. Value must be in range 0
to 124. basealign-parameter [Line n]
Error: The value for the /BASEALIGN qualifier is smaller than 0 or larger than
124.
User Action: Use a value in the range [0 ... 124].

BUGCHECK, Internal consistency failure [Line n] - please submit a bug report
Fatal: SDL has detected an internal error or inconsistency.
User Action: Please submit a bug report to Technical Languages and Environments
(TL&E).

DIMENSIONSTAR, DIMENSION * for MEMBER "member-name" has no known discriminant
[Line n]
Warning: The use of "DIMENSION *" within an aggregate is not allowed.
User Action: Use fixed values for "DIMENSION" within all aggregate.

DUPCONATT, Item item-name has duplicate or conflicting attributes [Line n]
Error: A declaration contains keywords that are not compatible.
User Action: Verify the syntax of the OpenSDL declaration, correct the
declaration, and invoke OpenSDL again.

ERREXIT, Error exit
Fatal: Previous errors prevent continuation.
User Action: Correct the errors and invoke OpenSDL again.

FILFORMUNSUPP, RMS file format error reading intermediate file.
Error: An intermediate file (.SDI) cannot be read due to wrong RMS attributes.
User Action: Make sure that the intermediate file is a sequential file,
variable length, maximum 510 bytes, longest 510 bytes, carriage return carriage
control.

FIXUP, Temporary hardcoded list used to discriminate for MEMBER "member-name"
[Line n]
Informational: From the comment in the SDLADA backend:
This is informational, with the first line otherwise being identical to a
warning, to aid diagnosing problems where someone makes a copy of a construct
on our hardcoded list without changing SDL.
This message is issued together with the DIMENSIONSTAR diagnostic.
User Action: See DIMENSIONSTAR.

IDENTGTR31, SDL-generated identifier longer than 31 characters exceeds capacity
of language-name compiler [Line n]
Warning: The Pascal backend appends "$TYPE" to data types that contain "DEF".
The resulting name then can exceed 31 characters, the maximum length of Pascal
type names on OpenVMS.
User Action: Don’t use "DEF" in your type names and/or shorten your type names.

ILLFORWREF, Illegal forward reference for output language language [Line n]
Error: The specified output language does not allow forward referencing, or the
language does not allow forward referencing in this context.
User Action: Correct or remove the forward reference.

IMMGTR32, Cannot pass values larger than 32 bits by immediate mechanism [Line
n]
Warning: Using VALUE is invalid for this parameter because its size is greater
than that of a longword. A reasonable translation was attempted, however.
User Action: Verify that the output file contains a satisfactory translation of
the parameter description in your OpenSDL source file.

INCDEFSTRUC, Incompletely defined structure—structure-name [Line n]
Error: A structure name has been referenced before the structure has been
completely defined.
User Action: Remove the reference and invoke OpenSDL again.

INFILOPN, Unable to open input file file-spec
Fatal: SDL cannot locate or open the SDL source file.
User Action: Verify that you correctly specified the name of the source file.

INFILSDI, File format error reading intermediate file file-spec. Possible version
mismatch
Error: An intermediate file (.SDI) could not be read.
User Action: Check the spelling of the file name, existence and protection of
the file.

INTOVF, Integer overflow in expression [Line n]
Error: Evaluation of an SDL expression resulted in a value that does not fit in
a longword.
User Action: Correct the expression.

INVALIGN, Illegal value for /ALIGNMENT qualifier in command line
Error: The value of the /ALIGNMENT qualifier is not a positive number.
User Action: Use a positive number as value for the /ALIGNMENT qualifier.

INVBITFLD, Invalid bitfield bitfield-name—bitfields must be aggregate members
[Line n]
Error: Bit fields must be members of aggregates. They cannot be scalar items.
User Action: Incorporate the BITFIELD declaration in an aggregate.

INVDECL, Invalid DECLARE for type user-defined-name [Line n]
Error: A DECLARE statement refers to a user defined data type that is invalid.
User Action: Correct the DECLARE statement.

INVEXPR, Invalid expression—cannot be resolved to a constant as required,
name-of-defined item [Line n]
Error: A non-constant expression has been used in a context which requires a
constant expression.
User Action: Use a constant expression.

INVFLDSIZ, Item item-name has bit field or offset length greater than 32 [Line
n]
Error: SDL cannot generate bit fields larger than 32 bits or cannot generate
the proper bit mask.
User Action: Verify the BITFIELD declaration and correct it. If the BITFIELD
declaration occurs within an aggregate and you specify the MASK option, verify
that the bit offset of the start of the declaration plus the bit field size
does not exceed 32 bits.

INVLISTOPT, Invalid use of LIST attribute—LIST may only appear on the last
parameter.
entry-name [Line n]
Error: The LIST attribute appears on a parameter other than the last.
User Action: Remove the LIST attribute.

INVNAME, Item name is invalid
Error: The item name contains illegal characters or is specified in an illegal
context.
User Action: Correct or relocate the item name.

INVOUT, Invalid attributes for output language language [Line n]
Error: An SDL construct or data type is invalid for the specified target
language.
User Action: Determine whether you specified the data type or OpenSDL
declaration correctly, or whether you may be requesting language output that
you do not require.  Either correct the declaration or reissue the SDL command
so that the indicated language output routine does not execute.

INVPARMTYP, Invalid parameter type for language language [Line n]
Error: A parameter specification is illegal for the specified language.
User Action: Modify the parameter specification and invoke OpenSDL again.

INVREQPARAM, Required parameter encountered after an optional parameter
parameter-name[Line n]
Error: Required parameters must not follow optional parameters.
User Action: Correct the error and invoke OpenSDL again.

INVSHRIMG, Shareable image not found specified-language
Error: SDL cannot find the image to support the specified language.
User Action: Verify that the language image is located in the appropriate area. 
SDL searches for the image in SYS$SHARE. Language support images are of the
form SDL$language.EXE, where language is an identifying character string for
the language.  For example, the FORTRAN back end is SDL$FORTRAN.EXE, and the
MACRO back end is SDL$MACRO.EXE.

INVSYMDEF, Invalid symbol symbol-name specified in /SYMBOLS qualifier
Error: The value of the /SYMBOLS qualifier is not correct. The /SYMBOLS
qualifier expects a list of symbol definitions in the form symbol-name:value or
symbol-name=value.  The error message indicates a missing comma, colon, or
value.
User Action: Correct the syntax of the /SYMBOLS qualifier.

INVUNKLEN, Unknown length attribute valid only for parameter type [Line n]
Error: CHARACTER LENGTH * is only allowed in a parameter description.
Specifying an unknown length for an ITEM or AGGREGATE member is an error.
User Action: Remove the LENGTH specification or replace the "*" with a valid
expression.

LANGDUP, Language name language-name appears more than once in list [Line n]
Warning: In an IFLANGUAGE or END_IFLANGUAGE statement, the name of a language
appears twice.
User Action: Remove the duplicate file name.

LANGMATCH, Language language-name does not appear in list of matching IF
statement [Line n]
Warning: The list of language specified after the END_IFLANGUAGE keyword does
not match the list of languages specified after the corresponding IFLANGUAGE
keyword.
User Action: Correct the language list.

LANGMISS, Language language-name in list of matching IF statement missing from
END list [Line n]
Warning: In an END_IFLANGUAGE statement, one of the languages from the
IFLANGUAGE statement is missing.
User Action: Add the missing language to the END_IFLANGUAGE statement or remove
all languages from the END_IFLANGUAGE statement.

LISFILOPN, Unable to open listing file file-spec
Error: SDL cannot open the indicated listing file.
User Action: Verify that you have write access to the directory to which the
OpenSDL listing file is directed.

MASKTOOBIG, Cannot create correct mask value for bitfield-name [Line n]
Error: The MASK on a BITFIELD can only be used if the BITFIELD is part of a
STRUCTURE which is part of a UNION, together with an integer field large enough
to hold the mask.
User Action: Remove the MASK option, or add an integer field big enough so that
it can hold all values for the MASK.

MATCHEND, End name does not match declaration name name [Line n]
Warning: The name specified on the END_MODULE or END delimiter does not match
the most recent module name or aggregate name.
User Action: Verify that the spelling of the names specified on the END and
END_MODULE delimiters match. Check whether you have illegally nested MODULE
declarations.
This is only a warning message, but it may indicate an error.

MULTDEFSYM, Multiply defined symbol—symbol-name [Line n]
Error: A structure contains a duplicate symbol name.
User Action: Remove the duplicate name and invoke OpenSDL again.

NAMTRUNC, Generated name too long - truncated to 64 characters
name-to-be-truncated
Warning: The BLISSF backend appends various prefixes and suffixes to names. The
resulting name then can exceed 64 characters, the maximum length.
The DCL, TPU, and UIL backends limit the name of constants to 64.
User Action: Shorten your names.

NEGORIGIN, Aggregate aggregate-name has a negative origin - negative offset
elements will be ignored [Line n]
Informational: The ORIGIN attribute defines a member as origin which is not at
the beginning of the aggregate. This diagnostic will only be issued if the
/VMS_DEVELOPMENT qualifier is present.
User Action: Specify the first member of the aggregate as origin.

NOOFFSET, Base offset for mask value for bitfield-name [Line n] cannot be
determined
Error: The MASK on a BITFIELD can only be used if the BITFIELD is part of a
STRUCTURE which is part of a UNION, together with an integer field large enough
to hold the mask.
User Action: Remove the MASK option, or make the integer field big enough so
that it can hold all values for the MASK.

NOOUTPUT, No language output produced
Warning: There were too many errors, or fatal errors, which prevented SDL from
generating any output files.
User Action: Correct the errors indicated by the accompanying messages.

NULLSTRUC, Null structure structure-name has no members [Line n]
Error: An AGGREGATE or subaggregate declaration did not have any members.
User Action: Verify that the AGGREGATE or subaggregate declaration is correctly
positioned in the file.

OFFSETEXPR, Offset or origin relative expression involves a forward or circular
reference.
???-nod$t_name-??? [Line n]
Warning: The offset or origin cannot be calculated.
User Action: Correct the error and invoke OpenSDL again.

OUTFILOPN, Unable to open output file file-spec
Error: SDL cannot locate or open an SDL output file.
User Action: Verify that you correctly specified the name of the source file.

POSSCIRC, Possible circular definition for type ???-nod$t_naked-??? [Line n]
Informational: The definition for the type cannot be processed.
User Action: Correct the error and invoke OpenSDL again.

REVCHECK, Front-end / back-end version mismatch. Check installation.
Fatal: A language backend has a different version than the calling frontend.
User Action: Check your OpenSDL installation.

SIZENEST, Illegal nesting of SIZEOF clauses (Item item-name) [Line n]
Error: SIZEOF clauses cannot be nested.
User Action: Remove the nested SIZEOF clause.

SIZEQUAL, Item item-name, an aggregate, cannot be qualified by SIZEOF [Line n]
Error: The SIZEOF clause is not allowed in this context.
User Action: Remove the SIZEOF clause.

SIZEREDEF, Size or type of item item-name redefined [Line n]
Error: SDL has detected a redefinition of the size or data type of the
specified item.
User Action: Remove the clause causing the redefinition.

STRINGCONST, String constant item-name used in arithmetic expression [Line n]
Error: A reference to a string constant is not allowed in the context of an
arithmetic expression.
User Action: Remove the string constant reference.

SYMALRDEF, Symbol symbol-name was already defined in command line
Error: The value of the /SYMBOLS qualifier contains a symbol name more than
once.
User Action: Remove the duplicate name.

SYMNOTDEF, Symbol symbol-name was not defined in command line, value zero
assumed [Line n]
Warning: A symbol is used in an IFSYMBOL or ELSE_IFSYMBOL statement, that has
not been defined using the /SYMBOLS qualifier.
User Action: Define the symbol using the /SYMBOLS qualifier.

SYMTABOVR, Symbol table overflow
Fatal: SDL exceeded its symbol table space.
User Action: Reduce the size or complexity of the OpenSDL source file; if
possible, separate the file into several different files or modules.

SYNTAXERR, Syntax error [Line n]
Error: The SDL translator detected a syntax error. This message is accompanied
by a message indicating the type of error and tells you what type of token or
keyword SDL expected but did not find.
User Action: Determine the syntax error from the accompanying message and
correct it.

TOKOVF, Token exceeds maximum size of maximum-token-length [Line n]
Error: A line in the OpenSDL source file is longer than the maximum length.
User Action: Shorten the offending line.

TOOMANYFIELDS, Structure structure-name has too many fields [Line n]
Error: The structure has too many fields.
User Action: Simplify the structure.

TYPNAM, Aggregate type name not supported [Line n]
Warning: An illegal aggregate name has been used.
User Action: Choose another aggregate name.

TYPNOTSUP, Output language does not support data type data-type-name [Line n].
Warning: The specified data type is not supported by the output language. A
reasonable translation was attempted, however.
User Action: Verify that the output file contains a satisfactory translation of
the data type you specified in your OpenSDL source file.

UNALIGNED, member-name does not align on its natural boundary [Line n]
Warning: A member does not fall on its natural alignment (if /CHECK_ALIGNMENT
is present on the command line) or on the alignment specified with the
/ALIGNMENT qualifier.
User Action: Check the layout of the aggregate in question.

UNDEFCON, Undefined constant name constant-name used in expression [Line n]
Error: In the definition of a CONSTANT, an undefined name has been used.
User Action: Verify the spelling of the name.

UNDEFFIL, Unable to open include file file-name [Line n]
Error: A file to be INCLUDEd could not be opened.
User Action: Check the spelling of the file name, existence and protection of
the file.

UNDEFORG, Definition of ORIGIN name member-name not found in aggregate [Line n]
Error: The member used as argument to the ORIGIN attribute was not found within
the aggregate.
User Action: Verify the spelling of the member name.

UNDEFSYM, Undefined local symbol symbol-name used in expression [Line n]
Error: A name preceded by a pound sign (#) is not defined.
User Action: Verify that the local symbol name is spelled correctly and that it
appears before its reference in the OpenSDL source file.

UNDEFUSER, Undefined user type name type-name referenced [Line n]
Error: A DECLARE statement refers to a data type that is neither a built-in nor
a known user defined data type.
User Action: Check the spelling of the data type referenced.

WARNEXIT, Warning exit
Warning: A warning message has been issued.
User Action: Output can be compiled, but the results may be unexpected.

ZERODIV, Zero divide in expression [Line n]
Error: An expression specified in an SDL declaration resulted in a
divide-by-zero exception condition.
User Action: Verify the expression and correct it.

ZEROLEN, Item item-name has 0 or negative length [Line n]
Warning: A BITFIELD or CHARACTER declaration or a DIMENSION option specified a
length of 0 or less.
User Action: Correct the declaration. If the length or bound value was
specified using an OpenSDL expression, verify the local symbol values and the
results of arithmetic operations in the expression, if any.

@appendix B

@unnumberedsec OpenSDL Language Translation Summaries

This appendix shows the translation summaries of OpenSDL language elements to
their corresponding output in each of the following supported languages:
@itemize @bullet
@item Ada
@item BASIC
@item BLISS
@item C
@item DATATRIEVE
@item OpenVMS DCL
@item FORTRAN
@item MACRO
@item Pascal
@item PL/I
@item SDML
@item DECTPU
@item UIL
@end itemize

@unnumberedsec Ada Translation Summary

The following table shows the OpenSDL to Ada language translation summary.

@multitable @columnfractions .35 .65
@headitem OpenSDL Declaration @tab Ada Output
@item MODULE name IDENT string @tab - - module name IDENT string
@item /* comment @tab - - comment
@item CONSTANT x @tab
@item EQUALS n; @tab x : constant := n ;
@item EQUALS STRING "s"; @tab x : constant STRING := "s";
@item ENTRY name @tab procedure name
@item @tab (parameter-list ...);
@item @tab pragma INTERFACE (EXTERNAL, name);
@item @tab pragma IMPORT_VALUED_PROCEDURE
@item @tab (name,"name",)
@item @tab (type,...),
@item @tab (passing-mechanism,...);
@item PARAMETER (type,...) @tab parameter-name : type;
@item @tab .
@item @tab .
@item @tab .
@item ANY @tab UNSIGNED_LONGWORD ;
@item DESCRIPTOR @tab Generates the DESCRIPTOR passing mechanism name in the
IMPORT_VALUED_PROCEDURE pragma for the parameter.
@item RTL_STR_DESC @tab Generates the DESCRIPTOR passing mechanism name in the
IMPORT_VALUED_PROCEDURE pragma for the parameter.
@item IN @tab Causes the IN parameter mode to appear on the formal parameter.
@item OUT @tab Causes the OUT parameter mode to appear on the formal
parameter.
@item NAMED param-name @tab Parameter name. If none exists, names will be
generated of the form PARAMETER_1 ... PARAMETER_n.
@item VALUE @tab Generates the VALUE passing mechanism name in the
IMPORT_VALUED_PROCEDURE pragma for the parameter.
@item REFERENCE @tab Generates the REFERENCE passing mechanism name in the
IMPORT_VALUED_PROCEDURE pragma for the parameter.
@item DEFAULT n @tab If DEFAULT = 0, see the table at the end of this section
for the initial values of each OpenSDL data type. If the parameter
contains the VALUE attribute and the default value is other
than 0, that := value is added to the parameter.
@item LIST @tab Generates 10 formal parameters of the type of the parameter
being described. If optional is not specified, all but the first of
the corresponding parameter specifications contain a default
expression of the form type’NULL_PARAMETER. If optional
is specified, all 10 parameter specifications contain the default
expression. An appropriate entry for FIRST_OPTIONAL_
PARAMETER is generated.
@item OPTIONAL @tab Generates a parameter specification containing a default
expression of the form type’NULL_PARAMETER. If mode is OUT (or
IN OUT), an additional parameter specification is generated to
allow for use as an output parameter. An appropriate entry for
FIRST_OPTIONAL_PARAMETER is generated.
@item TYPENAME type-name @tab Specifies a non-SDL keyword data type to be used
as the parameter type.
@item RETURNS return-data-type @tab The first parameter in the parameter list
is the return parameter.  A comment of the form ’-- return value’ is placed
beside the return parameter.
@item NAMED param-name @tab Specifies the name of a parameter in the
IMPORT_VALUED_PROCEDURE argument list that receives the return value.
@item VARIABLE @tab n/a
@item ALIAS internal-name @tab The internal-name is used instead of the entry
name as the identifier associated with the entry point.
@item LINKAGE n/a
@item TYPENAME type-name Specifies a non-SDL keyword data type to be used as
the entry type.
@item STRUCTURE @tab An Ada record type is generated as well as a record
representation clause and an initialization constant for the record. If
any substructures exist, the record types for those structures are
generated first. Following this table, see the note on structures
for a discussion of structure to Ada record translation.
@item UNION @tab An Ada record type is generated depending on the union.
See the notes following this table for a discussion of union translations.
@item BYTE [SIGNED] @tab INTEGER_8
@item INTEGER_BYTE [SIGNED] @tab INTEGER_8
@item WORD [SIGNED] @tab INTEGER_16
@item INTEGER_WORD [SIGNED] @tab INTEGER_16
@item LONGWORD [SIGNED] @tab INTEGER_32
@item INTEGER_LONG [SIGNED] @tab INTEGER_32
@item INTEGER [SIGNED] @tab INTEGER_32
@item QUADWORD [SIGNED] @tab UNSIGNED_QUADWORD
@item INTEGER_QUAD [SIGNED] @tab UNSIGNED_QUADWORD
@item INTEGER_HW [SIGNED] @tab INTEGER_64 for /ALPHA
@item @tab INTEGER_32 for /VAX
@item HARDWARE_INTEGER [SIGNED] @tab INTEGER_64 for /ALPHA
@item @tab INTEGER_32 for /VAX
@item OCTAWORD @tab UNSIGNED_LONGWORD_ARRAY(0 .. 3)
@item BYTE UNSIGNED @tab UNSIGNED_BYTE
@item INTEGER_BYTE UNSIGNED @tab UNSIGNED_BYTE
@item WORD UNSIGNED @tab UNSIGNED_WORD
@item INTEGER_WORD UNSIGNED @tab UNSIGNED_WORD
@item LONGWORD @tab UNSIGNED_LONGWORD
@item INTEGER_LONG UNSIGNED @tab UNSIGNED_LONGWORD
@item INTEGER UNSIGNED @tab UNSIGNED_LONGWORD
@item QUADWORD UNSIGNED @tab UNSIGNED_QUADWORD
@item INTEGER_QUAD UNSIGNED @tab UNSIGNED_QUADWORD
@item INTEGER_HW UNSIGNED @tab UNSIGNED_QUADWORD for /ALPHA
@item @tab UNSIGNED_LONGWORD for /VAX
@item HARDWARE_INTEGER UNSIGNED @tab UNSIGNED_QUADWORD for /ALPHA
@item @tab UNSIGNED_LONGWORD for /VAX
@item OCTAWORD UNSIGNED @tab UNSIGNED_LONGWORD_ARRAY(0 .. 3)
@item T_FLOATING @tab T_FLOAT
@item S_FLOATING @tab S_FLOAT
@item T_FLOATING COMPLEX @tab T_FLOATING_COMPLEX
@item S_FLOATING COMPLEX @tab S_FLOATING_COMPLEX
@item DECIMAL PRECISION (p,q) @tab This data type has not yet been implemented.
A comment appears in the output, and a message is printed to this effect.
@item BITFIELD @tab BOOLEAN (one bit)
@item LENGTH n @tab UNSIGNED_n if n > 1; BOOLEAN if n = 1 for /ALPHA
@item @tab BIT_ARRAY (0..n-1) for /VAX
@item MASK @tab prefix_M_name : constant : = 16#mask-value#;
@item SIGNED @tab n/a
@item CHARACTER @tab CHARACTER
@item LENGTH n @tab STRING(1 .. n) if n > 1
@item LENGTH * @tab STRING
@item VARYING @tab UNSIGNED_WORD field for the string length is generated if
VARYING is specified; n/a in parameter context
@item ADDRESS @tab ADDRESS
@item POINTER @tab ADDRESS
@item POINTER_LONG @tab ADDRESS
@item POINTER_HW @tab UNSIGNED_QUADWORD for /ALPHA
@item @tab ADDRESS for /VAX
@item HARDWARE_ADDRESS @tab UNSIGNED_QUADWORD for /ALPHA
@item @tab ADDRESS for /VAX
@item POINTER_QUAD @tab UNSIGNED_QUADWORD
@item BOOLEAN @tab BOOLEAN
@item user-type-name @tab user-type-name_TYPE
@item Default storage class @tab n/a
@item COMMON storage class @tab n/a
@item GLOBAL storage class @tab n/a
@item BASED pointer-name @tab n/a
@item TYPEDEF @tab For an ITEM, a subtype definition is generated. For an
AGGREGATE, the behavior is as though TYPEDEF had not been specified.
@item DIMENSION [lbound]:hbound @tab If other than a BITFIELD data type, append
’_ARRAY (lbound..hbound)’ to the type.@*
For BITFIELDS, a BIT_ARRAY is generated of the form
BIT_ARRAY(0..hbound*length-1). If lbound is not supplied, it defaults to 1.
@item ORIGIN member-name @tab n/a
@end multitable

@quotation Notes
@enumerate
@item @strong{Ada Names}@*
Dollar signs ($) are illegal in Ada names and are replaced with underscores
(_).

@item @strong{Union Criteria}@*
If the union has the following form, it is treated as a record type:
@example
A ... union;
ITEM_1 ...;                             /* First member is not a union or
                                           a structure, and the size of the
                                           first member is the same as the
                                           size of the union.
ITEM_2 structure ...;                   /* Second member is a structure,
                                           and the size of the first member
                                           is the same as the size of the
                                           union. (Needed so size based
                                           on structure components is
                                           correct.)
        I_2_A ...;
        I_2_B ...;
        ...
        end ITEM_2;
        ITEM_3 ...;
        ...
        end A;
@end example

If the union does not have the form shown in the previous example, the union is
ignored and only the first member is used.

@example
Example 1 - Criteria are satisfied:
---------

aggregate X prefix XXX$;
    X_1 longword unsigned;
    X_2_OVERLAY union;
        X_2 longword unsigned;
        X_2_FIELDS structure;
            X_2_B_1 byte unsigned;
            X_2_B_2 byte unsigned;
        end X_2_FIELDS;
        X_2_C word unsigned;
        X_2_D structure;
            X_2_D_1 bitfield(3);
            X_2_D_2 bitfield;
        end X_2_D;
    end X_2_OVERLAY;
end X;
@end example

The union X_2_OVERLAY satisfies the criteria in the previous example and would
be treated as a record declaration. Source code similar to the following would
be generated:

@example
type XXX_X_2_TYPE is record
    X_2_B_1 : BYTE;
    X_2_B_2 : BYTE;
end record;
type XXX_X_2_D_TYPE is record
    X_2_D_1 : FLAGS(1 .. 3);
    X_2_D_2 : BOOLEAN;
end record;
type XXX_TYPE is record
    X_1 : LONGWORD;
    X_2 : XXX_X_2_TYPE;
----X_2_C overlaps X_2
----
----X_2_C : UNSIGNED_16;
----X_2_D overlaps X_2
----
----X_2_D : XXX_X_2_D_TYPE;
end record;

Example 2 - Criteria are not satisfied
---------

aggregate Y prefix YYY$;
    Y_1 longword unsigned;
    Y_2_OVERLAY union;
        Y_2_A byte unsigned;
        Y_2_B byte unsigned;
    end Y_2_OVERLAY;
end Y;
@end example

In the previous example, the second member is not a structure, and the
following source code would be generated:

@example
type YYY_TYPE is record
    Y_1 : LONGWORD;
    Y_2_A : BYTE;
----Y_2_B overlaps Y_2_A
----
----Y_2_B : BYTE;
    end record;
@end example

@item IN and OUT Parameter Modes@*
If the mode is not explicitly given for a parameter, the default mode (IN)
appears.

@item OPTIONAL Parameters@*

An entry for FIRST_OPTIONAL_PARAMETER is generated, naming the first trailing
optional parameter, if one exists. The appropriate signatures are generated for
OPTIONAL OUT (or IN OUT) parameters to allow for any valid combination of
actual parameters to be specified.

@item DEFAULT Values
DEFAULT generates a default expression in the parameter specification.
The following is a list of OpenSDL data types and the default Ada values for
the INITIALIZATION constant.

@multitable @columnfractions .3 .7
@headitem OpenSDL Data Type @tab Ada INITIALIZATION
@item BYTE [SIGNED] @tab 0
@item INTEGER_BYTE [SIGNED] @tab INTEGER_8_ZERO
@item WORD [SIGNED] @tab 0
@item INTEGER_WORD [SIGNED] @tab INTEGER_16_ZERO
@item LONGWORD [SIGNED] @tab 0
@item INTEGER_LONG [SIGNED] @tab INTEGER_32_ZERO
@item INTEGER [SIGNED] @tab INTEGER_32_ZERO
@item INTEGER_HW [SIGNED] @tab INTEGER_64_ZERO for /ALPHA
@item @tab INTEGER_32_ZERO for /VAX
@item HARDWARE_INTEGER [SIGNED] INTEGER_64_ZERO for /ALPHA
@item @tab INTEGER_32_ZERO for /VAX
@item QUADWORD [SIGNED] @tab (0, 0)
@item INTEGER_QUAD [SIGNED] @tab UNSIGNED_QUADWORD_ZERO
@item OCTAWORD [SIGNED] @tab (0, 0, 0, 0)
@item BYTE UNSIGNED @tab 0
@item INTEGER_BYTE UNSIGNED @tab UNSIGNED_BYTE_ZERO
@item WORD UNSIGNED @tab 0
@item INTEGER_WORD UNSIGNED @tab UNSIGNED_WORD_ZERO
@item LONGWORD UNSIGNED @tab 0
@item INTEGER_LONG UNSIGNED @tab UNSIGNED_LONGWORD_ZERO
@item INTEGER UNSIGNED @tab UNSIGNED_LONGWORD_ZERO
@item INTEGER_HW UNSIGNED @tab UNSIGNED_QUADWORD_ZERO for /ALPHA
@item @tab UNSIGNED_LONGWORD_ZERO for /VAX
@item HARDWARE_INTEGER UNSIGNED @tab UNSIGNED_ZERO for /ALPHA
@item @tab UNSIGNED_LONGWORD_ZERO for /VAX
@item QUADWORD UNSIGNED @tab (0, 0)
@item INTEGER_QUAD UNSIGNED @tab UNSIGNED_QUADWORD_ZERO
@item OCTAWORD [SIGNED] @tab (0, 0, 0, 0)
@item CHARACTER @tab ASCII.NUL
@item DECIMAL PRECISION (p,s) @tab NYI_PACKED_DECIMAL_ZERO
@item T_FLOATING @tab 0.0
@item T_FLOATING_COMPLEX @tab T_FLOATING_COMPLEX_ZERO
@item S_FLOATING @tab 0.0
@item S_FLOATING_COMPLEX @tab S_FLOATING_COMPLEX_ZERO
@item ADDRESS @tab ADDRESS_ZERO
@item POINTER @tab ADDRESS_ZERO
@item POINTER_LONG @tab ADDRESS_ZERO
@item POINTER_HW @tab UNSIGNED_QUADWORD_ZERO for /ALPHA
@item @tab ADDRESS_ZERO for /VAX
@item HARDWARE_ADDRESS @tab UNSIGNED_QUADWORD_ZERO for /ALPHA
@item @tab ADDRESS_ZERO for /VAX
@item POINTER_QUAD @tab (0, 0)
@end multitable

@item Structure of Ada Record Translation@*

For each OpenSDL structure, the corresponding Ada translation consists of three
parts: 1) a record type definition, 2) a record representation clause, and 3)
an initialization constant for the record. The three parts have the following
form:

@example
type structure-name is
    record
        member-name : type; ...
    end record;
    for structure-name use
        record
            member-name at offset range 0 .. size;
            ...
        end record
    for structure-name’size use total-size;
structure-name_INIT : constant structure-name :=
    (member-name => initial_value,
     ...)
@end example
@end enumerate
@end quotation

Size is the size of the field in bits, and total_size is the size of the entire
record in bits.

BASIC Translation Summary

The following table shows the OpenSDL to BASIC language translation summary.

OpenSDL Declaration BASIC Output
MODULE name IDENT string !*** MODULE name IDENT string ***
/* comment ! comment
CONSTANT x
EQUALS n; DECLARE LONG CONSTANT x = n
EQUALS STRING "s"; DECLARE STRING CONSTANT x = "s"
ENTRY name EXTERNAL SUB name
PARAMETER (type,...) ( &
type, &
.
.
)
ANY ANY
DESCRIPTOR BY DESC
RTL_STR_DESC BY DESC
IN n/a
OUT n/a
NAMED param-name n/a
VALUE BY VALUE
REFERENCE BY REF
DEFAULT n n/a
LIST Yields one explicit parameter description plus m-n commas,
where m is the maximum number of parameters allowable in
BASIC, and n is the number of parameters already specified
(including the LIST parameter description).
OPTIONAL OPTIONAL data-type
TYPENAME type-name n/a
RETURNS return-data-type EXTERNAL data-type FUNCTION name
NAMED param-name n/a
VARIABLE n/a
ALIAS n/a
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE DECLARE LONG CONSTANT markerS_structure-name = size
RECORD struct-name
type member-name
.
.
.
END RECORD struct-name
UNION DECLARE LONG CONSTANT markerS_union-name = size
RECORD union-name
VARIANT
CASE
type member-name
.
.
.
END VARIANT
END RECORD union-name
BYTE [SIGNED] BYTE
INTEGER_BYTE [SIGNED] BYTE
WORD [SIGNED] WORD
INTEGER_WORD [SIGNED] WORD
LONGWORD [SIGNED] LONG
INTEGER_LONG [SIGNED] LONG
INTEGER [SIGNED] LONG
INTEGER_HW [SIGNED] BASIC$QUADWORD for /ALPHA
LONG for /VAX
HARDWARE_INTEGER [SIGNED] BASIC$QUADWORD for /ALPHA
LONG for /VAX
QUADWORD [SIGNED] BASIC$QUADWORD
INTEGER_QUAD [SIGNED] BASIC$QUADWORD
OCTAWORD BASIC$OCTAWORD
BYTE UNSIGNED BYTE
INTEGER_BYTE UNSIGNED BYTE
WORD UNSIGNED WORD
INTEGER_WORD UNSIGNED WORD
LONGWORD UNSIGNED LONG
INTEGER_LONG UNSIGNED LONG
INTEGER UNSIGNED LONG
QUADWORD UNSIGNED BASIC$QUADWORD
INTEGER_QUAD UNSIGNED BASIC$QUADWORD
INTEGER_HW UNSIGNED BASIC$QUADWORD for /ALPHA
LONG for /VAX
HARDWARE_INTEGER UNSIGNED BASIC$QUADWORD for /ALPHA
LONG for /VAX
OCTAWORD UNSIGNED BASIC$OCTAWORD
F_FLOATING SINGLE
D_FLOATING DOUBLE
G_FLOATING GFLOAT
H_FLOATING BASIC$HFLOAT_AXP for /ALPHA
HFLOAT for /VAX
F_FLOATING COMPLEX BASIC$F_FLOATING_COMPLEX
D_FLOATING COMPLEX BASIC$D_FLOATING_COMPLEX
G_FLOATING COMPLEX BASIC$G_FLOATING_COMPLEX
H_FLOATING COMPLEX BASIC$H_FLOATING_COMPLEX_AXP for /ALPHA
BASIC$H_FLOATING_COMPLEX for /VAX
DECIMAL PRECISION (p,q) DECIMAL (p,q)
BITFIELD type name_bits ! COMMENT ADDED
BY SDL name_bits contains bits name1 through name2
LENGTH n n is used in computing size (type) of name_bits field.
MASK DECLARE LONG CONSTANT prefix$m_name = x’mask-value’
SIGNED n/a
CHARACTER STRING name = 1
LENGTH n STRING name = n
LENGTH * STRING
VARYING group name
WORD str-len
STRING str-text = n, where n is the maximum length of the
string
end group name
ADDRESS LONG name
POINTER LONG name
POINTER_LONG LONG name
POINTER_HW BASIC$QUADWORD name for /ALPHA
LONG name for /VAX
HARDWARE_ADDRESS BASIC$QUADWORD name for /ALPHA
LONG name for /VAX
POINTER_QUAD BASIC$QUADWORD name
BOOLEAN BYTE name
user-type-name user_type_name
COMMON storage class COMMON name name
GLOBAL storage class EXTERNAL name name
BASED pointer-name n/a
TYPEDEF For an ITEM, a record definition is generated. For an
AGGREGATE, the behavior is as though TYPEDEF had not
been specified.
DIMENSION [lbound:]hbound type name (lbound to hbound); if lbound was not
specified in SDL, lbound is 1 in the BASIC output
ORIGIN member-name n/a

BLISS Translation Summary

The following table shows the OpenSDL to BLISS language translation summary.

OpenSDL Declaration BLISS Output
MODULE name IDENT string !*** MODULE name IDENT string ***
/* comment ! comment
CONSTANT x
EQUALS n; LITERAL x = n;
EQUALS STRING "s"; macro x = ’s’%;
ENTRY name EXTERNAL ROUTINE name
EXTERNAL ROUTINE name: NOVALUE ;
PARAMETER (type,...) n/a
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name n/a
VALUE n/a
REFERENCE n/a
DEFAULT n Used in KEYWORDMACRO when the /VMS_DEVELOPMENT
qualifier is specified
LIST Generates invocation of special predefined macro to handle LIST
parameters
OPTIONAL Generates invocation of special predefined macro to handle
OPTIONAL parameters when the /VMS_DEVELOPMENT
qualifier is specified
TYPENAME type-name n/a
RETURNS return-data-type n/a
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name When the /VMS_DEVELOPMENT qualifier is specified,
internal-name becomes the name of the BLISS KEYWORDMACRO
generated for the ENTRY declaration.
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE and UNION Each aggregate or member declaration in OpenSDL produces a
BLISS macro declaration of the form:
MACRO name = off,pos,size,ext %;
The BLISSF back end translates each aggregate and associated
member declaration in OpenSDL to a BLISS field declaration.
The field-set-name is of the form prefix$name_FIELDSET,
where prefix is declared for the entire aggregate and name is
the aggregate name.
FIELD prefix$name_FIELDSET=
SET
member-name = [off,pos,size,ext];
.
.
.
TES;
literal prefix$s_name = size;
MACRO prefix$r_name = BLOCK
[pref$_name,BYTE]
FIELD
(prefix$name_FIELDSET)%;
off
Byte offset of this aggregate or item within the current aggregate
pos
Bit position from the offset
size
Size of the aggregate of item, in bits, if the size is 4 bytes or
less. Otherwise, this field contains 0, and OpenSDL generates
the size declaration.
ext
Contains 0 if the value is zero extended, or 1 if the value is sign
extended or SIGNED bit.
The following OpenSDL data types generate field specifications of
the form "off,pos,size,ext" in various contexts. Where necessary,
constants indicating the size of the data type (field) are also
generated.
BYTE [SIGNED] off,pos,8,1
INTEGER_BYTE [SIGNED] off,pos,8,1
WORD [SIGNED] off,pos,16,1
INTEGER_WORD [SIGNED] off,pos,16,1
LONGWORD [SIGNED] off,pos,32,1
INTEGER_LONG [SIGNED] off,pos,32,1
INTEGER [SIGNED] off,pos,32,1
INTEGER_HW [SIGNED] off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,32,1 for /VAX
HARDWARE_INTEGER [SIGNED] off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,32,1 for /VAX
QUADWORD [SIGNED] off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,0,1 for /VAX
INTEGER_QUAD [SIGNED] off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,0,1 for /VAX
OCTAWORD [SIGNED] off,pos,0,1
BYTE UNSIGNED off,pos,8,0
INTEGER_BYTE UNSIGNED off,pos,8,0
WORD UNSIGNED off,pos,16,0
INTEGER_WORD UNSIGNED off,pos,16,0
LONGWORD UNSIGNED off,pos,32,0
INTEGER_LONG UNSIGNED off,pos,32,0
INTEGER UNSIGNED off,pos,32,0
INTEGER_HW UNSIGNED off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,32,0 for /VAX
HARDWARE_INTEGER UNSIGNED off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,32,0 for /VAX
QUADWORD [SIGNED] off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,0,0 for /VAX
INTEGER_QUAD [SIGNED] off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,0,0 for /VAX
OCTAWORD UNSIGNED off,pos,0,0
F_FLOATING off,pos,32,0
D_FLOATING off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,0,0 for /VAX
literal prefix$s_name = 8;
G_FLOATING off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,0,0 for /VAX
literal prefix$s_name = 8;
H_FLOATING off,pos,0,0
literal prefix$s_name = 16;
If you specify /LANGUAGES=BLISSF, a special set of macros
and FIELDSETs, which define the particular COMPLEX data
type and its real and imaginary components, are generated.
F_FLOATING COMPLEX off,pos,0,0 for /ALPHA
COMPLEX off,pos,64,0 for /ALPHA/B64
COMPLEX off,pos,0,0 for /VAX
literal prefix$s_name = 8;
D_FLOATING COMPLEX off,pos,0,0
literal prefix$s_name = 16;
G_FLOATING COMPLEX off,pos,0,0
literal prefix$s_name = 16;
H_FLOATING COMPLEX off,pos,0,0
literal prefix$s_name = 32;
DECIMAL PRECISION (p,q) n/a
BITFIELD off,pos,size,0
literal prefix$_name = size;
LENGTH n off,pos,n,0
literal prefix$_name = n;
MASK literal prefix$m_name = mask-value; where mask-value is the
decimal equivalent of the binary mask
SIGNED off,pos,size,1
CHARACTER off,pos,size,0
LENGTH n literal prefix$_name = n;
LENGTH * n/a
VARYING off,pos,size,0; where size = (length + 2) * 8. If (length + 2) > 4,
then size = 0.
literal prefix$s_name = <length + 2>;
ADDRESS off,pos,32,0
POINTER off,pos,32,1
POINTER_LONG off,pos,32,1
POINTER_HW off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,32,1 for /VAX
HARDWARE_ADDRESS off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,32,1 for /VAX
POINTER_QUAD off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,0,1 for /VAX
BOOLEAN off,pos,8,0
user-type-name off,pos,size,0; where size is dependent upon the type indicated
by user-type-name
Default storage class n/a
COMMON storage class EXTERNAL
with /GLOBALDEF GLOBAL
GLOBAL storage class EXTERNAL
with /GLOBALDEF GLOBAL
BASED pointer-name n/a
TYPEDEF n/a
DIMENSION [lbound:]hbound lbound and hbound are only used to determine the total size of
the item, which is reflected in: literal prefix$s_name = size;
ORIGIN member-name n/a

Notes
1. The BLISS output routine does not assign data to storage classes.
2. For all literals above, size is given in bytes.

C/C++ Translation Summary

The C backend differentiates along the qualifiers /ALPHA vs. /VAX,
/[NO]VMS_DEVELOPMENT, and /[NO]C_DEVELOPMENT.
/VMS_DEVELOPMENT and /C_DEVELOPMENT can be combined.
When /C_DEVELOPMENT is present, every definition is translated twice, once
between

#ifdef __NEW_STARLET
/* translation */
#else /* __OLD_STARLET */
and once between
#else /* __OLD_STARLET */
/* possibly different translation */
#endif /* #ifdef __NEW_STARLET */

So, there are 12 possibly different translations for a single data type. To make
the translation summary more readable, abbreviations are used.

Abbreviation Qualifier combination
a /ALPHA
b /ALPHA/VMS_DEVELOPMENT
c /ALPHA/VMS_DEVELOPMENT/C_DEVELOPMENT, #ifdef _ _NEW_STARLET
d /ALPHA/VMS_DEVELOPMENT/C_DEVELOPMENT, #else
e /ALPHA/C_DEVELOPMENT, #ifdef _ _NEW_STARLET
f /ALPHA/C_DEVELOPMENT, #else
g /VAX
h /VAX/VMS_DEVELOPMENT
i /VAX/VMS_DEVELOPMENT/C_DEVELOPMENT, #ifdef _ _NEW_STARLET
j /VAX/VMS_DEVELOPMENT/C_DEVELOPMENT, #else
k /VAX/C_DEVELOPMENT, #ifdef _ _NEW_STARLET
l /VAX/C_DEVELOPMENT, #else

The following table shows the OpenSDL to C/C++ language translation summary.

OpenSDL Declaration C/C++ Output
MODULE name IDENT string /*** MODULE name IDENT string ***/
/* comment /* comment */
CONSTANT x
EQUALS n; #define x n
EQUALS STRING "s"; #define x "s"
ENTRY name return-type name( )
PARAMETER (type,...) n/a
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name n/a
VALUE n/a
REFERENCE n/a
DEFAULT n n/a
LIST n/a
OPTIONAL n/a
TYPENAME type-name n/a
RETURNS return-type return-type name( )
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name n/a
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE struct
UNION union
name BYTE [SIGNED] char name
name INTEGER_BYTE [SIGNED] char name
name WORD [SIGNED] short int name
name INTEGER_WORD [SIGNED] short int name
name LONGWORD [SIGNED] int name
name INTEGER_LONG [SIGNED] int name
name INTEGER [SIGNED] int name
name INTEGER_HW [SIGNED] _ _int64 name for a-f
int name for g-l
name HARDWARE_INTEGER
[SIGNED]
_ _int64 name for a-f
int name for g-l
name QUADWORD [SIGNED] int name [2] for a, d, f, g, h, j, l
_ _int64 name for b, c, e, i, k
name INTEGER_QUAD [SIGNED] _ _int64 name for a-f
int name[2] for g-l
name OCTAWORD [SIGNED] int name [4]
name BYTE UNSIGNED unsigned char
name INTEGER_BYTE UNSIGNED unsigned char
name WORD UNSIGNED unsigned short int
name INTEGER_WORD UNSIGNED unsigned short int
name INTEGER_LONGWORD
UNSIGNED
unsigned int
name INTEGER_LONG UNSIGNED unsigned int
name INTEGER UNSIGNED unsigned int
name INTEGER_HW UNSIGNED unsigned _ _int64 name for a-f
unsigned int name for g-l
name HARDWARE_INTEGER
UNSIGNED
unsigned _ _int64 name for a-f
unsigned int name for g-l
name QUADWORD UNSIGNED unsigned int name [2] for a, d, f, g, h, j, l
unsigned _ _int64 name for b, c, e, i, k
name INTEGER_QUAD UNSIGNED unsigned _ _int64 name for a-f
unsigned int name[2] for g-l
name OCTAWORD UNSIGNED unsigned int name [4]
name F_FLOATING float name
name D_FLOATING double float name
name G_FLOATING double float name
name H_FLOATING int name [4]
name F_FLOATING COMPLEX float name [2]
name D_FLOATING COMPLEX double float name [2]
name G_FLOATING COMPLEX double float name [2]
name H_FLOATING COMPLEX int name [8]
name DECIMAL PRECISION (p,q) char name [p/2+1]
name BITFIELD unsigned name:1
LENGTH n unsigned name:n
MASK n/a
SIGNED n/a
name CHARACTER char name
LENGTH n char name [n]
LENGTH * n/a
VARYING struct @{short string_length; char string_text[n];@} name; where n
is the maximum length of the character string
name ADDRESS (object-type) object-type *name for a-c, e, g-i, k
void * for d, f, j, l
name POINTER (object-type) object-type *name for a-c, e, g-i, k
unsigned int for d, f, j, l
name POINTER_LONG (object-type)
int for a-l
void * for b, c, e, h, i, k
name POINTER_HW (object-type) object-type *name for a, g-i, k
(1) for b-c, e
unsigned _ _int64 name for d, f
unsigned int for j, l
name HARDWARE_ADDRESS
(object-type)
object-type *name for a-l
name POINTER_QUAD (object-type)
object-type *name for a, g
(1) for b-c, e, h, i, k
unsigned _ _int64 name for d, f
unsigned int name [2] for j, l
name BOOLEAN char name
name user-type-name user-type-name name
Default storage class struct or union with <member-name> as the tag, and no
declared variable names
COMMON storage class extern attribute
GLOBAL storage class globalref attribute
with /GLOBALDEF globaldef attribute
BASED pointer-name A pointer will be generated for the based item
TYPEDEF For an AGGREGATE, a TYPEDEF STRUCT is generated.
In this case, a pre-tag is generated as well as the post-tag.
The pre-tag consists of the structure named prefixed by an
underscore. Any reference to the structure type within the
definition (such as for forward and backward linkages) is also
output with the underscore. For an ITEM, the TYPEDEF
keyword is generated, followed by the data type of the ITEM.
1 #ifdef __INITIAL_POINTER_SIZE #pragma __required_pointer_size __long
object-type *name; #else unsigned
__int64 name; #endif
DIMENSION [lbound:]hbound The declaration specifies an array of the number of
elements specified with subscripts ranging from 0 to (hbound - lbound + 1)
ORIGIN member-name n/a

DATATRIEVE Translation Summary

The following table shows the OpenSDL to DATATRIEVE language translation
summary.

OpenSDL Declaration DATATRIEVE Output
MODULE name IDENT string ! *** MODULE name IDENT string ***
/* comment ! comment
CONSTANT x EQUALS n; ! x=n
ENTRY ! name ENTRY
PARAMETER (type,...) n/a
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name n/a
VALUE n/a
REFERENCE n/a
DEFAULT n n/a
LIST n/a
OPTIONAL n/a
TYPENAME type-name n/a
RETURNS return-data-type n/a
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name n/a
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE A group field declaration. An AGGREGATE declaration is
always assigned a level number of 1; subsequent subaggregates
are assigned level numbers 2, 3, and so on.
UNION A group field declaration, with level numbers assigned as above.
All but the first union member have a REDEFINES first-fieldname
clause. The redefined fields cannot be larger than the first
union member.
BYTE [SIGNED] USAGE IS BYTE
INTEGER_BYTE [SIGNED] USAGE IS BYTE
WORD [SIGNED] USAGE IS WORD
INTEGER_WORD [SIGNED] USAGE IS WORD
LONGWORD [SIGNED] USAGE IS LONG
INTEGER_LONG [SIGNED] USAGE IS LONG
INTEGER [SIGNED] USAGE IS LONG
INTEGER_HW [SIGNED] USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
HARDWARE_INTEGER [SIGNED] USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
QUADWORD [SIGNED] USAGE IS QUAD
INTEGER_QUAD [SIGNED] USAGE IS QUAD
OCTAWORD [SIGNED] USAGE IS QUAD OCCURS 2 TIMES
BYTE UNSIGNED USAGE IS BYTE
INTEGER_BYTE UNSIGNED USAGE IS BYTE
WORD UNSIGNED USAGE IS WORD
INTEGER_WORD UNSIGNED USAGE IS WORD
LONGWORD UNSIGNED USAGE IS LONG
INTEGER_LONG UNSIGNED USAGE IS LONG
INTEGER UNSIGNED USAGE IS LONG
INTEGER_HW UNSIGNED USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
HARDWARE_INTEGER UNSIGNED USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
QUADWORD UNSIGNED USAGE IS QUAD
INTEGER_QUAD UNSIGNED USAGE IS QUAD
OCTAWORD UNSIGNED USAGE IS QUAD OCCURS 2 TIMES
F_FLOATING USAGE IS REAL
D_FLOATING USAGE IS DOUBLE
G_FLOATING USAGE IS DOUBLE
H_FLOATING USAGE IS QUAD OCCURS 2 TIMES
F_FLOATING COMPLEX USAGE IS REAL OCCURS 2 TIMES
D_FLOATING COMPLEX USAGE IS DOUBLE OCCURS 2 TIMES
G_FLOATING COMPLEX USAGE IS DOUBLE OCCURS 2 TIMES
H_FLOATING COMPLEX USAGE IS QUAD OCCURS 2 TIMES
DECIMAL PRECISION (p,q) USAGE IS PACKED PIC 9(p-q)V9(q)
BITFIELD ! name BIT position:size
See the description following the table
LENGTH n ! name BIT position:n
MASK ! maskname = value
SIGNED n/a
CHARACTER PIC X(n)
LENGTH n X(n)
LENGTH * n/a
VARYING A group field of the form:
level field-name
level+1 STRING_LENGTH USAGE IS WORD
level+1 STRING_TEXT PIC X(n)
ADDRESS USAGE IS LONG
POINTER USAGE IS LONG
POINTER_LONG USAGE IS LONG
POINTER_HW USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
HARDWARE_ADDRESS USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
POINTER_QUAD USAGE IS QUAD
BOOLEAN USAGE IS BYTE
Default storage class n/a
COMMON storage class n/a
GLOBAL storage class n/a
with /GLOBALDEF n/a
BASED pointer-name n/a
pointer-name USAGE IS LONG
name DIMENSION [lbound:]hbound OCCURS hbound-lbound+1 TIMES
ORIGIN member-name n/a

Notes
1. Bitfields must be an integral number of bytes, union members, or be fully
contained in a structure composed only of bit members. If they are in a
structure, bit names themselves are commented out, but the appropriate amount
of storage is allocated at the structure name level. USAGE IS BYTE, WORD, LONG,
or QUAD is used when possible to allocate the storage; otherwise, USAGE IS BYTE
OCCURS n TIMES is used.
2. All items and aggregates are output as record definitions as follows:

1 aggregate-name.
2 member-name datatype.
.
.
.
;

The record name is composed of the top-level aggregate or item name and the
string ‘‘_RECORD’’.
3. A dollar sign ($) appearing in a name is replaced by a hyphen (-).

FORTRAN Translation Summary

The following table shows the OpenSDL to FORTRAN language translation summary.

OpenSDL Declaration FORTRAN Output
MODULE name IDENT string !*** MODULE name IDENT string ***
/* comment ! comment
CONSTANT x
EQUALS n; PARAMETER x = n
EQUALS STRING "s"; CHARACTER*(*) x
PARAMETER (x = ’s’)
ENTRY name EXTERNAL name
PARAMETER (type,...) n/a
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name n/a
VALUE n/a
REFERENCE n/a
DEFAULT n n/a
LIST n/a
OPTIONAL n/a
TYPENAME type-name n/a
RETURNS return-data-type data-type function-name
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name n/a
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE If this is a top-level AGGREGATE declaration, a FORTRAN
STRUCTURE declaration is generated. If this is a subaggregate
declaration, no structure is generated.
UNION UNION and associated MAP declarations
name BYTE [SIGNED] BYTE name
name INTEGER_BYTE [SIGNED] INTEGER*1 name
name WORD [SIGNED] INTEGER*2 name
name INTEGER_WORD [SIGNED] INTEGER*2 name
name LONGWORD [SIGNED] INTEGER*4 name
name INTEGER_LONG [SIGNED] INTEGER*4 name
name INTEGER [SIGNED] INTEGER*4 name
name INTEGER_HW [SIGNED] INTEGER*8 for /ALPHA
INTEGER*4 name for /VAX
name HARDWARE_INTEGER
[SIGNED]
INTEGER*8 for /ALPHA
INTEGER*4 name for /VAX
name QUADWORD [SIGNED] INTEGER*4 name(2)
name INTEGER_QUAD [SIGNED] INTEGER*8 for /ALPHA
INTEGER*4 name(2) for /VAX
name OCTAWORD [SIGNED] INTEGER*4 name(4)
name BYTE UNSIGNED BYTE name
name INTEGER_BYTE UNSIGNED BYTE name
name WORD UNSIGNED INTEGER*2 name
name INTEGER_WORD UNSIGNED INTEGER*2 name
name LONGWORD UNSIGNED INTEGER*4 name
name INTEGER_LONG UNSIGNED INTEGER*4 name
name INTEGER UNSIGNED INTEGER*4 name
name INTEGER_HW UNSIGNED INTEGER*8 for /ALPHA
INTEGER*4 name for /VAX
name HARDWARE_INTEGER
UNSIGNED
INTEGER*8 for /ALPHA
INTEGER*4 name for /VAX
name QUADWORD UNSIGNED INTEGER*4 name(2)
name INTEGER_QUAD UNSIGNED INTEGER*8 for /ALPHA
INTEGER*4 name(2) for /VAX
name OCTAWORD UNSIGNED INTEGER*4 name(4)
name F_FLOATING REAL*4 name
name D_FLOATING REAL*8 name
name G_FLOATING REAL*8 name
name H_FLOATING REAL*16 name
name F_FLOATING COMPLEX COMPLEX name
name D_FLOATING COMPLEX COMPLEX*16 name
name G_FLOATING COMPLEX COMPLEX*16 name
name H_FLOATING COMPLEX BYTE %FILL (32)
DECIMAL PRECISION (p,q) Undefined data type; error INVOUT
BITFIELD Offset and size declarations with "V_" and "S_" tags
LENGTH n n specifies the size for size declaration
MASK Mask declaration, with "M" tag
SIGNED n/a
name CHARACTER CHARACTER*n name
LENGTH n CHARACTER*n name
LENGTH * n/a
VARYING STRUCTURE/name/name
INTEGER*2 LEN
CHARACTER*length TXT
END STRUCTURE
name ADDRESS INTEGER*4 name
name POINTER INTEGER*4 name
name POINTER_LONG INTEGER*4 name
name POINTER_HW INTEGER*8 name for /ALPHA
INTEGER*4 name for /VAX
name HARDWARE_ADDRESS INTEGER*8 name for /ALPHA
INTEGER*4 name for /VAX
name POINTER_QUAD INTEGER*8 name for /ALPHA
INTEGER*4 name(2) for /VAX
name BOOLEAN BYTE name
name user-type-name data-type name ! type is "user-type-name"
Default storage class Local, static
COMMON storage class RECORD /name/ name
COMMON /name/ name
GLOBAL storage class n/a
with /GLOBALDEF n/a
BASED pointer-name n/a
TYPEDEF For an ITEM, a comment is generated. For an AGGREGATE,
the behavior is as though TYPEDEF had not been specified.
DIMENSION [lbound:]hbound name(hbound - lbound)
ORIGIN member-name n/a

Note
Because FORTRAN does not have a comparable data type for BITFIELD, the 
FORTRAN back end translates bitfields to PARAMETERS with the same value as
that of the associated structure offset. BYTE fillers (using the FORTRAN %FILL
feature) are placed in the structures for alignment.

MACRO Translation Summary

The following table shows the OpenSDL to MACRO language translation summary.

OpenSDL Declaration MACRO Output
MODULE name IDENT string .MACRO name ;IDENT string
/* comment ;comment
CONSTANT x
EQUALS n; If /NOVMS_DEVELOMENT (default), generates: x’..equ’n
If /VMS_DEVELOPMENT is specified, generates: $EQU x n
EQUALS STRING "s"; See Note 2.
ENTRY If /NOVMS_DEVELOPMENT (default), generates: ;EXTERNAL
entry entry-name
If /VMS_DEVELOPMENT, generates a special set of macros
that facilitate calling of the routine using either the CALLG or
CALLS instruction.
PARAMETER (type,...) If /VMS_DEVELOPMENT, generates the formal argument list
for keyword macros associated with the ENTRY declaration
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name If /VMS_DEVELOPMENT, param-name becomes a formal
argument name used in the argument list for keyword macros
associated with the ENTRY declaration
VALUE n/a
REFERENCE n/a
DEFAULT n If /VMS_DEVELOPMENT, n becomes a default value in the
macro argument list for the parameter being described
LIST Fills the macro argument list with up to 20 parameters of the
type of the parameter being described
OPTIONAL Generates an "OPTIONAL" macro argument, which either
defaults to 0 or is truncated from the actual argument list when
the macro is expanded
TYPENAME type-name n/a
RETURNS return-data-type n/a
NAMED param-name n/a
VARIABLE If /VMS_DEVELOPMENT, causes a special form of macro to be
generated that handles a variable number of parameters. See
also LIST.
ALIAS internal-name Macro name (default is entry name)
LINKAGE Call instruction (default is CALLS)
TYPENAME type-name n/a
STRUCTURE See Note 1.
name BYTE [SIGNED] .
name INTEGER_BYTE [SIGNED] .
name WORD [SIGNED] .
name INTEGER_WORD [SIGNED] .
name LONGWORD [SIGNED] .
name INTEGER_LONG [SIGNED] .
name INTEGER [SIGNED] .
name INTEGER_HW [SIGNED] .
name HARDWARE_INTEGER
[SIGNED]
.
name QUADWORD [SIGNED] .
name INTEGER_QUADWORD
[SIGNED]
.
name OCTAWORD [SIGNED] .
name BYTE UNSIGNED .
name INTEGER_BYTE UNSIGNED .
name WORD UNSIGNED .
name INTEGER_WORD UNSIGNED .
name LONGWORD UNSIGNED .
name INTEGER_LONG UNSIGNED .
name INTEGER UNSIGNED .
name INTEGER_HW UNSIGNED .
name HARDWARE_INTEGER
UNSIGNED
.
name QUADWORD UNSIGNED .
name INTEGER_QUADWORD
UNSIGNED
.
name OCTAWORD UNSIGNED .
name F_FLOATING .
name D_FLOATING .
name G_FLOATING .
name H_FLOATING .
name F_FLOATING COMPLEX .
name D_FLOATING COMPLEX .
name G_FLOATING COMPLEX .
name H_FLOATING COMPLEX .
name DECIMAL PRECISION (p,q) .
name ADDRESS .
name POINTER .
name POINTER_LONG .
name POINTER_HW .
name HARDWARE_ADDRESS .
name POINTER_QUAD .
name BOOLEAN .
name user-type-name .
name CHARACTER .
LENGTH n n/a
LENGTH * n/a
VARYING n/a
name BITFIELD LENGTH n Bitfield identifiers are equal to the bit offset of the
item, and a prefix$_name identifier is equal to the size of the bitfield in
bits; see Note 1.
MASK Mask declarations are constants with the "m_" tag
SIGNED n/a; see Note 1.
Default storage class The aggregate is placed in the absolute Psect $ABS$, and
the value of the current location counter is set to the origin at the
beginning of the aggregate. Element names can then be used
as displacements off a register that contains the address of the
actual aggregate.
COMMON storage class An aggregate or item is placed in a Psect that has the
same name as the top-level aggregate or item, and the attributes
SHR, GBL, and OVR. Constant offsets are produced for all
aggregate members.
GLOBAL storage class Generates .EXTERNAL declaration for the top-level name,
and produces offset constants for any aggregate members.
with /GLOBALDEF Generates .GLOBAL declaration and BLKB length for top-level
name, and produces offset constants for any aggregate members.
BASED pointer-name n/a
TYPEDEF n/a
DIMENSION [lbound:]hbound Offsets are appropriately adjusted to allow for the
size of the array.
ORIGIN member-name Aggregate members preceding member-name may be referenced
using negative offsets with member-name as the base.
The MACRO output routine produces declarations that can generate either local
symbol or global symbol definitions. The following is an example of OpenSDL
source code:

MODULE simple;
CONSTANT bits EQUALS 4;
ITEM field BYTE PREFIX tst$ COMMON;
END_MODULE;

The following is the resulting MACRO output:

.MACRO simple,..EQU=<=>,..COL=<:>
bits’..equ’4
.SAVE
.PSECT tst$b_field PIC,OVR,REL,GBL,-
SHR,NOEXE,RD,WRT,LONG
tst$b_field’..col’ <P>lkb 1
.RESTORE
; tst$b_field’..equ’0
.ENDM

When the macro is invoked without arguments, the resulting local definitions
are as follows:

bits = 4
tst$b_field1:
blkb 1

To generate these names as global symbols, invoke the macro with the arguments
<= => and <::>, as follows:

simple ..EQU=<==> ..COL=<::>

This invocation results in the following definitions:

bits == 4
tst$b_field1::
blkb 1

The MACRO output routine always generates a size variable for bitfields,
aggregates, arrays, and character strings, using the tag S_ preceding the
output identifier.

The /VMS_DEVELOPMENT qualifier on the SDL command produces special forms of
macros for entry point declarations.

Note
1. Each identifier produces a constant assignment equal to the byte offset of
the item, as follows:

name = offset-value

Offset-value is the byte offset relative to the origin of the level-1
aggregate. A constant assignment of the following form gives the size in bytes
for aggregates, arrays, and character strings:

prefix$_name = byte-size

2. If /VMS_DEVELOPMENT was specified, the CONSTANT x EQUALS STRING "s"
declaration translates to the following:

.SAVE
.PSECT module_name_STRCONST PIC,CON,REL,NOEXE,GBL,SHR,RD,NOWRT,LONG
$EQU S_x size
$DEF x .ASCII /s/
.RESTORE

If /NOVMS_DEVELOPMENT was specified (default), this declaration translates to
the following:

.SAVE
.PSECT module_name STRCONST PIC,CON,REL,NOEXE,GBL,SHR,RD,NOWRT,LONG
S_x ..equ’size
x’..col’ .ASCII /s/
.RESTORE

where size represents the number of bytes in the string.

Note:
@itemize @bullet
@item Ifthestringcontainsthe/character,anotherdelimitercharacter(pulledfroma
priority list) is used.
@item IfthelengthofthePSECTnameexceeds31charactersafterappending_STRCONST,
the module_name is truncated appropriately before appending _STRCONST.
@end itemize

Pascal Translation Summary

The following table shows the OpenSDL to Pascal language translation summary.

OpenSDL Declaration Pascal Output
MODULE name IDENT string (*** MODULE name IDENT string ***)
Note that when /MODULE is used, a Pascal MODULE
statement of the form MODULE name; is generated.
/* comment (* comment *)
CONSTANT x
EQUALS n; CONST x = n;
EQUALS STRING "s"; CONST x = ’s’;
ENTRY [ASYNCHRONOUS] FUNCTION
[ASYNCHRONOUS] PROCEDURE
PARAMETER (type,...) (formal param_list)
ANY %REF param-name: [UNSAFE] ARRAY [$l1..$u1:INTEGER]
OF $UBYTE
DESCRIPTOR [CLASS_S] for scalars;
[CLASS_S] for CHARACTER LENGTH 1;
[CLASS_A] for nonscalars;
%DESCR for fixed-length VARYING;
RTL_STR_DESC PACKED ARRAY [$l1..$u1:INTEGER] OF CHAR;
IN Default semantics (unless overridden by OUT)
OUT (or IN OUT) VAR, except for CHARACTER LENGTH * and ANY (which
generate %REF)
NAMED param-name Parameter name. If none is given, names will be generated of
the form $P1,...$Pn.
VALUE %IMMED
REFERENCE %REF for CHARACTER LENGTH * and ANY; VAR for all
others if mode OUT or IN OUT; otherwise (IN only) default
mechanism
DEFAULT n := %IMMED value
LIST If OPTIONAL is not specified, generates one required parameter
followed by a parameter with the [LIST] attribute;
if OPTIONAL is specified, only the parameter with [LIST] is
generated.
OPTIONAL :=%IMMED 0
TYPENAME type-name n/a
RETURNS return-data-type FUNCTION name : data-type;
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name Results in [EXTERNAL (entry-name)] and internal-name being
used as entry-name
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE RECORD
UNION RECORD CASE INTEGER OF
0: ...
.
.
n: ...
BYTE [SIGNED] $BYTE—[BYTE] -128..127
INTEGER_BYTE [SIGNED] $BYTE—[BYTE] -128..127
WORD [SIGNED] $WORD—[WORD] -32768..32767
INTEGER_WORD [SIGNED] $WORD—[WORD] -32768..32767
LONGWORD [SIGNED] INTEGER
INTEGER_LONG [SIGNED] INTEGER
INTEGER [SIGNED] INTEGER
INTEGER_HW [SIGNED] $QUAD—[QUAD,UNSAFE]RECORD L0: UNSIGNED; L1:
INTEGER; END for /ALPHA
INTEGER for /VAX
HARDWARE_INTEGER [SIGNED] $QUAD for /ALPHA
$QUAD for /ALPHA, INTEGER for /VAX
QUADWORD [SIGNED] $QUAD
INTEGER_QUADWORD [SIGNED] $QUAD
OCTAWORD [SIGNED] $OCTA—[OCTA,UNSAFE]RECORD L0,L1,L2: UNSIGNED; L3:
INTEGER; END
BYTE UNSIGNED $UBYTE—[BYTE] 0..255
INTEGER_BYTE UNSIGNED $UBYTE—[BYTE] 0..255
WORD UNSIGNED $UWORD—[WORD] 0..65535
INTEGER_WORD UNSIGNED $UWORD—[WORD] 0..65535
LONGWORD UNSIGNED UNSIGNED
INTEGER_LONG UNSIGNED UNSIGNED
INTEGER UNSIGNED UNSIGNED
INTEGER_HW UNSIGNED $UQUAD—[QUAD,UNSAFE]RECORD L0,L1: UNSIGNED;
END for /ALPHA
INTEGER for /VAX
HARDWARE_INTEGER UNSIGNED $UQUAD for /ALPHA
INTEGER for /VAX
QUADWORD UNSIGNED $UQUAD
INTEGER_QUADWORD UNSIGNED $UQUAD
OCTAWORD UNSIGNED $UOCTA—[OCTA,UNSAFE]RECORD L0,L1,L2,L3: UNSIGNED;
END
F_FLOATING SINGLE
D_FLOATING DOUBLE (D_FLOAT$$TYPE if the logical name SDLPASCAL$FLAG
is defined)
G_FLOATING DOUBLE (G_FLOAT$$TYPE if the logical name SDLPASCAL$FLAG
is defined)
H_FLOATING QUADRUPLE
F_FLOATING COMPLEX $UQAD
D_FLOATING COMPLEX $UOCTA
G_FLOATING COMPLEX $UOCTA
H_FLOATING COMPLEX $UOCTAQUAD –[OCTA(2),UNSAFE]RECORD L0,L1,L3,L4,L5,L6,L7:UNSIGNED;
END;
DECIMAL PRECISION (p,q) PACKED ARRAY [1..p+2-mod(p,2)] OF $PACKED_DEC
$PACKED_DEC—[BIT(4),UNSAFE] 0..15
BITFIELD LENGTH n $BIT1—[BIT(1), UNSAFE] BOOLEAN
$BITn—[BIT(n),UNSAFE] 0..2**n-1
MASK CONST prefixM_name = mask-value;
SIGNED n/a
CHARACTER CHAR
LENGTH n PACKED ARRAY [1..n] OF CHAR
LENGTH * PACKED ARRAY [$l..$u] OF CHAR
or VARYING [$m] OF CHAR (if VARYING is also specified)
VARYING VARYING [n] OF CHAR
or VARYING [$m] OF CHAR (if LENGTH * is also specified)
ADDRESS (object-type) ^object-type
If object type is not supplied, generates $DEFPTR, which is
defined as ^$DEFTYP; $DEFTYP is defined as [UNSAFE]
INTEGER
POINTER (object-type) ^object-type
If object type is not supplied, generates UNSIGNED
POINTER_LONG (object-type) ^object-type
If object type is not supplied, generates UNSIGNED
POINTER_HW (object-type) $QUAD for /ALPHA
INTEGER for /VAX
HARDWARE_ADDRESS (object-type)
$QUAD for /ALPHA
INTEGER for /VAX
POINTER_QUAD (object-type) $QUAD
BOOLEAN BOOLEAN
user-type-name user-type-name
Default storage class TYPE
COMMON storage class [COMMON]
GLOBAL storage class [EXTERNAL]
with /GLOBALDEF [GLOBAL]
BASED pointer-name TYPE pointer-name = structure-name
TYPEDEF n/a
name DIMENSION [lbound:]hbound ARRAY [lbound..hbound] OF data type; if lbound
is not supplied, it defaults to 1
ORIGIN member-name n/a

Notes
1. When the /MODULE (default) qualifier is used, OpenSDL generates the Pascal
MODULE statement followed by a block of data type definitions. Both of these
items are omitted when /NOMODULE is specified. This behavior facilitates
combining multiple OpenSDL-generated Pascal output files into a single module.
2. Where type names are required (for example, in parameter lists, function
return types, and pointer data types), they will be generated in a TYPE block
at the beginning of the module. Names have the form module-name$$TYPn,
where module-name is truncated to 20 characters if necessary, and n is an
integer beginning at 1 and incremented by 1 for each type generated in a module.
3. Bitfields cannot be more than 32 bits in length, so type names giving the
appropriate subranges will be generated for each possible bitfield size.
Bitfields of length 1 are a special case.
4. The mask-value generated by OpenSDL for the MASK option of the BITFIELD data
type is an integer.
5. OpenSDL generates only single-level records for Pascal. Thus, you can avoid
writing many long intermediate field names in the Pascal source program. If the
outer level is a structure, a PACKED RECORD is typically declared. If the outer
level is a union; a PACKED RECORD CASE INTEGER is declared.

In the case of multiple levels of structures or unions in OpenSDL, the entire
aggregate is transformed into a PACKED RECORD CASE INTEGER. The intermediate
field-names are themselves declared as BYTE_DATA fields. This translation
scheme may result in several fields in the record having the same name.

PL/I Translation Summary

The following table shows the OpenSDL to PL/I language translation summary.

OpenSDL Declaration PL/I Output
MODULE name IDENT string /*** MODULE name IDENT string ***/
/* comment /*comment*/
CONSTANT x
EQUALS n; %REPLACE x BY n;
EQUALS STRING "s"; %REPLACE x BY ’s’;
ENTRY ENTRY
PARAMETER (type,...) (parameter-descriptor,...)
ANY ANY
DESCRIPTOR DESCRIPTOR or CHARACTER(*) for CHARACTER data type
RTL_STR_DESC ANY CHARACTER(*)
IN n/a
OUT n/a
NAMED param-name n/a
VALUE VALUE
REFERENCE n/a
DEFAULT n n/a
LIST LIST
OPTIONAL OPTIONAL or OPTIONAL TRUNCATE
TYPENAME type-name Special VMS TYPENAME values are recognized.
RETURNS return-data-type RETURNS (returns-descriptor)
NAMED param-name n/a
VARIABLE OPTIONS(VARIABLE)
ALIAS internal-name n/a
LINKAGE n/a
TYPENAME type-name Special VMS TYPENAME values are recognized.
STRUCTURE Structure declaration. An AGGREGATE declaration is always
assigned a level number of 1; subsequent subaggregates are
assigned level numbers 2, 3, and so on.
UNION UNION
BYTE [SIGNED] FIXED BINARY(7)
INTEGER_BYTE [SIGNED] FIXED BINARY(7)
WORD [SIGNED] FIXED BINARY(15)
INTEGER_WORD [SIGNED] FIXED BINARY(15)
LONGWORD [SIGNED] FIXED BINARY(31)
INTEGER_LONG [SIGNED] FIXED BINARY(31)
INTEGER [SIGNED] FIXED BINARY(31)
INTEGER_HW [SIGNED] (2) FIXED BIN(31) for /ALPHA
FIXED BIN(31) for /VAX
HARDWARE_INTEGER [SIGNED] (2) FIXED BIN(31) for /ALPHA
FIXED BIN(31) for /VAX
QUADWORD [SIGNED] BIT(64) ALIGNED
INTEGER_QUAD [SIGNED] BIT(64) ALIGNED
OCTAWORD [SIGNED] BIT(128) ALIGNED
BYTE UNSIGNED BIT(8) ALIGNED
FIXED BINARY(7) for /PLI_DEVELOPMENT
INTEGER_BYTE UNSIGNED BIT(8) ALIGNED
FIXED BINARY(7) for /PLI_DEVELOPMENT
WORD UNSIGNED BIT(16) ALIGNED
FIXED BINARY(15) for /PLI_DEVELOPMENT
INTEGER_WORD UNSIGNED BIT(16) ALIGNED
FIXED BINARY(15) for /PLI_DEVELOPMENT
LONGWORD UNSIGNED BIT(32) ALIGNED
FIXED BINARY(31) for /PLI_DEVELOPMENT
INTEGER_LONG UNSIGNED BIT(32) ALIGNED
FIXED BINARY(31) for /PLI_DEVELOPMENT
INTEGER UNSIGNED BIT(32) ALIGNED
FIXED BINARY(31) for /PLI_DEVELOPMENT
INTEGER_HW UNSIGNED BIT(64) ALIGNED for /ALPHA
(2) FIXED BIN(31)/ALPHA/PLI_DEVELOPMENT
BIT(32) ALIGNED for /VAX
FIXED BIN(31)/VAX/PLI_DEVELOPMENT
HARDWARE_INTEGER UNSIGNED BIT(64) ALIGNED for /ALPHA
(2) FIXED BIN(31)/ALPHA/PLI_DEVELOPMENT
BIT(32) ALIGNED for /VAX
FIXED BIN(31)/VAX/PLI_DEVELOPMENT
QUADWORD UNSIGNED BIT(64) ALIGNED
INTEGER_QUAD UNSIGNED BIT(64) ALIGNED
OCTAWORD UNSIGNED BIT(128) ALIGNED
F_FLOATING FLOAT BINARY (24)
D_FLOATING FLOAT BINARY(53)
G_FLOATING FLOAT BINARY(53)
H_FLOATING FLOAT BINARY(113)
F_FLOATING COMPLEX ANY except as a
D_FLOATING COMPLEX - function return type or union
G_FLOATING COMPLEX - type of a structure member
H_FLOATING COMPLEX - array type
In these cases, respective translations are:
BIT(64)
BIT(128)
BIT(128)
BIT(256)
DECIMAL PRECISION (p,q) DECIMAL (p,q)
BITFIELD LENGTH n BIT(n)
MASK %REPLACE prefixM_name BY mask-value;
SIGNED n/a
CHARACTER CHARACTER(n)
LENGTH n CHARACTER(n)
LENGTH * CHARACTER(*)
VARYING VARYING
ADDRESS POINTER
POINTER POINTER
POINTER_LONG POINTER
POINTER_HW (2) POINTER for /ALPHA
POINTER for /VAX
HARDWARE_ADDRESS (2) POINTER for /ALPHA
POINTER for /VAX
POINTER_QUAD (2) POINTER
BOOLEAN BIT(1) ALIGNED
user-type-name data-type /* user-type-name */
Default storage class BASED attribute
COMMON storage class STATIC EXTERNAL
GLOBAL storage class GLOBALREF
with /GLOBALDEF GLOBALDEF
BASED pointer-name aggregate BASED (pointer-name)
TYPEDEF n/a
name DIMENSION [lbound:]hbound name ([lbound]:hbound)
ORIGIN member-name n/a

Notes
1. In PL/I, you can access values declared using the OpenSDL UNSIGNED keyword
by specifying the name in a POSINT built-in function. The integer value of the
name will be returned; however, this will work only if the sign bit is 0.
2. The mask value generated by OpenSDL for the MASK option of the BITFIELD data
type is a bit-string constant.
3. The OpenSDL declarations BYTE UNSIGNED, WORD UNSIGNED, and LONGWORD
UNSIGNED produce the same PL/I output as the OpenSDL declarations BYTE,
WORD, and LONGWORD, when the /VMS_DEVELOPMENT qualifier is specified.

OpenVMS DCL Translation Summary

The following table shows the OpenSDL to OpenVMS DCL language translation
summary.  Since OpenVMS DCL does not understand procedures or aggregates, only
constants are translated.

OpenSDL Declaration OpenVMS DCL Output

MODULE name IDENT string $ ! MODULE name
/* comment $ ! comment
CONSTANT x
EQUALS n; x = = n
EQUALS STRING "s"; x = = "s"
ENDMODULE name $ ! ENDMODULE

SDML Translation Summary

SDML is not a programming language; the translation is intended to be used as
input to software manuals.

For every AGGREGATE STRUCT files named aggregate-name_PIC.SDML and
aggregate-name_TBL.SDML are generated. Those files also include the constants
defined in the SDL file before the AGGREGATE.
AGGREGATE UNIONs and ITEMs are written into files named PICFILE.DAT and
TBLFILE.DAT. If an SDL file contains more than one ITEM or UNION, multiple
versions of PICFILE.DAT and TBLFILE.DATE will be written.
‘‘PIC’’ files contain drawings, where every member of an AGGREGATE is drawn
according to its size and position. BITFIELDs are not drawn, their size and
position are respected only partly; members following BITFIELDS are not always
positioned correctly. ‘‘TBL’’ files contain tables with a row for every member
of an AGGREGATE.

The HARDWARE_INTEGER and COMPLEX data types are not supported by the SDML
backend.

ENTRY declarations are also not supported by the SDML backend.

DECTPU Translation Summary

The following table shows the OpenSDL to DECTPU language translation summary.
Since DECTPU does not understand procedures or aggregates, only constants are
translated.

OpenSDL Declaration DECTPU Output
MODULE name IDENT string MODULE name
/* comment ! comment
CONSTANT x
EQUALS n; CONSTANT x := n;
EQUALS STRING "s"; CONSTANT x := "s";
ENDMODULE name ENDMODULE

UIL Translation Summary

The following table shows the OpenSDL to UIL language translation summary.
Since UIL does not understand procedures or aggregates, only constants are
translated.

OpenSDL Declaration UIL Output
MODULE name IDENT string ! MODULE name
/* comment ! comment
CONSTANT x
EQUALS n; VALUE x : n;
EQUALS STRING "s"; VALUE x : "s";
ENDMODULE name ! ENDMODULE


@appendix C

@unnumberedsec ASCII Character Set
The following table shows the ASCII character set referred to in Section 3.3.

@multitable @columnfractions .20 .20 .60
@headitem Character @tab ASCII Decimal @tab Hexadecimal
@item NUL @tab 000 @tab 00
@item SOH @tab 001 @tab 01
@item STX @tab 002 @tab 02
@item ETX @tab 003 @tab 03
@item EOT @tab 004 @tab 04
@item ENQ @tab 005 @tab 05
@item ACK @tab 006 @tab 06
@item BEL @tab 007 @tab 07
@item BS @tab 008 @tab 08
@item HT @tab 009 @tab 09
@item LF @tab 010 @tab 0A
@item VT @tab 011 @tab 0B
@item FF @tab 012 @tab 0C
@item CR @tab 013 @tab 0D
@item SO @tab 014 @tab 0E
@item SI @tab 015 @tab 0F
@item DLE @tab 016 @tab 10
@item DC1 @tab 017 @tab 11
@item DC2 @tab 018 @tab 12
@item DC3 @tab 019 @tab 13
@item DC4 @tab 020 @tab 14
@item NAK @tab 021 @tab 15
@item SYN @tab 022 @tab 16
@item ETB @tab 023 @tab 17
@item CAN @tab 024 @tab 18
@item EM @tab 025 @tab 19
@item SUB @tab 026 @tab 1A
@item ESC @tab 027 @tab 1B
@item FS @tab 028 @tab 1C
@item GS @tab 029 @tab 1D
@item RS @tab 030 @tab 1E
@item US @tab 031 @tab 1F
@item SP @tab 032 @tab 20
@item ! @tab 033 @tab 21
@item " @tab 034 @tab 22
@item # @tab 035 @tab 23
@item $ @tab 036 @tab 24
@item % @tab 037 @tab 25
@item & @tab 038 @tab 26
@item ’ @tab 039 @tab 27
@item ( @tab 040 @tab 28
@item ) @tab 041 @tab 29
@item * @tab 042 @tab 2A
@item + @tab 043 @tab 2B
@item @comma{} @tab 044 @tab 2C
@item - @tab 045 @tab 2D
@item . @tab 046 @tab 2E
@item / @tab 047 @tab 2F
@item 0 @tab 048 @tab 30
@item 1 @tab 049 @tab 31
@item 2 @tab 050 @tab 32
@item 3 @tab 051 @tab 33
@item 4 @tab 052 @tab 34
@item 5 @tab 053 @tab 35
@item 6 @tab 054 @tab 36
@item 7 @tab 055 @tab 37
@item 8 @tab 056 @tab 38
@item 9 @tab 057 @tab 39
@item : @tab 058 @tab 3A
@item ; @tab 059 @tab 3B
@item < @tab 060 @tab 3C
@item = @tab 061 @tab 3D
@item > @tab 062 @tab 3E
@item ? @tab 063 @tab 3F
@item @@ @tab 064 @tab 40
@item A @tab 065 @tab 41
@item B @tab 066 @tab 42
@item C @tab 067 @tab 43
@item D @tab 068 @tab 44
@item E @tab 069 @tab 45
@item F @tab 070 @tab 46
@item G @tab 071 @tab 47
@item H @tab 072 @tab 48
@item I @tab 073 @tab 49
@item J @tab 074 @tab 4A
@item K @tab 075 @tab 4B
@item L @tab 076 @tab 4C
@item M @tab 077 @tab 4D
@item N @tab 078 @tab 4E
@item O @tab 079 @tab 4F
@item P @tab 080 @tab 50
@item Q @tab 081 @tab 51
@item R @tab 082 @tab 52
@item S @tab 083 @tab 53
@item T @tab 084 @tab 54
@item U @tab 085 @tab 55
@item V @tab 086 @tab 56
@item W @tab 087 @tab 57
@item X @tab 088 @tab 58
@item Y @tab 089 @tab 59
@item Z @tab 090 @tab 5A
@item [ @tab 091 @tab 5B
@item @backslashchar{} @tab 092 @tab 5C
@item ] @tab 093 @tab 5D
@item ^ @tab 094 @tab 5E
@item _ @tab 095 @tab 5F
@item ‘ @tab 096 @tab 60
@item a @tab 097 @tab 61
@item b @tab 098 @tab 62
@item c @tab 099 @tab 63
@item d @tab 100 @tab 64
@item e @tab 101 @tab 65
@item f @tab 102 @tab 66
@item g @tab 103 @tab 67
@item h @tab 104 @tab 68
@item i @tab 105 @tab 69
@item j @tab 106 @tab 6A
@item k @tab 107 @tab 6B
@item l @tab 108 @tab 6C
@item m @tab 109 @tab 6D
@item n @tab 110 @tab 6E
@item o @tab 111 @tab 6F
@item p @tab 112 @tab 70
@item q @tab 113 @tab 71
@item r @tab 114 @tab 72
@item s @tab 115 @tab 73
@item t @tab 116 @tab 74
@item u @tab 117 @tab 75
@item v @tab 118 @tab 76
@item w @tab 119 @tab 77
@item x @tab 120 @tab 78
@item y @tab 121 @tab 79
@item z @tab 122 @tab 7A
@item @{ @tab 123 @tab 7B
@item | @tab 124 @tab 7C
@item @} @tab 125 @tab 7D
@item ~ @tab 126 @tab 7E
@item DEL @tab 127 @tab 7F
@end multitable

The following table describes the ASCII character abbreviations used in the previous table.

@multitable @columnfractions .20 .20 .20 .40
@headitem Characters @tab Description @tab Characters @tab Description
@item NUL @tab Null @tab DLE @tab Data Link Escape
@item SOH @tab Start of Heading @tab DC1 @tab Device Control 1
@item STX @tab Start of Text @tab DC2 @tab Device Control 2
@item ETX @tab End of Text @tab DC3 @tab Device Control 3
@item EOT @tab End of Transmission @tab DC4 @tab Device Control 4
@item ENQ @tab Enquiry @tab NAK @tab Negative Acknowledge
@item ACK @tab Acknowledge @tab SYN @tab Synchronous Idle
@item BEL @tab Bell @tab ETB @tab End of Transmission Block
@item BS @tab Backspace @tab CAN @tab Cancel
@item HT @tab Horizontal Tabulation @tab EM @tab End of Medium
@item LF @tab Line Feed @tab SUB @tab Substitute
@item VT @tab Vertical Tab @tab ESC @tab Escape
@item FF @tab Form Feed @tab FS @tab File Separator
@item CR @tab Carriage Return @tab GS @tab Group Separator
@item SO @tab Shift Out @tab RS @tab Record Separator
@item SI @tab Shift In @tab US @tab Unit Separator
@item SP @tab Space @tab DEL @tab Delete
@end multitable

@node Index
@unnumbered Index

@printindex cp

@bye
