\input texinfo    @c -*-texinfo-*-
@comment $Id@w{$}
@comment %**start of header
@include version.texi
@settitle Open Structure Definition Langauage @value{VERSION}
@syncodeindex pg cp
@comment %**end of header

@titlepage
@title Guide to the Open Structure Definition Language

@subtitle
This manual describes the Open Structure Definition Language (OpenSDL) and the
OpenSDL translator.
Revision/Update Information: This revised manual supersedes HP and VAX SDL
(Structure Definition Language) Version 3.2.
Operating System and Version: Cygwin 2.11.1 or later
Software Version: OpenSDL Version @value{VERSION}
First Printing, June 1981
Revised, June 1985
Revised, November 1987
Revised, May 1989
Revised, October 2007
Revised, September 2018

@page
@copying
This manual is for OpenSDL (version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2018 Jonathan D. Belanger.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@page
@contents

@ifnottex
@node Top
@top OpenSDL
This is the documentation for the OpenSDL Compiler.

@menu
@end menu

@node Preface
@unnumbered Preface
@cindex preface

This manual describes the Open Structure Definition Language (OpenSDL) and the
OpenSDL translator for use on any compatible operating systems. OpenSDL source
code can be translated to output files in one or more target progamming
languages. OpenSDL is suitable for systems and application programming
environments that use executable programs consisting of modules written in one
or multiple programming languages.

@section Intended Audience
This manual is intended for users who are familiar with one or more programming
languages and who are currently involved in the design and development of
multilanguage programming applications; however, users are not required to have
previous experience with OpenSDL in order to use this manual.

@section Document Structure
This manual contains the following chapters and appendixes.
@table @verb
@item Chapter 1
provides a brief overview of OpenSDL and the translation process.
@item Chapter 2
describes how to create, edit, and process a OpenSDL source file using the
Language-Sensitive Editor (LSE) templates and the SDL command options.
@item Chapter 3
describes the OpenSDL language elements that compose OpenSDL declarations.
@item Chapter 4
describes the function and format of OpenSDL declarations.
@item Appendix A
provides a list and descriptions of OpenSDL diagnostic messages.
@item Appendix B
shows translation summaries for all output languages supported by OpenSDL.
@item Appendix C
is a table showing the ASCII character set.
@end table

If OpenSDL is installed on your system, an online copy of this manual is
contained in the help/manpage folders. You can print a copy of the manual file
on a PostScript or other supported pringer.

@section Associated Documents
If OpenSDL is installed on your system, an online example of an OpenSDL source
file is contained in EXAMPLE.SDL in the public directory SDL$EXAMPLES.

@section Conventions
The following conventions are used in this document.
@multitable @columfractions .3 .7
@headitem Convention @tab Meaning
@item @code @{ STRUCTURE @}
@itemx @code @{ UNION @}
@tab Stacked items within braces indicate that you must select one of the
items.
@item @code [ ]
@tab Simple square brackets indicate that the enclosed item(s) are optional.
@item @code [ COMMON ]
@itemx @code [ GLOBAL ]
@tab Stacked items within brackets indicate that only one item may be selected.
@item @code MODULE name;
@tab Names shown in uppercase letters in examples and format
descriptions are OpenSDL keywords that must be entered as shown. Names and
syntactic elements shown in lowercase letters represent user-specified names
and identifiers.
@item @code arg,...
@tab A comma followed by an ellipsis means that the preceding item may be
repeated one or more times, with commas separating two or more items.
@item @code .
@itemx @code .
@itemx @code .
@tab A vertical ellipsis in an example or figure indicates that not all the
statements or elements are shown.
@item @code @strong{common storage}
@tab Boldface words in text are used to introduce or define a new term, or to
refer to a term used in a code example.
@item @code @underline{$ LSEDIT USER.SDL}
@tab In interactive examples, user input is underlined.
@end table

@section Software and Documentation Reporting and Distribution
If OpenSDL is installed on your system, an online copy of this manual is
contained in SYS$HELP.

@section Summary of Technical Changes
The technical changes for this version of OpenSDL are described in the online release notes file
SDL023.RELEASE_NOTES in SYS$HELP (if OpenSDL is installed on your system) and in the
OpenSDL kit area. You can also access the release notes through the HELP file by typing the
following command:
@code{$ TYPE SYS$HELP:SDL023.RELEASE_NOTES} @key{RET}
The following is a summary of technical changes in OpenSDL Version
@value{VERSION}. (For detailed descriptions and a summary of bug fixes, see the
online release notes file.)
@itemize @bullet
@item
The BASIC$data-type record definitions generated in BASIC language output have
been conditionalized in order to prevent re-definition of these record
structures within a BASIC program.
@item
DIMENSION * now yields name[] instead of name[1] in C language output.
@item
In Pascal language output, the [UNSAFE] attribute is now generated for LIST
parameters that are conformant strings.
@item
The header that is optionally included at the beginning of an output file now
indicates that the file was created by OpenSDL instead of "HP" SDL or "VAX"
SDL.
@item
The DEFAULT clause may now be specified for a parameter of an AGGREGATE type
(i.e. STRUCTURE or UNION).
@item
Macro names generated for ENTRY definitions without an ALIAS clause specified
now conform to OpenVMS macro naming conventions. These macro naming changes
apply only to BLISS and MACRO language output.
@item
SDL no longer generates CHARACTER*1 in FORTRAN language output for aggregate
members of type CHARACTER LENGTH 0. Instead, an informational comment is
generated for the aggregate member.
@item
All behavior by the PL/I backend previously under the control of the
/VMS_DEVELOPMENT qualifier has now been placed instead under the control of a
new qualifier, /PLI_DEVELOPMENT.
@item
The DESCRIPTOR and RTL_STR_DESC parameter passing mechanism attributes are now
translated to DESCRIPTOR(S) and DESCRIPTOR(SB), respectively, for ENTRY
arguments of type CHARACTER.
@item
The PASCAL backend now coalesces contiguous TYPE and VAR sections under a
single incurrence of the keyword.
@end itemize

@section New Features
The following is a summary of new features in OpenSDL Version @value{VERSION}.
(For detailed descriptions, see the online release notes file
SDL032.RELEASE_NOTES in SYS$HELP (if OpenSDL is installed on your system) and
in the OpenSDL kit area.)

@itemize @bullet
@item
User-defined data types --- SDL provides the TYPEDEF keyword to allow you to
define additional data types in some languages. TYPEDEF behaves like a Storage Class.
@item
Entry point return types --- This feature extends the syntax of the ENTRY
statement to allow you to specify a user-defined data type as a return type.
@item
The CONSTANT declaration now includes string constants.
@item
Conditional SDL compilation --- SDL now allows you to compile a section of SDL
code conditionally, depending on whether output is being generated for a
particular language or not.
@item
Text pass-through --- SDL provides this feature to allow you to pass literal
text through to the output language file without translation. This feature
allows language-specific constructs that cannot be represented in SDL to be
emitted.
@item
DECLARE statement --- SDL provides this statement to allow you to declare a 
data item of a type that you define, which may be unknown in the current SDL
compilation.
@item
READ statement --- SDL provides this statement to allow you to include a .SDI
intermediate file in the current compilation, without causing it to be emitted
to the output stream.
@item
/SUPPRESS qualifier --- SDL provides this command line qualifier to allow you
to suppress the addition of prefixes and/or tags to names.
@end itemize

@chapter 1

@section Overview
The Open Structure Definition Language (OpenSDL) is used to write source statements that
describe data structures and that can be translated to source statements in other languages.
You can include the resulting output files in a corresponding target language program for
subsequent compilation.
Because OpenSDL is compiler- and language-independent, it is particularly useful for maintaining
multilanguage implementations. For example, you can create and later modify a single
OpenSDL source file that can be translated to multilanguage output files; any number of these
output files can then be included in one or several multilanguage programming applications.
OpenSDL supports the following OpenVMS languages:
@itemize @bullet
@item
Ada
@item
BASIC
@item
BLISS
@item
C/C++
@item
DATATRIEVE
@item
OpenVMS DCL
@item
FORTRAN
@item
MACRO
@item
Pascal
@item
PL/I
@item
SDML
@item
DECTPU
@item
UIL
@end itemize

1.1 The OpenSDL Translation Process
The translation of a OpenSDL source file occurs when you issue the SDL command
(see Section 2.2). The SDL command activates the OpenSDL "front-end" translator
(SDL$MAIN.EXE), which is stored in the directory SYS$SYSTEM. The front end parses
the OpenSDL source code and, if you specify the /LANGUAGE qualifier, passes the parse tree
to one or more of the OpenSDL "back-end" translators. The following table is a list of the back
ends that are stored in the directory SYS$SHARE.
Language Back End
Ada SDL$ADA.EXE
BASIC SDL$BASIC.EXE
BLISS SDL$BLISS.EXE
SDL$BLISSF.EXE1
C/C++ SDL$CC.EXE
DATATRIEVE SDL$DTR.EXE
OpenVMS DCL SDL$DCL.EXE
FORTRAN SDL$FORTRAN.EXE
MACRO SDL$MACRO.EXE
Pascal SDL$PASCAL.EXE
PL/I SDL$PLI.EXE
SDML SDL$SDML.EXE
DECTPU SDL$TPU.EXE
UIL SDL$UIL.EXE
1The BLISSF back end generates BLISS FIELDSETS for OpenSDL aggregates.
Each back end translates only those OpenSDL declarations that can (or need) be expressed
in that language. OpenSDL declarations, described in detail in Chapter 4, translate to the
following types of data items:

@itemize @bullet
@item Scalar or dimensioned scalar data items (ITEM declarations)
@item Nonscalar data items (AGGREGATE and subaggregate declarations)
@item Named constants (CONSTANT declarations)
@item External entries(ENTRY declarations)
@end itemize

Figure 1–1 shows each step in the OpenSDL translation process, and the key following the
example describes each step. Section 2.2 describes the SDL command in detail.

Figure 1–1: OpenSDL Translation Process

Key to Figure 1–1:
! The front end (SDL$MAIN.EXE) parses the statements contained in the OpenSDL source
file TEST.SDL as a result of issuing the SDL command in one of the following four ways:
a. $ SDL/LIST/PARSE/LANGUAGE=BAS TEST.SDL
If you specify the /LANGUAGE qualifier (for example, /LANGUAGE=BAS), the front
end parses the source code and passes the parse tree to the back end for the specified
language (for example, SDL$BASIC.EXE). (The function of the /LIST qualifier is
described at the end of step 1. The /PARSE qualifier is shown here for completeness,
but it is the default for this command and does not need to be specified.)
b. $ SDL/PARSE=TEST/LIST TEST.SDL
If you do not specify the /LANGUAGE qualifier, but specify instead the /PARSE
qualifier and an output file name, the front end parses the source code and writes the
parse tree to an intermediate file with a default file type of .SDI.
c. $ SDL/PARSE=TEST/LIST/LANGUAGE=BAS TEST.SDL
If you specify the /PARSE qualifier with an output file name and the /LANGUAGE
qualifier, the front end parses the source code, writes the parse tree to the specified
intermediate file (for example, TEST), and passes the parse tree to the specified back
end.
d. $ SDL/PARSE/LIST TEST.SDL
If you specify the SDL command with the optional /PARSE and /LIST qualifiers and do
not specify an intermediate file name, the front end parses the source code (checking
for errors), but does not generate an intermediate file.
The front end produces a .LIS file as a result of specifying the /LIST qualifier on all the
SDL commands described in steps 1a. through 1d. The .LIS file contains a line-numbered
copy of your source code and describes any errors or warnings encountered during the
translation process.
" If you specify the /PARSE qualifier and an output file name, as in step 1b. or step 1c.,
you may later decide to translate the intermediate (already parsed) code to one or more
language output files (for example, TEST.BAS) by entering the following command:
$ SDL/NOPARSE/LANGUAGE=BAS TEST.SDI
NOTE
In cases where OpenSDL translation must be performed at a customer site, the
intermediate .SDI file is included in the software HP sends to customers.
# If you enter the command in step 2, the alternate front end (SDL$NPARSE.EXE) passes
the parse tree (in TEST.SDI) to the specified back end (SDL$BASIC.EXE).
$ The specified back end (SDL$BASIC.EXE) produces an output file with the default file
type of .BAS.
You can specify any or all of the language options on the /LANGUAGE qualifier, and OpenSDL
produces separate output files for each language specified.

1.2 Description of a Sample OpenSDL Source File
Example 1–1 is a typical OpenSDL source file, and the key following the example describes each
of the numbered language elements. (Chapter 3 describes all the language elements in detail.)
You may want to familiarize yourself with this example because it shows the source file you
will be creating in the LSE tutorial in Section 2.1.2.
Example 1–1: Sample OpenSDL Source File
MODULE opr_descriptor IDENT "Version 2.0";!
/* define constants and node structure for operators;"
#max_args = 10;#
CONSTANT (fixed_binary,floating,char,untyped) EQUALS 1 INCREMENT 1;$
AGGREGATE operator STRUCTURE%
PREFIX "opr_";&
flink ADDRESS;'
blink ADDRESS;
opcount WORD;
optype CHARACTER LENGTH 1;
id WORD;
operands LONGWORD DIMENSION 0:#max_args-1;(
END operator;
#opsize = .;)
CONSTANT opr_node_size EQUALS #opsize / 2;
ITEM current_node_ptr+> ADDRESS+? GLOBAL;+@
END_MODULE opr_descriptor;+A

Key to Example 1–1:
! All OpenSDL declarations are grouped within modules, and you must assign a name to each
module. The IDENT keyword precedes any commented information that you may want to
add to describe the MODULE declaration.
" Output comments begin with a slash and an asterisk (/*) and are written to the language
output file unless the /NOCOMMENTS qualifier is specified.
# Local symbols begin with a pound sign (#) and are not written to the output file. Local
symbols may be used to express values in declarations. For example, the symbol #max_
args is used in the declaration of the array operands.
$ CONSTANT declarations produce declarations of named constants. When the INCREMENT
option and an increment value are specified, OpenSDL automatically increments the initial
value for each of the declared output constants. In the example, fixed_binary will be
assigned the value 1, floating will be assigned the value 2, and so on.
% AGGREGATE declarations define data structures and their members.
& When the PREFIX option and a prefix are specified, OpenSDL concatenates the prefix and
a data type code to the declared aggregate member names in the language output files.
Compare these aggregate member name declarations with the PL/I output shown
in Example 1–2.
' Aggregate members are declared using reserved OpenSDL data type keywords.
( An aggregate member or a scalar data item can be declared to be an array by specifying
the DIMENSION option. In this example, the array operands has 10 elements, with
subscripts 0 through 9.
) The period (.) represents the current byte offset within an AGGREGATE declaration.
The local symbol assignment #opsize = .; captures the size of the constant portion of the
structure operator. The value of this local symbol is then used in the declaration of the
constant opr_node_size.
+> ITEM declarations, such as the declaration of current_node_ptr, define scalar data
items.
+? The ADDRESS keyword specifies a data type that is an address, or pointer.
+@ The GLOBAL keyword specifies global storage to override the default language storage
class for an ITEM or an AGGREGATE declaration.
+A The END_MODULE keyword ends a MODULE declaration; you may optionally specify the
MODULE name after the END_MODULE keyword.
Example 1–2 shows the PL/I output file that results from translation of the OpenSDL
source file shown in Example 1–1.
Chapter 3 describes all the OpenSDL language elements, and Chapter 4 describes the function
and format of each of the OpenSDL declarations.

Example 1–2: PL/I Output File for the Sample OpenSDL Source File
/**************************************************************************
/* Created 17-AUG-2007 11:23:49 by OpenVMS SDL EV2-3
Source: 13-AUG-2007 08:37:41 FOO$:[DIR]TEST.SDL
/**************************************************************************
/*** MODULE opr_descriptor IDENT Version 2.0 ***/
/* define constants and node structure for operators; */
%replace fixed_binary by 1;
%replace floating by 2;
%replace char by 3;
%replace untyped by 4;
%replace opr_s_operator by 53;
dcl 1 operator based,
2 opr_a_flink pointer,
2 opr_a_blink pointer,
2 opr_w_opcount fixed binary(15),
2 opr_t_optype character(1),
2 opr_w_id fixed binary(15),
2 opr_l_operands (0:9) fixed binary(31);
%replace opr_node_size by 26;
dcl current_node_ptr pointer globalref;

@chapter 2
Creating, Editing, and Processing a OpenSDL Source File
This chapter describes how to create a OpenSDL source file using the recommended HP
Language-Sensitive Editor (LSE) text editor and how to process your source file using the
SDL command and all its qualifiers.
You can use any text editor to create your source file, including EDT and TPU/EVE. LSE
offers the advantages of being layered on TPU and of giving you the option of selecting either
an EDT- or EVE-style keypad. In addition, LSE increases your productivity as a programmer
by providing you with OpenSDL language-specific templates to help you write your OpenSDL
source code.
Section 2.1.1 describes how to use the LSE templates to enter source code. Section 2.1.2
provides a tutorial to get you started using the LSE templates to write OpenSDL source code.
Section 2.1.3 describes how to compile your source code and use split-screen mode to review
your .LIS and output files from within the LSE editing environment.
Section 2.2 describes the SDL command and the uses of the SDL command qualifiers.
For more information on the advanced features of LSE, see the Guide to HP Language-
Sensitive Editor and HP Source Code Analyzer.
2.1 Creating a OpenSDL Source File with LSE
To invoke LSE, issue the LSEDIT command followed by a file name with an .SDL file type at
the DCL prompt. For example:
$ LSEDIT USER.SDL
NOTE
If you are unable to access OpenSDL or LSE support for OpenSDL, contact your
system manager to ensure that they are installed on your system.
Section 2.1.1 describes how to enter source code using LSE, and Section 2.1.2 provides a
tutorial on using the LSE templates to generate OpenSDL source code. Section 2.1.3 describes
LSE’s compiler interface features.

2.1.1 Entering Source Code Using Placeholders and Tokens
LSE simplifies the tasks of developing and maintaining software systems. LSE provides
the functions of a traditional text editor, plus these additional powerful features: languagespecific
placeholders and tokens, aliases, comment and indentation control, and templates for
subroutine libraries.
Placeholders are markers in the source code that indicate locations where you can provide
program text. Placeholders help you to supply the appropriate syntax in a given context.
Generally, you do not need to type placeholders; rather, they are inserted for you by LSE.
Placeholders are either optional or required. Required placeholders, which are delimited
by braces ( {} ), represent places in the source code where you must provide program text.
Optional placeholders, which are delimited by brackets ( [ ] ), represent places in the source
code where you can either provide additional constructs or delete the placeholder.

The following table describes the three types of LSE placeholders.
Type of Placeholder Description
Terminal Provides text that describes valid replacements for the placeholder
Nonterminal Expands into additional language constructs
Menu Provides a list of options corresponding to the placeholder
You can move forward or backward from placeholder to placeholder. In addition, you can delete
or expand placeholders as needed. Section 2.1.2 shows examples of expanding placeholders.
Tokens typically represent keywords in OpenSDL. When expanded, tokens provide additional
language constructs. You can type tokens directly into the buffer. Generally, you use tokens
when you want to add language constructs and there are no placeholders in an existing
program. For example, typing AGGREGATE and issuing the EXPAND (CTRL/E) command
causes a template for an AGGREGATE declaration to appear on your screen. You can also use
tokens to bypass long menus in cases where expanding a placeholder, such as {statement}, will
result in a lengthy menu.
You can use tokens to insert text when editing an existing file by typing the name for a
function or keyword and pressing CTRL/E.

LSE commands allow you to manipulate tokens and placeholders. The following table shows the
LSE commands and their default key bindings.
Command Key Binding Function
EXPAND CTRL/E Expands a placeholder
UNEXPAND PF1 - CTRL/E Reverses the effect of the most recent
placeholder expansion
GOTO PLACEHOLDER/FORWARD CTRL/N Moves the cursor to the next placeholder
GOTO PLACEHOLDER/REVERSE CTRL/P Moves the cursor to the previous
placeholder
ERASE PLACEHOLDER/FORWARD CTRL/K Erases a placeholder
UNERASE PLACEHOLDER PF1 - CTRL/K Restores the most recently erased
placeholder
None # Moves the indicator down through a
menu
None " Moves the indicator up through a
menu
None { ENTER } or Selects a menu option
{ RETURN }
You can display a list of all defined tokens and placeholders, or a particular token or placeholder,
with the LSE commands SHOW TOKEN and SHOW PLACEHOLDER. To copy the
listed information into a separate file, first issue the appropriate SHOW command to put the
list into the $SHOW buffer. Then issue the following commands:
LSE> GOTO BUFFER $SHOW
LSE> WRITE filename
To obtain a hard copy of the list, use the PRINT command at DCL level to print the file you
created.
2.1.2 Getting Started with the LSE Templates for OpenSDL
This section provides a tutorial on using some common tokens and placeholders to write 
SDL source code. The tutorial shows expansions of the following OpenSDL declarations and
language elements:
@itemize @bullet
@item MODULE declaration
@item Output comment
@item Local symbol declaration
@item CONSTANT declaration
@itgem AGGREGATE declaration
@item ITEM declaration
@end itemize

Example 2–1 shows the sample OpenSDL source file described in Chapter 1. You will be creating
this sample source file in the following tutorial. The numbered callouts in the example
correspond to the source code you will be entering in each step.
Following each step, intermediate and resulting screen displays highlight the source code you
just entered.
As you step through the tutorial, refer to Section 2.1.1 for the commands that manipulate
tokens and placeholders. You can also access online help by typing HELP at the LSE> prompt.
Remember that braces ( @{@} ) enclose required placeholders; brackets ( [ ] ) enclose optional
placeholders. When you erase an optional placeholder, LSE also deletes any associated text
before and after that placeholder.

Example 2–1: Creating a Sample OpenSDL Source File Using LSE
MODULE opr_descriptor IDENT "Version 2.0";!
/* define constants and node structure for operators;"
#max_args = 10;#
CONSTANT (fixed_binary,floating,char,untyped) EQUALS 1 INCREMENT 1;$
AGGREGATE operator STRUCTURE
PREFIX "opr_";%
flink ADDRESS;&
blink ADDRESS;
opcount WORD;
optype CHARACTER LENGTH 1;
id WORD;
operands LONGWORD' DIMENSION 0:#max_args-1;(
END operator;
#opsize = .;)
CONSTANT opr_node_size EQUALS #opsize / 2;+>
ITEM current_node_ptr ADDRESS GLOBAL;+?
END_MODULE opr_descriptor;
Before starting the tutorial, invoke LSE and create a new OpenSDL source file. The initial
string, [module]...;, appears at the top of the screen. Expand the initial string by pressing
CTRL/E, and the following appears on your screen:
[copyright-statement]
MODULE {module-name} [ident-string];
[statement]...;
END_MODULE [module-name];
[module]...;
You may expand the [copyright-statement] placeholder, but for the purposes of this tutorial,
it has been deleted by pressing CTRL/K.

! Move to the required placeholder {module-name} by pressing CTRL/N and type
opr_descriptor. Then move to the optional placeholder [ident-string]. As you move
the cursor, notice that LSE inserts the opr_descriptor module name for the END_MODULE
name as well. Expand [ident-string] and type Version 2.0 over the resulting placeholder
"[ident-text]". Your screen will look as follows:

" Move to the placeholder [statement] and press CTRL/E. LSE displays a menu of options.
Press the down arrow ( #) key to move the pointer to the menu option {output-comment}
and press RETURN. Type define constants and node structure for operators over the
placeholder [TBS]. Your screen will look as follows:

# Move to the placeholder [statement] and press CTRL/E. LSE displays a menu of options.
Press the down arrow ( #) key to move the pointer to the menu option {local-assignment}
and press RETURN. Type max_args over the current placeholder {local-symbol}. Move to
the placeholder {expression} and type the value 10. Your screen will looks as follows:

$ Move to the placeholder [statement] and press CTRL/E. Press RETURN to select the
menu option {constant-declaration} displayed on your screen. Your screen will look as
follows:

Press CTRL/E to expand the current placeholder {constant-definition}. Press the down
arrow ( #) key to move the pointer to the menu option "([constant-name]...) EQUALS
{CONSTANT-expression} [increment-expression]" and press RETURN. Your screen will
look as follows:

Type fixed_binary, floating, char, and untyped over the current placeholder [constantname].
Press CTRL/K to delete the last occurrence of the placeholder [constant-name].
Move to the placeholder {CONSTANT-expression} and type the value 1. Move to the placeholder
[increment-expression] and press CTRL/E. Move to the resulting placeholder
{expression} and type the value 1. Your screen will look as follows:
Move to the three optional placeholders [prefix-declaration], [tag-declaration], and
[counter-declaration] and delete each of them by pressing CTRL/K.

% Expand the current placeholder [statement]. Press the down arrow (#) key to move the
pointer to the menu option {aggregate-declaration} and press RETURN. Your screen
will look as follows:

Move to the placeholder {aggregate-name} and type operator.
Move to the placeholder {aggregate_type} and press CTRL/E. Press RETURN to select
the menu option "STRUCTURE" displayed on your screen.
Press CTRL/E to expand the current placeholder [aggregate-options]. Press RETURN
to select the menu option {member-options} : PREFIX, TAG, OR DIMENSION displayed on
your screen. Press RETURN again to select the new menu option {PREFIX-DECLARATION} :
PREFIX.
Type "opr_" over the current placeholder {prefix_string}. Your screen will look as follows:

& Move to the placeholder [aggregate-options] and press CTRL/K to delete it. Expand the
current placeholder [member-declaration]. Press RETURN to select themenu option
{member-name} {member-type} [member-options] displayed on your screen. Your
screen will look as follows:

Type the first member name flink over the current placeholder {member-name}. Move
to the placeholder {member-type} and press CTRL/E. Press the down arrow (#) key
to move the pointer to the menu option {address-declaration} : Address (pointer)
datatype declaration and press RETURN. Press RETURN again to select the menu
option "ADDRESS". Your screen will look as follows:

' Delete the current placeholder [member-options]. The cursor is now on the current
placeholder [member-declaration]. Follow the steps described in the previous paragraph
for the blink, opcount, optype, id, and operands members shown on each line in the
example callout '. Note the differences in syntax required for some of themember names.
Your screen will look as follows:

( Press CTRL/E to expand the current placeholder [member-options]. Press the down
arrow ( #) key to select the menu option {dimension-declaration}. Press RETURN again
to select the menu option "DIMENSION [lower-bound] {upper-bound}". Your screen will
look as follows:

Press CTRL/E to expand the current placeholder [lower-bound]. Expand the resulting
current placeholder {bound-specifier} and type 0 over the resulting current placeholder
{expression}:. Move to the placeholder {upper-bound} and press CTRL/E. Type
#max_args-1; over the resulting current placeholder {expression}. Your screen will look
as follows:
Move to the optional placeholders [member-options] and [member-declaration] and
press CTRL/K to delete each of them.

) Expand the current placeholder [statement]. Press the down arrow (#) key to move the
pointer to the menu option {local-assignment} and press RETURN. Your screen will look
as follows:

Type opsize over the current placeholder {local-symbol}. Move to the placeholder {expression}
and press CTRL/E. Press the down arrow (#) key to move the pointer to the
menu option {offset-location-symbol} and press RETURN. Press RETURN again to
select the new menu option {origin-byte-offset-symbol}. Your screen will look as follows:

+> Expand the current placeholder [statement]. Press RETURN to select themenu option
{constant-declaration} displayed at the top of the screen. Press CTRL/E to expand the
current placeholder {constant-definition}. Press RETURN to select the menu option
"{constant-name} EQUALS {CONSTANT-expression}". Your screen will look as follows:

Type opr_node_size over the current placeholder {constant-name}. Move to the placeholder
{CONSTANT-expression} and press CTRL/E. Press the down arrow (#) key to move
the pointer to the menu option {expression} / {expression} and press RETURN. Type the
expression #opsize over the resulting current placeholder {expression}. Move to the next
placeholder {expression} and type the value 2. Your screen will look as follows:
Move to the three optional placeholders [prefix-declaration], [tag-declaration], and
[counter-declaration] and delete each of them by pressing CTRL/K.

+? Expand the current placeholder [statement]. Press the down arrow (#) key to move the
pointer to the menu option {item-declaration} and press RETURN. Your screen will look
as follows:
Type current_node_ptr over the current placeholder {item-name}. Move to the placeholder
{item-data-type} and press CTRL/E. Select the menu option {address-declaration} and
then press RETURN to select the menu option "ADDRESS". Press CTRL/E to expand
the current placeholder [storage-class]. Move to themenu option "GLOBAL" and press
RETURN. Press CTRL/K to delete the current placeholder [item-options]. Move to the
placeholders [statement] and [module] and press CTRL/K to delete them.
Your resulting screen display should be the OpenSDL source file shown in Example 2–1.
2.1.3 Compiling Source Code
You can compile your source code, review compilation errors, and view your output file without
leaving the editing session by using the LSE command COMPILE with the SDL command and
the /LIST qualifier. If you enter only the COMPILE command, a DCL command that invokes
the OpenSDL compiler is issued in a subprocess. For example:
LSE> COMPILE
STARTING COMPILATION: SDL/PARSE/LIST USER.SDL
COMPILATION OF BUFFER USER.SDL COMPLETED
The compiler generates a .LIS file of compile-time diagnostic information that you can review
by entering the following command:
LSE> GOTO FILE USER.LIS
You have the option of entering split-screen mode first by typing the LSE command CHANGE
WINDOW_MODE and then the GOTO FILE USER.LIS command. This allows you to view
and compare your compilation errors in one window and then return to the other window to
correct your source code.
To generate an output file from within LSE, you must use the COMPILE command with the
SDL command as follows:
LSE> COMPILE SDL/LIST/LANG=BASIC
STARTING COMPILATION: SDL/LIST/LANG=BASIC USER.SDL
COMPILATION OF BUFFER USER.SDL COMPLETED
You can then view your output file from within LSE by issuing the following command:
LSE> GOTO FILE USER.BAS
LSE supports all of the OpenSDL compiler’s command qualifiers as well as user-supplied
command procedures. You can specify DCL qualifiers, such as /LIBRARY, when invoking the
compiler from LSE.
Section 2.2 describes how to process a OpenSDL source file using the SDL command and all its
qualifiers.

NOTE
OpenSDL does not support the LSE command REVIEW. The OpenSDL-generated
.LIS file, which you can view from within LSE, gives you the capability to review
compilation errors.
2.2 Processing a OpenSDL Source File
The SDL command invokes the OpenSDL translator from DCL command level to produce
output files for one or more target languages. The SDL command has the following format:
SDL[/qualifier[...]] file-spec[/qualifier[...]],...
Section 2.1.3 describes how the SDL command and all its qualifiers can be entered from within
LSE when used with the LSE command COMPILE.
Command Parameter
file-spec,...
Specifies one or more OpenSDL source files to be translated. A file specification must specify
a file name; if it does not include a file type, OpenSDL uses the default file type .SDL. You
can specify multiple input files, separated by commas. OpenSDL translates each source file
individually and creates separate output files for each.
Wildcards are not allowed in the file specification.
Command Qualifiers
Command qualifiers may be specified following the SDL command, or they may be used to
qualify individual file specifications. Table 2–1 lists all the optional SDL command qualifiers
and their defaults.
Table 2–1: SDL Command Qualifiers and Their Defaults
Qualifier Default
/ALIGNMENT No alignment
/ALPHA_AXP /ALPHA_AXP on Alpha and IA64 systems
/B64 none
/BACKEND_OPTION none
/[NO]CHECK_ALIGNMENT /NOCHECK_ALIGNMENT
/[NO]COMMENTS /COMMENTS
/[NO]COPYRIGHT /NOCOPYRIGHT
/[NO]C_DEVELOPMENT /NOC_DEVELOPMENT
/[NO]DUMP[=file-spec] /NODUMP
/[NO]GLOBAL_DEFINITION /NOGLOBAL_DEFINITION
/[NO]HEADER /HEADER

Table 2–1 (Cont.): SDL Command Qualifiers and Their Defaults
Qualifier Default
/LANGUAGES=(language[=file-spec],...) No languages
/[NO]LIST /NOLIST (interactive)
/LIST (batch)
/[NO]MEMBER_ALIGN /NOMEMBER_ALIGN
/[NO]MODULE /MODULE
/[NO]PARSE[=file-spec] /PARSE
[/NO]PLI_DEVELOPMENT /NOPLI_DEVELOPMENT
/[NO]SUBFIELDS /NOSUBFIELDS
/[NO]SUPPRESS /NOSUBFIELDS
/SYMBOLS No symbols
/VAX /VAX on VAX systems
)
/[NO]VMS_DEVELOPMENT /NOVMS_DEVELOPMENT
/ALIGNMENT=value
The assumed alignment. Integer value greater than zero. If specified, diagnostic messages are
emitted for data items that do not fall on the assumed alignment.
/ALPHA_AXP
Note the following:
@itemize @bullet
@item The size of certain data types (HARDWARE_ADDRESS, INTEGER_HW,
HARDWARE_INTEGER, POINTER_HW) is 8 bytes if /ALPHA_AXP is specified and 4 bytes
otherwise.
@item BITFIELDs can have 64 bits if /ALPHA_AXP is specified and only 32 bits
otherwise.
@item BASIC defines the data type HUGE as BASIC$HFLOAT_AXP if /ALPHA_AXP is
specified and as HFLOAT otherwise and HUGE_COMPLEX as
BASIC$H_FLOATING_COMPLEX_AXP if /ALPHA_AXP is specified and as
BASIC$H_FLOATING_COMPLEX otherwise.
@item CC writes alignment pragmas to the output file only if /ALPHA_AXP is
specified.
@item CC generates 64-bit pointers only if /ALPHA_AXP is specified.
@item CC generates QUADWORD data types as __int64 if /ALPHA_AXP is specified
and as int[2] otherwise.
@end itemize
/[NO]B64
This qualifier is only valid for the languages BLISS and BLISSF.
The default extension for the output file is .R64 if /B64 is specified and .R32 otherwise.
The word size used in BITFIELDs is 64 bits if /B64 is specified and 32 bits otherwise.
The name used for conditional compilation changes from BLISS or BLISSF to BLISS64 or
BLISSF64, respectively.
You cannot specify the qualifiers /B64 and /VAX together.

/[NO]BACKEND_OPTION={language=language-option}
{(language=language-option,...)}
The qualifier accepts a list of languages and a value for every language. The syntax of the
value is backend-specific.
At the moment, only the CC backend supports this qualifier. It accepts the value INT64_FOR_
QUAD, which indicates that the SDL quadword data type is always mapped to the C _ _int64
data type. This is done on 64bit-systems only (i.e. Alpha and IA64), not on VAX systems, since
there is no _ _int64 data type on VAX systems.
/[NO]CHECK_ALIGNMENT
If specified, diagnostic messages are emitted for data items that do not fall on their natural
alignment.
/[NO]COMMENTS
Controls whether output comments are included in the output file. For more compact target
language representation, use the /NOCOMMENTS qualifier to save file space. The default is
/COMMENTS.
/[NO]COPYRIGHT
Controls whether a standard copyright header is produced in the output file. The
/COPYRIGHT qualifier causes the OpenSDL translator to precede the output with a comment
containing the standard Hewlett-Packard copyright claim. The default is /NOCOPYRIGHT.
/[NO]C_DEVELOPMENT
Only used by the CC backend.
If an input file contains more than one module, C generates one .h file per module if either
/C_DEVELOPMENT or /VMS_DEVELOPMENT is specified and one file containing all the
modules otherwise.
C defines a macro with all lowercase characters to equal the same name in all uppercase
characters for every entry node if either /C_DEVELOPMENT or /VMS_DEVELOPMENT is
specified.
C creates function prototypes if either /C_DEVELOPMENT or /VMS_DEVELOPMENT is specified
(although the ones generated with /VMS_DEVELOPMENT only contain "_ _unknown_
params").
C generates most definitions twice if /C_DEVELOPMENT is specified, separated with "#ifdef
__NEW_STARLET" ... "else" ... "endif". The "__NEW_STARLET" definitions contain complete
function prototypes, the "OLD" definitions only "_ _unknown_params". Also the definitions of
structs and unions are different.
The _ _member_alignment pragmas are only generated if both /ALPHA_AXP and /C_
DEVELOPMENT are specified.
C generates "if !defined(__VAXC)" for special cases if /C_DEVELOPMENT or /VMS_
DEVELOPMENT is specified, otherwise "ifdef _ _cplusplus" is generated.
C generates "#ifndef __<module-name>_LOADED" ... if /C_DEVELOPMENT or /VMS_
DEVELOPMENT is specified.

C generates "__required_pointer_size" pragmas if either /VMS_DEVELOPMENT or both /C_
DEVELOPMENT and /ALPHA_AXP are specified.
Together with the /ALPHA_AXP qualifier and the /VMS_DEVELOPMENT qualifier this
qualifier influences the definition of certain data types and the generation of certain pragmas,
e.g. the data type QUADWORD is defined as _ _int64 if /ALPHA_AXP is specified
and /VMS_DEVELOPMENT and not /C_DEVELOPMENT, and as int [2] otherwise, and the
HARDWARE_ADDRESS and POINTER_HW data types are defined as _ _int64 if /ALPHA_
AXP and neither /C_DEVELOPMENT nor /VMS_DEVELOPMENT are specified and as int[2]
if /ALPHA_AXP is not specified, and are not defined if /ALPHA_AXP and one of the qualifiers
/C_DEVELOPMENT or /VMS_DEVELOPMENT is specified.
/[NO]DUMP [=file-spec]
Controls whether the OpenSDL intermediate code is displayed on your screen. If you specify the
/DUMP qualifier with a file specification, the output is sent to the specified file. The default is
/NODUMP.
/[NO]GLOBAL_DEFINITION
Controls whether an item or aggregate declared with the GLOBAL option generates a declaration
indicating that the value of the global data item is defined in this module. In some
languages, this qualifier has no effect; see the individual language translation summaries in
Appendix B and online examples of language output files as a result of processing the OpenSDL
source file EXAMPLE.SDL in SDL$EXAMPLES.
By default, global definitions are not generated; the GLOBAL option designates global data
whose value is defined elsewhere.
/[NO]HEADER
Controls whether a header containing the date and the source file name is included at the
beginning of the output file. The default is /HEADER.
/LANGUAGES={language[=file-spec]}
{(language[=file-spec],...)}
Specifies one or more of the language options listed in Table 2–2 for which the OpenSDL
translator is to produce one or more source output files. By default, OpenSDL writes output
files into separate files in the current default directory. The default file name for each output
file is taken from the file name of the corresponding source file and the default target file type
for each language name.
Table 2–2: OpenSDL Output Language Options and File Types
Language Option Target File Type
Ada /LANGUAGES=ADA .ADA
BASIC /LANGUAGES=BASIC .BAS
BLISS /LANGUAGES=BLISS .R32, .R64
/LANGUAGES=BLISSF .R32, .R641
1The BLISSF back end generates BLISS FIELDSETS for OpenSDL aggregates.

Table 2–2 (Cont.): OpenSDL Output Language Options and File Types
Language Option Target File Type
/LANGUAGES=BLISS64 .R642
C/C++ /LANGUAGES=CC .H
OpenVMS DCL /LANGUAGES=DCL .COM
DATATRIEVE /LANGUAGES=DTR .DTR
FORTRAN /LANGUAGES=FORTRAN .FOR
MACRO /LANGUAGES=MACRO .MAR
Pascal /LANGUAGES=PASCAL .PAS
PL/I /LANGUAGES=PLI .PLI
SDML /LANGUAGES=SMDL .SDML
DECTPU /LANGUAGES=TPU .TPU
UIL /LANGUAGES=UIL .UIL
2The BLISS64 back end generates the same code as the BLISS backend when the /B64 qualifier has been specified.
OpenSDL builds the language image name by concatenating the prefix SDL to the language
option specified on the SDL command. For example, if you specify /LANGUAGE=FORTRAN,
OpenSDL searches for and activates the SDL$FORTRAN.EXE back end. You may abbreviate
most language options, but OpenSDL uses the first image it finds that matches the generated
file specification. For example, if you wish to invoke the BLISSF back end instead of the 
BLISS back end, you must specify /LANGUAGE=BLISSF.
The /LANGUAGE qualifier also allows you to override the default output file specification
for one or more language output files. You can specify a language option followed by the
destination file specification for that language. You must separate the language from the
destination file specification with an equal sign (=) and separate specifications for different
languages with commas.
/[NO]LIST
Controls whether a listing file is produced.
If the SDL command is executed from interactive mode, /NOLIST is the default. If the SDL
command is executed from batch mode, /LIST is the default.
The /LIST qualifier causes the OpenSDL translator to produce a listing file with numbered lines
of source code and descriptions of any compilation errors. The listing file has the same name
as the related source file and a file type of .LIS.
/[NO]MEMBER_ALIGN
Specifies that every item in aggregates should be aligned. This is the same as specifying
ALIGN on all aggregates.

/[NO]MODULE
Controls whether a Ada package or a Pascal module is generated in the output file.
The default is /MODULE. The /[NO]MODULE qualifier affects only the Pascal and 
Ada languages.
/[NO]PARSE [=file-spec]
Controls whether OpenSDL reads or writes a OpenSDL intermediate file. A OpenSDL intermediate
file contains OpenSDL source code that has already been parsed using the SDL/PARSE
command. The default file type for the OpenSDL intermediate file is .SDI.
The intermediate file produced as a result of the SDL/PARSE command can later be used instead
of OpenSDL source code as input to the back end. This is done using the SDL/NOPARSE
command. When this qualifier appears in an SDL command line, the input file specification
is assumed to be that of an SDL intermediate file with a default file type of .SDI. Examples 4
and 5 at the end of this section show the uses of the /[NO]PARSE qualifiers.
/[NO]PLI_DEVELOPMENT
Only used by the PLI backend.
This qualifier specifies the definition of certain data types, e.g. most integral data types
are defined as fixed binary (n) if /PLI_DEVELOPMENT is specified and as bit(n) aligned
otherwise.
In addition, the type names of certain parameters are changed, e.g. "ASTADR" to "entry
value" and "MASK_BYTE" to "bit (8) aligned".
Default parameters that are not optional are marked as "optional" if /PLI_DEVELOPMENT is
specified
/[NO]SUBFIELDS
When this qualifier is given, the BLISSF backend handles subfields of members declared with
a named type differently.
/SUPPRESS ={suppress-option}
{(suppress-option,...)}
The /SUPPRESS qualifier has the following format:
SDL /SUPPRESS=(PREFIXES, TAGS)
Note the following:
@itemize @bullet
@item The suppress-options can be either PREFIXES or TAGS.
@item The qualifier may appear any where in the command line where a qualifier
is valid.
@item Output in all languages in that compilation is affected. It is not
possible to make the qualifier position-dependent (CDU constraint).
@item Either PREFIXES or TAGS, or both, may be included in the list.
@item If both prefixes and tags are suppressed, the connecting underscore is
also suppressed.
@item The effect on the intermediate tree is as though null prefixes and/or
tags had been specified throughout the source. There are therefore no changes
to the back ends.
@end itemize

/SYMBOLS={symbol=value}
{(symbol=value,...)}
It is possible to specify symbols and values which can be used in the IFSYMBOL statement
(kind of conditional compilation).
See IFSYMBOL.
/VAX
For modules, FORTRAN writes the following comment to the output file:
!DEC$ OPTIONS/ALIGN=(RECORDS=PACKED,COMMONS=PACKED)/NOWARN
CC generates ‘‘double’’ as return type for functions if the actual return type is quadword and
/VAX but not /VMS_DEVELOPMENT is specified.
You cannot specify the qualifiers /ALPHA_AXP and /VAX together. You cannot specify the
qualifiers /B64 and /VAX together.
/[NO]VMS_DEVELOPMENT
Modifies the behavior of certain OpenSDL back ends so that the generated output files conform
to specific VMS development standards.
Ada defines the data types QUADWORD and INTEGER_QUAD as INTEGER_64 if
/ALPHA_AXP and /VMS_DEVELOPMENT is specified and as UNSIGEND_QUADWORD
otherwise.
For BLISS and BLISSF, the /VMS_DEVELOPMENT qualifier causes ENTRY declarations
to generate KEYWORD macros in the output (.R32) file and defines routines as ‘‘external
routine routine-name : novalue’’ otherwise.
BLISS’ and BLISSF’s generation of certain ‘‘literal’’s for the sizes of structures or unions
depends on this qualifier.
The following rules apply when the /VMS_DEVELOPMENT qualifier is specified for 
BLISSF output:
@itemize @bullet
@item User fill fields are ignored.
@item Nested structures are ignored.
@item Macros are generated instead of fields for certain level one items.
@end itemize
CC handles user fill depending on /VMS_DEVELOPMENT.
CC handles references to aggregates within typedef’d aggregates different when /VMS_
DEVELOPMENT is specified.
For MACRO, the /VMS_DEVELOPMENT qualifier causes the VMS macros $EQU, $DEF,
$DEFINI, and $DEFEND to be generated in the output (.MAR) file.
For Pascal, the /VMS_DEVELOPMENT qualifier causes "$TYPE" to be appended to the
names of structures and unions in the output (.PAS) file.
The following rules apply when the /VMS_DEVELOPMENT qualifier is specified for Pascal
output:
@itemize @bullet
@item ‘‘readnode’’ modules are prefixed with ‘‘PASCAL$’’.
@item The generation of certain fill fields is suppressed.
@item ‘‘$TYPE’’ is appended to data types that have no ‘‘$’’ in their name.
@item An error message is emitted if a complex data type is encountered.
@item The type ‘‘$DEFPTR’’ is generated for user data types instead of the
actual data type.
@end itemize
The following rules apply when the /VMS_DEVELOPMENT qualifier is specified for 
PL/I output:
@itemize @bullet
@item UNSIGNEDBYTE,UNSIGNEDWORD,andUNSIGNEDLONGWORDyieldFIXED
BINARY(7), FIXED BINARY(15), and FIXED BINARY(31), respectively.
@item SpecialVMSTYPENAMEvaluesarerecognized.
@item DEFAULTnforn<>0generatesOPTIONAL.
@end itemize
The default is /NOVMS_DEVELOPMENT.
Examples
The following are examples and descriptions of the SDL command.
1. $ SDL BLOCKNODE/LANGUAGE=(PLI=PLI$:[PL1.PSRC],CC=C$:[C.CSRC])
OpenSDL translates the declarations in BLOCKNODE.SDL to PL/I and C, writes
the PL/I output to PLI$:[PL1.PSRC]BLOCKNODE.PLI, and writes the C output to
C$:[C.CSRC]BLOCKNODE.H.
2. $ SDL VTREE.SRC/LANGUAGE=(PLI=[PLI.PSRC])
OpenSDL translates the declarations in VTREE.SRC and writes the PL/I output to
[PLI.PSRC]VTREE.PLI.
3. $ SDL/LANGUAGE=(MACRO,BLISS) IODEF,SSDEF
OpenSDL translates the declarations in IODEF.SDL and SSDEF.SDL and writes the output to
IODEF.MAR, IODEF.R32, SSDEF.MAR, and SSDEF.R32.
4. $ SDL/PARSE=INTER TEST
OpenSDL translates the declarations in the source file TEST.SDL and writes the output to a
OpenSDL intermediate file called INTER.SDI.
5. $ SDL/NOPARSE/LANG=(MACRO,BLISS) INTER
OpenSDL translates the declarations that have already been parsed by the OpenSDL front end
in INTER.SDI and writes the output to INTER.MAR and INTER.R32.

@chapter 3
OpenSDL Language Elements
This chapter describes the function and syntax of the following OpenSDL language elements
that compose the OpenSDL declarations described in Chapter 4:
@itemize @bullet
@item User-specified names, which can be either local symbol names or source
program identifiers
@item Reserved OpenSDL keywords
@item Expressions
@end itemize
The following can also be used within a MODULE declaration; although they are not OpenSDL
language elements (see Section 3.4 through Section 3.6):
@itemize @bullet
@item Local and output comments
@item INCLUDE statement
@item READ statement
@item Conditional compilation
@item Text pass-through
@item DECLARE statement
@end itemize
The space, tab, or carriage return character delimits the language elements, and a semicolon
(;) terminates each declaration. In MODULE and AGGREGATE declarations, the semicolon
also terminates separate parts of the declaration.
Appendix B shows language translation summaries of all the OpenSDL language elements.
3.1 Names
A OpenSDL name can be either a user-specified local symbol name that is not translated to
the output file or a user-specified source program identifier that is translated to the output
file. Names are composed of upper- and lowercase letters (A - Z, a - z), numbers (0 - 9), the
dollar sign ($), and the underscore (_). Specifying a name is subject to the following rules:
1. Local symbol names must begin with a pound sign (#).
2. Source program identifiers must begin with an alphabetic character (A - Z,
a - z), a dollar sign ($), or an underscore (_).

3. Source program identifiers that are reserved OpenSDL keywords or that contain invalid 
SDL characters must be enclosed in quotation marks
(" "). (For more information on reserved OpenSDL keywords, see Section 3.2.)
4. OpenSDL passes all source program identifiers to the output file in the same case in which
they are defined.
3.1.1 Local Symbol Names
A local symbol name is known only within a OpenSDL source file and cannot be translated
directly to the output file. A local symbol name can be assigned a value anywhere within a
source file, but must begin with the pound sign (#). A local symbol is declared when it is first
assigned a value. This value can be any valid expression (see Section 3.3). If you reference
a local symbol before assigning it a value, OpenSDL displays an error message and does not
produce an output file. A local symbol assignment has the following syntax:
#local-name = expression;
#local-name
Is any valid OpenSDL name.
expression
Is any valid OpenSDL expression resulting in a longword integer value.
Signed integer longword data types are described in Section 3.2.3.9.
The following are examples of local symbol assignments:
#max_args = 255;
#counter = #counter + 1;
The values of these local symbols may be referenced by subsequent declarations, as shown in
the following example:
CONSTANT block_node_size EQUALS #max_args + #counter;
3.1.2 Source Program Identifiers
Source program identifiers (identifiers) specify declaration names, AGGREGATE member
names, and ENTRY parameter names that are passed to the output file. Optional userspecified
prefixes and tags can be appended to these identifiers. If a prefix is specified without
a tag, OpenSDL concatenates a default tag (corresponding to the data type) to the identifier
in the output file. (Section 3.2.2.2 describes the PREFIX and TAG keyword options.) The
identifier block_node_size in the following example names the CONSTANT declaration:
CONSTANT block_node_size EQUALS #max_args + #counter;
To avoid compilation errors, each reference to a particular OpenSDL identifier must be a casesensitive
match because an identifier is passed to the output file in the same case in which it
appears in the source file. You can use reserved OpenSDL keywords and characters that are
not valid in identifiers if you enclose them in quotation marks (" "). For example:
ITEM "length" LONGWORD;

This declaration produces the identifier length, which is a reserved OpenSDL keyword typically
used to specify the length of a bit-string or character-string data type (see Section 3.2.3.3 and
Section 3.2.3.5).
3.2 Keywords
Reserved OpenSDL keywords are used to specify the following:
• Declarations(seeSection3.2.1)
• Declarationmodifiers(seeSection3.2.2)
• Prefixes,markers,andtags(seeSection3.2.2.2)
• Alignment(seeSection3.2.2.3)
• Storageclasses(seeSection3.2.2.4)
• Arrays(seeSection3.2.2.7)
• Datatypes(seeSection3.2.3)
You can use keywords as identifiers if they are enclosed in quotation marks (" "). For example:
ITEM "length" LONGWORD;
This declaration produces the identifier length, which names this particular ITEM declaration.
The length identifier is a reserved OpenSDL keyword that is typically used to specify the
length of a bit-string or character-string data type (see Section 3.2.3.3 and Section 3.2.3.5).
Reserved OpenSDL keywords can be entered in either upper- or lowercase letters, but they
cannot be truncated.
The following sections describe the format and function of each of the reserved OpenSDL
keywords.
3.2.1 Declaration Keywords
Table 3–1 alphabetically lists and defines the keywords for the declarations described in detail
in Chapter 4.
Table 3–1: Keywords That Identify or End Declarations
Keyword Definition
AGGREGATE Declaration that produces a structure or union body
CONSTANT Declaration of a named constant
END Delimiter for the end of an aggregate body
END_MODULE Delimiter for the end of a module
ENTRY Declaration of an entry
ITEM Declaration of an item
MODULE Declaration of a module

Table 3–1 (Cont.): Keywords That Identify or End Declarations
Keyword Definition
STRUCTURE Declaration that is a type of aggregate or subaggregate
UNION Declaration that is a type of aggregate or subaggregate
3.2.2 Declaration Modifier Keywords
Table 3–2 lists and defines other keywords that are used in declarations. The prefix and tag,
storage class, and array keywords have special functions that are described in detail in the
sections following Table 3–2. All the other keywords defined in Table 3–2 are described in
greater detail in Chapter 4.
Table 3–2: Keywords Used in Declarations
MODULE Declaration
Keyword Description
IDENT Optional keyword used to pass information describing the MODULE declaration to
the output file
ITEM Declaration
Keyword Description
ALIGN,
NOALIGN,
BASEALIGN
Optional keywords used to specify alignment; see Section 3.2.2.3
COMMON and
GLOBAL
Optional keywords used to specify common and global storage; see Section 3.2.2.4
DIMENSION Optional keyword used to specify that the ITEM declaration is an array; see
Section 3.2.2.7
PREFIX Optional keyword used to concatenate a user-defined prefix to ITEM names,
AGGREGATE member names, and named constants; see Section 3.2.2.2
TAG Optional keyword used to override the default OpenVMS code assigned to a name
and to assign a user-defined tag instead; see Section 3.2.2.2
AGGREGATE Declaration
Keyword Description
COMMON,
GLOBAL,
BASED,
TYPEDEF
Optional keywords used to specify common, global, or based storage, or a TYPEDEF;
see Section 3.2.2.4

Table 3–2 (Cont.): Keywords Used in Declarations
AGGREGATE Declaration
Keyword Description
DIMENSION Optional keyword used to specify that the AGGREGATE declaration is an array; see
Section 3.2.2.7
FILL Optional keyword used to indicate whether the associated aggregate or member
occurs only as a fill to force byte alignment on the following member or aggregate,
respectively
MARKER Optional keyword used to assign a user-defined prefix to the aggregate name; see
Section 3.2.2.2
ORIGIN Optional keyword used to define the beginning of an aggregate with respect to an
aggregate member
PREFIX Optional keyword used to concatenate a user-defined prefix to AGGREGATE member
names, ITEM names, and named constants; see Section 3.2.2.2
TAG Optional keyword used to override the default OpenVMS code assigned to a name
and to assign a user-defined tag instead; see Section 3.2.2.2
CONSTANT Declaration
Keyword Description
COUNTER Optional keyword that saves the last assigned value in a local symbol declaration
for subsequent use
EQUALS Required keyword used in assigning the value to the first named constant
STRING Optional keyword specified immediately after EQUALS to indicate the definition of
a string constant.
INCREMENT Optional keyword used to specify constants with incremental values
PREFIX Optional keyword used to concatenate a user-defined prefix to aggregate member
names and named constants; see Section 3.2.2.2
TAG Optional keyword used to override the default OpenVMS code assigned to a name
and to assign a user-defined tag instead; see Section 3.2.2.2
TYPENAME Optional keyword used only by the Ada and PL/I back ends to specify a
user-defined data type name; see Section 3.2.2.1
ENTRY Declaration
Parameter-
Passing
Mechanism
Keywords Description
DESCRIPTOR Optional parameter-passing mechanism keyword used to specify that a parameter
must be passed BY DESCRIPTOR

Table 3–2 (Cont.): Keywords Used in Declarations
ENTRY Declaration
Parameter-
Passing
Mechanism
Keywords Description
REFERENCE Optional parameter-passing mechanism keyword used to specify that a parameter
must be passed BY REFERENCE; REFERENCE is the default
RTL_STR_
DESC
Optional parameter-passing mechanism keyword used to specify that a parameter
must be passed by any of the classes of string descriptors
VALUE Optional parameter-passing mechanism keyword used to specify that the parameter
must be passed BY immediate VALUE
Parameter
Mode
Keywords Description
IN Parameter description keyword used to indicate that a parameter is an input
parameter; can be used with OUT to indicate that the parameter is both an input
and an output parameter; IN is the default
OUT Parameter description keyword used to indicate that a parameter is an output
parameter; can be used with IN to indicate that the parameter is both an input and
an output parameter
Other
Parameter
Modifier
Keywords Description
DEFAULT Optional parameter description keyword used to specify a default parameter value
DIMENSION Optional keyword used to specify that the parameter is an array; see Section 3.2.2.7
LIST Optional parameter description keyword used to indicate that the routine may be
called with one or more parameters of the type being described
NAMED Optional parameter description keyword used only by the Ada back end to name
the parameter
OPTIONAL Optional parameter description keyword used to specify that the parameter may or
may not appear in the sequence of parameters using the entry point name
TYPENAME Optional parameter description keyword used only by the Ada and PL/I
back ends to specify a user-defined data type name; see Section 3.2.2.1

Table 3–2 (Cont.): Keywords Used in Declarations
ENTRY Declaration
Entry
Return Value
Keywords Description
NAMED Optional keyword used to specify the name of the parameter (in a Ada IMPORT_
VALUED_PROCEDURE) into which the return value is returned
RETURNS Optional keyword used to specify the data type returned by the external entry
TYPENAME Optional keyword used only by the Ada and PL/I back ends to specify
a user-defined name that is the data type returned by the external entry; see
Section 3.2.2.1
Entry
Description
Keywords Description
ALIAS Optional keyword used to indicate an alternate internal name that can be used to
designate the entry point
LINKAGE Optional keyword used only by the MACRO back end to indicate that a special
call macro will be used in the expansion of the entry macro
PARAMETER Optional keyword used to describe the parameters of the external entry
VARIABLE Optional keyword used to indicate that the entry point can be invoked with a
variable number of parameters; see also the LIST parameter modifier keyword
3.2.2.1 User-Specified TYPENAME keyword
The TYPENAME keyword is used to specify a data type name that is not a OpenSDL data
type. Depending on which back end is specified, this name may or may not override the
OpenSDL data type. The Ada and PL/I back ends use these data type names as
parameter data types, as return value data types, and as CONSTANT declaration data types.
The TYPENAME keyword has the following syntax:
TYPENAME name
The Ada language translation (as a result of processing the OpenSDL source file
EXAMPLE.SDL in SDL$EXAMPLES) shows an example of the TYPENAME keyword. The
following is an example of the TYPENAME keyword on each of the parameters in an ENTRY
declaration:
ENTRY SYS$FAO
ALIAS $FAO
PARAMETER (CHARACTER DESCRIPTOR NAMED CTRSTR IN TYPENAME CHARDESC,
WORD UNSIGNED NAMED OUTLEN OUT DEFAULT 0 TYPENAME NUMBER,
CHARACTER DESCRIPTOR NAMED OUTBUF OUT TYPENAME CHARDESC,
LONGWORD VALUE NAMED P1 OPTIONAL LIST TYPENAME VARIES)
RETURNS LONGWORD TYPENAME CONDVALU;

3.2.2.2 PREFIX, MARKER, and TAG Keywords
User-defined prefixes, markers, and tags are optional character strings that help to uniquely
identify the names associated with a particular facility or system. When the /SUPPRESS
qualifier is specified on the command line, the inclusion of prefixes and/or tags on output
symbol names is suppressed. See Section 2.2 for a description of the /SUPPRESS qualifier.
PREFIX Keyword
The PREFIX option may be specified on an AGGREGATE, subaggregate, CONSTANT, or
ITEM declaration to cause OpenSDL to concatenate a user-specified prefix and the name
specified in the declaration.
When you specify a prefix for an aggregate, OpenSDL concatenates the prefix and the name of
each member or named constant declared within the aggregate. The name of the aggregate
itself is not altered by the use of the PREFIX option. The PREFIX option has the following
syntax:
PREFIX prefix-string
prefix-string
Is a 0- to 32-character string that can be any valid OpenSDL identifier.
If you specify the PREFIX option, OpenSDL constructs the identifier of each member by
concatenating the prefix, a tag, an underscore, and the member name.
You can override a prefix that is currently in effect by specifying a new prefix for a particular
aggregate member. If this member happens to be a subaggregate, the new prefix is applied
to all the members of that subaggregate. Otherwise, if no prefix is specified for the subaggregate,
all subaggregate members are assigned the same prefix as that specified on the level-1
aggregate.
MARKER Keyword
You can use the MARKER keyword to assign a user-defined prefix to the aggregate name. The
MARKER option has the following syntax:
MARKER marker-string
marker-string
Is a 0- to 32-character string that can be any valid OpenSDL name that may or may not be
enclosed in quotation marks (" ") and may be null.
TAG Keyword
The TAG option overrides the default tags that OpenSDL uses in forming identifiers. You can
specify tags for CONSTANT, ITEM, and AGGREGATE declarations and aggregate members.
The tag that you specify, however, affects only the outer-level identifier. For example, a tag
you supply in an AGGREGATE declaration affects only the aggregate name; if you wish to
change all the tags in an aggregate, you must do it on a member-by-member basis. The TAG
option has the following syntax:
TAG tag-string

tag-string
Is a 0- to 32-character string specifying the tag to use in forming the name. If the TAG option
is not specified, OpenSDL uses a default code based on the data type of the name.
If you specify the TAG option, OpenSDL appends the tag-string, which may be null (" "), and an
underscore character (_) to the current prefix-string. A tag consisting of a single underscore
character produces a single underscore character in any resulting identifier.
The following is an example of the PREFIX, TAG, and MARKER keywords:
AGGREGATE operator STRUCTURE MARKER doowop$ PREFIX beebop$ TAG shoo;
flink ADDRESS;
blink WORD;
END;
Table 3–3 shows the default tags that OpenSDL uses when the TAG option is not specified on
an aggregate member.
Table 3–3: Default Tags Used by OpenSDL
Data Type Default Tag
CONSTANT K
BYTE [UNSIGNED] B
WORD [UNSIGNED] W
LONGWORD [UNSIGNED] L
QUADWORD Q
OCTAWORD O
F_FLOATING F
D_FLOATING D
G_FLOATING G
H_FLOATING H
F_FLOATING COMPLEX FC
D_FLOATING COMPLEX DC
G_FLOATING COMPLEX GC
H_FLOATING COMPLEX HC
DECIMAL P
BITFIELD V for BITFIELD offset
S for BITFIELD size1
M for BITFIELD mask1
CHARACTER T
ADDRESS A
BOOLEAN B
1Identifiers with size and mask (if MASK is specified) tags are generated regardless of whether a PREFIX or TAG
option is specified.

Table 3–3 (Cont.): Default Tags Used by OpenSDL
Data Type Default Tag
VOID Z
INTEGER IS
INTEGER_BYTE IB
INTEGER_WORD IW
INTEGER_LONG IL
INTEGER_QUAD IQ
INTEGER_HW IH
POINTER_HW PH
POINTER_LONG PL
POINTER PS
POINTER_QUAD PQ
HARDWARE_ADDRESS HA
HARDWARE_INTEGER HI
STRUCTURE R
UNION R
The following example shows the use of a user-specified prefix on an AGGREGATE declaration:
AGGREGATE operator STRUCTURE
PREFIX opr$;
id WORD;
"typename" CHARACTER;
CONSTANT (fixed_bin_,float_) EQUALS 0 INCREMENT 1;
bits STRUCTURE;
variable_size BITFIELD;
size_units BITFIELD LENGTH 3;
END bits;
END operator;
In the previous example, the member name "typename" is enclosed in quotation marks
because it is a OpenSDL keyword.
The previous declaration produces the following names, with the prefix opr$ and default tags,
in the PL/I output file:
%replace opr$k_fixed_bin_ by 0;
%replace opr$k_float_ by 1;
%replace opr$s_operator by 4;
dcl 1 operator based,
2 opr$w_id fixed binary(15),
2 opr$t_typename character(1),
2 opr$r_bits ,
3 opr$v_variable_size bit(1),
3 opr$v_size_units bit(3),
3 opr$v_fill_0 bit(4);

The name opr$v_fill_0 in the previous list is the result of a BITFIELD declaration that 
SDL supplied because the subaggregate did not end on a byte boundary. The name (opr$v_
fill_0) ensures that the next aggregate begins on a byte boundary. Section 4.5.7 describes
data alignment in detail. OpenSDL uses default codes followed by an underscore (_) for the
tag portion of a prefix when the TAG option is not specified. You can override the default
OpenVMS codes by specifying a tag, which may be null (" "). For example:
CONSTANT (abc,def,ghi) EQUALS 0 INCREMENT 1
PREFIX new
TAG "";
This declaration results in the names new_abc, new_def, and new_ghi.
3.2.2.3 Alignment Keywords
Both the ALIGN and BASEALIGN keywords can ensure that items are properly aligned. The
BASEALIGN keyword takes an argument, which specifies the alignment, whereas the ALIGN
keyword uses the natural alignment of the item.
• IftheALIGNkeywordisincludedinthedefinitionofanaggregate,everymemberwillbe
aligned. Both i1 and i2 will be aligned.
AGGREGATE MyStruct STRUCTURE ALIGN;
c1 CHARACTER;
i1 LONGWORD;
c2 CHARACTER;
i2 LONGWORD;
END;
• IftheALIGNkeywordisincludedinthedefinitionofamemberofanaggregate,thismember
will be aligned, even if the AGGREGATE itself does not have the ALIGN attribute. i2
will be aligned whereas i1 will not be aligned.
AGGREGATE MyStruct STRUCTURE NOALIGN;
c CHARACTER;
i1 LONGWORD;
i2 LONGWORD ALIGN;
END;
• IftheNOALIGNkeywordisincludedinthedefinitionofamemberofanaggregate,no
action will be taken to ensure that this member will be aligned, even if the AGGREGATE
has the ALIGN attribute. i2 will be aligned, i1 will not be aligned.
AGGREGATE MyStruct STRUCTURE ALIGN;
c CHARACTER;
i1 LONGWORD NOALIGN;
i2 LONGWORD;
END;
• IftheNOALIGNkeywordisincludedinthedefinitionofanaggregate,noactionwillbe
taken to ensure that any member of this aggregate will be aligned. Neither i2 nor i1 will
be aligned.

AGGREGATE MyStruct STRUCTURE NOALIGN;
c CHARACTER;
i1 LONGWORD;
i2 LONGWORD;
END;
• IftheBASEALIGNkeywordisincludedinthedefinitionofamemberofanaggregate,
this member will be aligned according to the given alignment. In this case, i2 will have an
offset of 256 (28),
AGGREGATE MyStruct STRUCTURE NOALIGN;
c CHARACTER;
i1 LONGWORD;
i2 LONGWORD BASEALIGN(8);
END;
• IftheBASEALIGNkeywordisincludedinthedefinitionofanaggregateoranitem,the
aggregate or item itself will be padded, so that in an array of elements of this aggregate or
item type, all elements will be aligned according to the given alignment. The syntax is as
follows:
AGGREGATE MyStruct STRUCTURE BASEALIGN (2);
c CHARACTER;
i1 LONGWORD;
i2 LONGWORD;
END;
The size of the aggregate will be a multiple of 4 (22), in this case 12, and neither i1 nor i2 will be
aligned.
In the following example, the item will have a size of 8 (23).
ITEM MyItem LONGWORD UNSIGNED BASEALIGN (3);
3.2.2.4 Storage Class Keywords
Storage class refers to the way in which the target language compiler allocates storage for
scalar items and aggregates. In general, declarations produce a template describing data for
which the compiler allocates storage dynamically at run time, rather than at compile time.
This type of storage is the default and is specified using the BASED option in some languages,
although the default storage class option is language-dependent. The PL/I back end
generates the BASED storage class option, which has the following syntax:
BASED (pointer-name)
In languages that support the construct, you can use the BASED pointer-name option on an
AGGREGATE declaration to bind a named pointer to that aggregate. In all target languages,
the aggregate resulting from such a declaration has the default storage class (BASED).
A subaggregate always acquires the storage class of the aggregate to which it belongs.
The default storage class associated with any declaration is language-dependent. You can
override the default storage class by specifying either of the following storage classes:
• Common storage is allocated in an external program section (Psect) with the OVR option
and is shared by all routines that reference it. You declare data in common storage by

using the COMMON option on an AGGREGATE or ITEM declaration. For example, the
MACRO back end places all declarations in an absolute program section by default
and associates the names with the offset values.
• Global storage represents data in a global storage location whose value is defined
elsewhere. You declare global data by using the GLOBAL option on an AGGREGATE or
ITEM declaration.
For some languages, the /GLOBALDEF qualifier on the SDL command affects the operation
of the GLOBAL option. When this qualifier is used, GLOBAL generates a reference to
global data whose value is defined in this module. You can see the effect of /GLOBALDEF
for each output language by processing the OpenSDL source file EXAMPLE.SDL in
SDL$EXAMPLES.
• TYPEDEF behaves like a storage class. In C, examples of storage classes are static,
globaldef/ref, extern, etc. Syntactically, you can replace a ‘static’ in any declaration with
‘typedef ’ and have it compile. Storage classes (including TYPEDEF) are mutually exclusive
in an SDL declaration.
Example of C type definition:
typedef struct {int jg$l_i1; int jg$l_i2;} MyStruct ;
static MyStruct foo ;
is equivalent to:
static struct {int jg$l_i1; int jg$l_i2;} foo ;
or:
static struct MyStruct {int jg$l_i1; int jg$l_i2;} foo ;
or:
struct MyStruct {int jg$l_i1; int jg$l_i2;} ;
static struct MyStruct foo ;
If COMMON and GLOBAL appear together in a declaration, a DUPCONATT (duplicate or
conflicting attributes) error is given. The COMMON, GLOBAL and TYPEDEF storage classes
are mutually exclusive.
3.2.2.5 SDL Storage Classes and Typedef Syntax
Explicit SDL Storage classes are COMMON and GLOBAL. To maintain orthogonal syntax,
TYPEDEF is permitted wherever COMMON and GLOBAL are permitted.
The Storage class definition in SDL is included as an option on an ITEM or AGGREGATE
declaration. This means that an AGGREGATE TYPEDEF for the preceding example would
be:
AGGREGATE MyStruct STRUCTURE TYPEDEF PREFIX jg$ ;
i1 LONGWORD ;
i2 LONGWORD ;
END ;

3.2.2.6 Data Types
In most cases it is possible to refer to a user-defined Data Type where a standard built-in SDL
Data Type (BYTE, LONGWORD etc.) can be referenced.
Reference to the type MyStruct defined in the preceding example is made as follows:
ITEM foo MyStruct ;
3.2.2.7 DIMENSION Keyword
You can apply a dimension to AGGREGATE (as well as members of aggregates and subaggregates)
and ITEM declarations, which means that you can define an array of structures, a
structure that contains one or more arrays, or an array of structures each of which contains
one or more arrays. The DIMENSION option is valid when specified with any of the data
types described in Section 3.2.3 and has the following syntax:
DIMENSION [lbound:]hbound
lbound
Is any valid OpenSDL expression giving the value of the lowest-numbered element of the array.
If lbound is not specified, OpenSDL supplies a default lbound of 1.
hbound
Is any valid OpenSDL expression giving the number of elements in the array, or, if lbound is
specified, the highest-numbered element.
The following is an example of the DIMENSION option specified on an AGGREGATE declaration:
AGGREGATE array_info STRUCTURE;
bound STRUCTURE DIMENSION 8;
lower LONGWORD;
upper LONGWORD;
multiplier LONGWORD;
constant_lower BITFIELD LENGTH 1;
constant_upper BITFIELD LENGTH 1;
constant_multiplier BITFIELD LENGTH 1;
reserved BITFIELD LENGTH 13;
END bound;
END array_info;
The subaggregate bound has eight elements. Each element consists of the members upper,
lower, multiplier, and so on. Because bound is an array, each of its members (upper,
lower, multiplier, and so on) can also be considered an array of eight elements.
When you specify a single value after the DIMENSION keyword, as in the previous example,
the specified back end assumes that the value represents the high bound value and supplies a
default low bound value of one. You can override this default by specifying both a low bound
and a high bound value as follows:
ITEM node_pointers DIMENSION 0:255 ADDRESS;
This declaration results in a declaration of the array node_pointers, whose low bound is 0
and whose high bound is 255. Only one dimension can be specified for an AGGREGATE or
ITEM declaration. This restriction ensures that there is no interlanguage conflict in an array
declaration.

You can see how OpenSDL translates the DIMENSION option for each output language by
processing the OpenSDL source file EXAMPLE.SDL in SDL$EXAMPLES.
3.2.3 Data Type Keywords
Data type keywords specify the data types of scalar objects, which can be declared as members
of aggregates or as individual items. Data type keywords are also used to describe the data
types of parameters, as well as the return value of an ENTRY. They can also be used in
an AGGREGATE declaration to generate an implicit union. The data type declaration also
specifies, either implicitly or explicitly, the size of a member.
The following sections describe the data types and the keywords you use to specify them.
3.2.3.1 Pointer Data Types
The keywords ADDRESS, POINTER, POINTER_LONG, POINTER_QUAD, POINTER_HW,
and HARDWARE_ADDRESS specify a data type that is an address, or pointer. The ADDRESS
data type has the following syntax:
pointer-type [ (object-type [ basealign-attribute ] ) ]
pointer-type
is one of the keywords ADDRESS, POINTER, POINTER_LONG, POINTER_QUAD,
POINTER_HW, and HARDWARE_ADDRESS.
ADDRESS, POINTER, POINTER_LONG are 4-byte-addresses.
POINTER_HW and HARDWARE_ADDRESS are 4-byte-addresses if /VAX us specified and
8-byte-addresses if /ALPHA is specified.
POINTER_QUAD is an 8-byte-address.
object-type
is the optional data type of the object to which the address refers. This construct is ignored for
languages in which pointers are distinct data types. Object-type is either a builtin object type,
like LONGWORD or ANY, or a user-defined object type, optionally followed by a DIMENSION
specification, or an ENTRY declaration.
basealign-attribute
Here, a BASEALIGN attribute can be specified, as desribed in Section 3.2.2.3.
The following is an example of an aggregate with a member of pointer type:
AGGREGATE any_node STRUCTURE;
flink ADDRESS (any_node);
blink ADDRESS (any_node);
END;

3.2.3.2 ANY Data Type
The ANY keyword specifies that the parameter being described in an ENTRY declaration can
be of any data type. The ANY data type can be used only within the context of a parameter
description and has the following syntax:
ANY
ANY
Specifies that the parameter can be of any data type.
The following is an example of the use of the ANY data type:
ENTRY sys$abc PARAMETER (ANY);
3.2.3.3 BITFIELD Data Type
The BITFIELD keyword specifies a bit field variable that must be a member of an
AGGREGATE declaration. The BITFIELD data type has the following syntax:
BITFIELD [LENGTH n] [MASK] [SIGNED]
[LENGTH n]
Is any valid OpenSDL expression giving the number of bits in the bitfield. If no length is
specified, OpenSDL uses a default length of 1 bit.
[MASK]
Is a keyword specifying that OpenSDL generate both a bitfield variable and a constant bit mask
representing the bits defined in this field.
[SIGNED]
Is a keyword specifying that OpenSDL treat the output as a signed field.
Bitfields must be AGGREGATE declaration members. They cannot be scalar items, objects of
ADDRESS declarations, parameters, or return data types of entries.
The following is an example of the BITFIELD keyword used in an AGGREGATE declaration
that specifies a structure with two bitfield members:
AGGREGATE flags STRUCTURE PREFIX tst$;
resolved BITFIELD MASK SIGNED;
spare_bits BITFIELD LENGTH 5;
END;
The declaration of resolved in the previous example results in two declarations in the output
file: a declaration for the bitfield itself and a declaration of a constant mask whose value is
1. Because the PREFIX option is specified for this aggregate, the source output file identifiers
produced for this declaration are tst$v_resolved and tst$m_resolved, where the tag v_
indicates the bitfield variable and the tag m_ indicates the mask. Prefixes and tags are
described in more detail in Section 3.2.2.2.

3.2.3.4 BOOLEAN Data Type
The BOOLEAN keyword specifies a Boolean data type that is a one-byte field that can have
one of two values, 0 or 1. The BOOLEAN data type has the following syntax:
BOOLEAN
BOOLEAN
Produces a Boolean variable in the output file.
The following is an example of the BOOLEAN keyword used in an ITEM declaration:
ITEM true BOOLEAN;
3.2.3.5 CHARACTER Data Type
The CHARACTER keyword declares a character string of a given length. The CHARACTER
data type has the following syntax:
CHARACTER [LENGTH {n}] [VARYING]
[ {*}]
[LENGTH n]
Is the length of the character string. The length can be specified using any valid OpenSDL
expression. If no length is specified, OpenSDL uses a default length of 1 character. You can
specify a character string of unknown length using LENGTH *. An unknown length character
string can be specified only for parameter types. For example:
ENTRY LIB$ROUTINE PARAMETER(CHARACTER LENGTH * NAMED foo);
[VARYING]
Is a keyword indicating that the identifier represents a varying-length character string (for
languages that support this data type). In a varying-length character string, the first word of
the string contains its current length; its declared length is the maximum length that it can
have.
The following is an example of the CHARACTER data type used in an AGGREGATE declaration.
The aggregate msg_buffer contains a character-string member named message_text
with a length of 256 characters.
AGGREGATE msg_buffer STRUCTURE;
message_text CHARACTER LENGTH 256 VARYING;
severity WORD;
END;
3.2.3.6 COMPLEX Data Types
The COMPLEX keyword immediately follows any of the four floating-point data type keywords
to specify any of the four COMPLEX data types. The COMPLEX data types have the following
syntax:
F_FLOATING COMPLEX
D_FLOATING COMPLEX
G_FLOATING COMPLEX
H_FLOATING COMPLEX

The following is an example of the F_FLOATING COMPLEX data type used in an ITEM
declaration:
ITEM foo F_FLOATING COMPLEX;
Section 3.2.3.8 describes floating-point data types.
3.2.3.7 DECIMAL Data Type
The DECIMAL keyword specifies a packed decimal data type and the size of the data type.
The DECIMAL data type has the following syntax:
DECIMAL PRECISION (precision,scale)
PRECISION (precision,scale)
Is the fixed-point decimal member’s precision and scale, respectively. Precision is the total
number of decimal digits, and scale is the number of fractional digits.
Both precision and scale must be specified using valid OpenSDL expressions.
The following is an example of the DECIMAL keyword used in an ITEM declaration that
indicates a packed decimal data type consisting of three decimal digits, two of which are
fractional:
ITEM percentage DECIMAL PRECISION (3,2);
3.2.3.8 Floating-Point Data Types
The floating-point keywords, F_FLOATING, D_FLOATING, G_FLOATING, and H_
FLOATING, declare storage units for single-, double-, G-, and H-floating-point data, respectively.
The floating-point data types have the following syntax:
F_FLOATING
D_FLOATING
G_FLOATING
H_FLOATING
The following is an example of the D_FLOATING data type used in an ITEM declaration:
ITEM foo D_FLOATING;
Section 3.2.3.6 describes COMPLEX data types.
3.2.3.9 Integer Data Types
The keywords BYTE, WORD, LONGWORD, QUADWORD, and OCTAWORD declare storage
units of 8, 16, 32, 64, and 128 bits, respectively, to represent signed integer data.
You may also specify the keyword UNSIGNED with any of these data types to indicate
unsigned integer data.
It is also possible to specify the keyword SIGNED.

The keywords INTEGER_BYTE, INTEGER_WORD, INTEGER_LONG and INTEGER_QUAD
are synonyms for BYTE, WORD, LONGWORD, QUADWORD, respectively, although some
back ends treat INTEGER_QUAD and QUADWORD different (C, FORTRAN and PL/I). The
keyword INTEGER is also synonym for LONGWORD and INTEGER_LONG.
The keywords INTEGER_HW and HARDWARE_INTEGER describe integer data types whose
size depends on the underlying hardware. If the qualifier /VAX is specified, they are 4 bytes
wide, and if /ALPHA is specified, they are 8 bytes wide.
The integer data types have the following syntax:
BYTE [ UNSIGNED | SIGNED ]
INTEGER_BYTE [ UNSIGNED | SIGNED ]
WORD [ UNSIGNED | SIGNED ]
INTEGER_WORD [ UNSIGNED | SIGNED ]
LONGWORD [ UNSIGNED | SIGNED ]
INTEGER_LONG [ UNSIGNED | SIGNED ]
INTEGER [ UNSIGNED | SIGNED ]
QUADWORD [ UNSIGNED | SIGNED ]
INTEGER_QUAD [ UNSIGNED | SIGNED ]
OCTAWORD [ UNSIGNED | SIGNED ]
INTEGER_HW [ UNSIGNED | SIGNED ]
HARDWARE_INTEGER [ UNSIGNED | SIGNED ]
The following are examples of the LONGWORD and BYTE data types used in an ITEM
declaration:
ITEM foo LONGWORD UNSIGNED;
ITEM bar BYTE;
3.3 Expressions
A OpenSDL expression evaluates to an arithmetic value and can consist of any of the following
syntax elements:
• Numeric values are, by default, expressed in decimal notation. You can override this
default by preceding a constant with one of the prefixes in the following table.
Prefix Interpretation Valid Characters
%X Hexadecimal 0 - 9, A - F
%O Octal 0 - 7
%B Binary 0 and 1
%A1 ASCII value Any ASCII character (see Appendix C)
1The %A operator takes the ASCII value of any ASCII character that follows it.
OpenSDL treats decimal constants as signed integer longword values.

You can also use a string of up to four characters as a numeric constant by enclosing the
string in quotation marks (" "). OpenSDL inserts the ASCII value of each character into the
byte field corresponding to that character’s position in the string. If the string you specify
has fewer than four characters, OpenSDL pads the string with the null character, which has
the ASCII code of zero.
• Local symbols and output constants are assigned integer longword values that are
available within the context (that is, during processing) of the input file.
• Operators perform arithmetic and logical operations on numeric values, local symbols,
and output constants. The following table lists the operators in order of precedence, with
the operators of higher precedence listed first.
Operator Meaning
unary - Arithmetic negation
* Arithmetic multiplication
/ Arithmetic division
+ Arithmetic addition
- Arithmetic subtraction
@ Logical shift–x@y shifts the value of x to the left y places; if y is negative, the value
of x is shifted y places to the right
& Logical AND
! Logical OR
• Offset symbols are used in expressions specified in AGGREGATE declarations:
— The period (.) represents the current byte offset fromthe origininanAGGREGATE
declaration. If the ORIGIN option is specified, the value of the period is equal to the
byte offset from the member specified using the ORIGIN option.
— The colon (:) represents the current byte offset relative to the firstmember in an
AGGREGATE declaration. The value is not affected by the presence of an ORIGIN
option.
— The circumflex (^) represents the current bit offset relative to themost recently
declared aggregate or byte-aligned element.
Section 4.5.8 describes the use of offset symbols in AGGREGATE declarations in more
detail.
• Parentheses group expressions to define the order of evaluation. Expressions within the
innermost set of parentheses are evaluated first.
The following is an example of an expression used in a CONSTANT declaration, which appears
in the context of an AGGREGATE declaration:
CONSTANT foo EQUALS %Ag + 72 / (#abc * boo + .);

3.4 Local Comments
A comment that is local to the OpenSDL source file is not written to the output file. Local
comments begin with the left brace ({) and extend to the end of the line. They can appear
anywhere within the source file (not necessarily within a module) where white space (a space,
tab, or carriage return) is allowed. The following is an example of a local comment:
{Assigning the value 255 to #max_args.
3.5 Output Comments
Comments appearing on lines by themselves are typically written to the output file as separate
comment lines. Comments appearing at the end of a line are output at the end of the
corresponding target source line, if possible.
Output comments begin with a slash and an asterisk (/*) and terminate at the end of the
current line. They can appear in the following contexts:
• OutsideMODULEdeclarations
• Attheendofalinecontainingadeclaration,thatis,followingthesemicolonterminator(;)
• Onlinesbythemselvesbetweenmember,CONSTANT,ENTRY,ITEM,andAGGREGATE
declarations
• Betweendeclarationswithinanaggregate
• Followingindividualconstantnameswithinacomma-delimitedlistofCONSTANTdeclarations
The following is an example of an output comment:
/* Get Job/Process Information System Service.
3.6 INCLUDE Statement
The INCLUDE statement specifies that the contents of an external file are to be incorporated
in the OpenSDL input file directly following the INCLUDE statement. The INCLUDE
statement has the following syntax:
INCLUDE "file-spec";
"file-spec"
Is any valid VMS file specification enclosed in quotation marks (" "). An INCLUDE statement
cannot appear embedded within an AGGREGATE declaration, but can appear anywhere else
within the module. If a directory is not included in the file specification, the current default
directory is used.
When OpenSDL encounters an INCLUDE statement, it stops reading from the current file
and reads the statements in the included file. When it reaches the end of the included file,
OpenSDL resumes translation with the source statement immediately following the INCLUDE
statement.

3.7 READ Statement
The READ statement allows a .SDI intermediate file to be included in an SDL source, without
causing it to be emitted to the output stream. Apart from these two differences, its operation
is similar to INCLUDE.
The READ statement allows previously-compiled definitions, such as constants and userdefined
types, to be used by the current compilation, without affecting the language output.
The READ statement has the following syntax:
READ "file-spec" ;
3.8 Conditional SDL Compilation
3.8.1 Conditional SDL Compilation using the IFLANGUAGE statement
This feature allows a section of SDL source code to be conditionally compiled, depending on
whether output is being generated for a particular language or not.
The syntax for conditional compilation has the format:
IFLANGUAGE language-name [ language-name ... ]
.
.
.
[ELSE ;
.
.
.
]
END_IFLANGUAGE [ language-name [ language-name ... ] ] ;
Note the following:
• Thethreekeywordsmayappearwhereverastatementisvalid.
• Conditionalcompilationstatementsmaynotbenested.
• Thelistoflanguage-namesontheEND_IFLANGUAGEisoptional,butifitisincluded,it
must match the list on the IFLANGUAGE statement. The languages need not necessarily
appear in the same order.
• Languagenamesmaynotbeabbreviated.
• Thevalidityoflanguagenamesisnotchecked. Thisisinkeepingwiththephilosophyof
SDL that new back ends may be added without changes to the front end.
• AcommentonthesamelineastheIF_LANGUAGEstatementisonlyoutputforlanguages
which satisfy the condition. A comment on the same line as the END_IFLANGUAGE
statement is always output, as this is considered to be outside the body of the conditional.
In the following example, SDL generates a translation of the ITEM statement if output is
being generated for Pascal, Ada, or FORTRAN. For other languages, SDL does not generate a
translation of the ITEM statement.

IFLANGUAGE PASCAL ADA FORTRAN ;
ITEM foo LONGWORD;
END_IFLANGUAGE PASCAL ADA FORTRAN;
3.8.2 Conditional SDL Compilation using the IFSYMBOL statement
This feature allows a section of SDL source code to be conditionally compiled, depending on
symbols specified with the command line qualifier /SYMBOLS.
The syntax for conditional compilation has the format:
IFSYMBOL symbol-name ;
.
.
.
{ ELSE_IFSYMBOL symbol-name ;
.
.
.
}
[ELSE ;
.
.
.
]
END_IFSYMBOL ;
Note the following:
• Thefourkeywordsmayappearwhereverastatementisvalid.
• Conditionalcompilationstatementsmaynotbenested.
• AcommentonthesamelineastheIFSYMBOLstatementisonlyoutputifthissymbol
is specified on the command line. A comment on the same line as the END_IFSYMBOL
statement is always output, as this is considered to be outside the body of the conditional.
With the following example:
IFSYMBOL s1;
<sdl code 1>
END_IFSYMBOL;
IFSYMBOL s2;
<sdl code 2>
ELSE_IFSYMBOL s3;
<sdl code 3>
ELSE;
<sdl code 4>
END_IFSYMBOL;
$ SDL/LANG=<LANGUAGE>/SYMBOLS=(S1=0,S2=0,S3=0) <FILE-SPEC>
produces
<sdl code 4>

$ SDL/LANG=<LANGUAGE>/SYMBOLS=(S1=1,S2=0,S3=0) <FILE-SPEC>
produces
<sdl code 1>
<sdl code 4>
$ SDL/LANG=<LANGUAGE>/SYMBOLS=(S1=1,S2=1,S3=x) <FILE-SPEC>
produces
<sdl code 1>
<sdl code 2>
$ SDL/LANG=<LANGUAGE>/SYMBOLS=(S1=1,S2=0,S3=1) <FILE-SPEC>
produces
<sdl code 1>
<sdl code 3>
3.9 Text Pass-through
Text pass-through allows literal text to be passed through to the output language file without
translation. It is normally used in conjunction with conditional compilation for a specific target
language. The purpose is to allow language-specific constructs, which cannot be represented
in SDL, to be emitted.
The syntax for text pass-through is:
LITERAL;
Any number of lines to be passed directly to
the output stream without translation
END_LITERAL;
Note the following:
• ThekeywordsLITERALandEND_LITERALmayappearwhereverastatementisvalid.
• ThekeywordEND_LITERALterminatesaliteralconstruct,andthereforecannotbe
included in a line of literal text. Any text preceding END_LITERAL on the same line is
output as a line of literal text.
Literal text is processed identically in all back ends. The literal text is merely written directly
to the output file.
The following is an example of text pass-through for the C language.
IFLANGUAGE CC
LITERAL
#define ctext "This appears in C language output only"
END_LITERAL
END_IFLANGUAGE CC

3.10 DECLARE Statement
The DECLARE statement allows you to declare a data item of a type that you define, which
may be unknown in the current SDL compilation. When you use DECLARE, the type is made
known when the target language source is compiled.
The DECLARE statement uses the SIZEOF clause to allow you to specify the size of the userdefined
data type being declared. The parameter you specify in the SIZEOF clause may be
a built-in SDL data type, a user-defined type defined in the current SDL compilation, or an
expression.
The DECLARE statement has the following syntax:
DECLARE user-type SIZEOF { data-type } [ PREFIX prefix-string ]
{ user-type } [ TAG tag-string ]
{ ( expression ) }
user-type
Represents the unknown data type name you wish to declare.
SIZEOF
A clause that must be appended to user-type. The SIZEOF clausemay be specified in several
ways, as shown, to indicate the size of the user-defined type being declared.
data-type
Represents either a built-in SDL data type, a user-defined type that is known at SDL compile
time, or a data type that has been sized by a previous SIZEOF clause.
user-type
Represents a user-defined data type.
( expression )
Represents an expression. If specified, the expression must specify the number of bytes to be
reserved for this data type. If the data type is dimensioned, the SIZEOF clause must specify
the size of a single element. When you specify an expression, always enclose it in parentheses,
as shown in this syntax.
Notes:
1. DECLARE identifies the size of the data type when included in an AGGREGATE declaration.
(SDL needs to know its equivalent predefined type so that the correct default tag
letter, if required, can be output.)
2. You may declare a user-defined data type more than once (either explicitly or implicitly),
but any subsequent declaration must match the first.
3. The default tag letter for the unknown variable being sized is derived from the type
specified in the SIZEOF clause. If you use an expression in place of a data type to reserve
a fixed number of bytes, the default tag letter is T. You may override the default tag by
using an explicit TAG option.
4. SIZEOF clauses cannot be nested.
5. You cannot qualify a reference to the name of a previously-declared aggregate using the
SIZEOF clause.

6. Although DECLARE statements and implicit SIZEOF declarations appear in the output
tree for use by the back ends, these do not result in specific generated code.
7. Do not use the SIZEOF clause for data types that are aggregate names. Also, do not nest
SIZEOF clauses where the syntax would otherwise allow aggregate names. For example,
the following statements are valid:
DECLARE type SIZEOF ADDRESS (CHARACTER);
ITEM type ADDRESS (bar SIZEOF LONGWORD);
However, the following statement generates an error message:
DECLARE type SIZEOF ADDRESS (bar SIZEOF LONGWORD);
Examples
A database contains information on a number of forests in a region, each of which contains
a number of different types of trees. The definition of the tree structure is held in a different
SDL file from the other definitions. When the second SDL file is compiled, the composition of
the tree structure is unknown — the definitions will only come together when the output files
are included in a compilation in the target language.
The following shows the two SDL files and the corresponding output in C.
TREE1.SDL:
AGGREGATE tree STRUCTURE TYPEDEF;
flink ADDRESS (tree);
blink ADDRESS (tree);
height LONGWORD;
age LONGWORD;
END;
TREE2.SDL:
DECLARE tree SIZEOF (16);
AGGREGATE forest STRUCTURE TYPEDEF;
oak tree;
ash tree;
elm tree;
confirs tree DIMENSION 6;
END;
ITEM tree_pointer ADDRESS (tree);
ITEM tree_storage tree DIMENSION 1000;
ITEM region forest DIMENSION 4; { No SIZEOF, since ’forest’ defined here}
TREE1.H:
typedef struct _tree {
_tree *flink;
_tree *blink;
long int height;
long int age;
} tree;
3–26 OpenSDL Language Elements
TREE2.H:
typedef struct _forest {
tree oak;
tree ash;
tree elm;
tree conifers[6];
} forest;
tree *tree_pointer;
tree tree_storage[1000];
forest region[4];
Note that the SIZEOF information is discarded by C, but is used by other languages, such as
MACRO.

@chapter 4
OpenSDL Declarations
This chapter describes the function and format of each of the following OpenSDL declarations:
• MODULEdeclaration
• ITEMdeclaration
• AGGREGATEandsubaggregatedeclarations
• CONSTANTdeclaration
• ENTRYdeclaration
OpenSDL declarations are composed of the language elements described in Chapter 3. The
output generated by each OpenSDL declaration depends on which back end is used for the
translation.
Online examples of output files for each language are available by processing the OpenSDL
source file EXAMPLE.SDL in SDL$EXAMPLES. Appendix B provides translation summaries
for each output language.

MODULE Declaration
MODULE Declaration
The following sections describe the function and format of a MODULE declaration.
4.1 MODULE Description
A MODULE declaration groups all related symbols and data structures. All declarations
(other than local symbol assignments and local and output comments) must occur within a
module, which is delimited by the MODULE and END_MODULE keywords. A OpenSDL source
file may contain multiple MODULE declarations, but modules may not be nested.
You must specify a module name on the MODULE declaration; this name corresponds to the
name of a macro or module in a given output language. (Section 3.1 describes the syntax for
names.) For example:
MODULE $modef;
This declaration generates the beginning of the declaration for the macro or module named
$modef.
You can use the IDENT option on a MODULE declaration to pass a version number or other
information that must be enclosed in quotation marks (" ") to the output file. For example:
MODULE params IDENT "V2.0";
You can optionally specify the module name on the END_MODULE statement; this is particularly
useful if you place more than one MODULE declaration in the same OpenSDL source file.
The module name is case-sensitive and must match exactly (in case) the name specified on the
MODULE declaration.
4.2 MODULE Format
A MODULE declaration has the following syntax:
MODULE module-name [ IDENT "ident-string" ];
[ module-body ];
.
.
.
END_MODULE [ module-name ];
MODULE module-name
Specifies any valid OpenSDL identifier you want to use to identify the module.
[IDENT "ident-string"]
Specifies any valid OpenSDL identifier, or a string of any characters, that must be enclosed in
quotation marks (" ") and that either further identifies the module or is a version number.
[module-body]
Is one or more of the following:
• ITEMdeclaration
• AGGREGATEdeclaration

MODULE Declaration
• CONSTANTdeclaration
• ENTRYdeclaration
• Localsymbolassignment
• Localoroutputcomment
• INCLUDEstatement
• DECLAREstatement
• READstatement
• IFLANGUAGEconstruct
• IFSYMBOLconstruct
• LITERALconstruct
END_MODULE [module-name]
Marks the end of the MODULE declaration. The module-name, if specified, must match the
name on the most recently specified MODULE declaration.

ITEM Declaration
ITEM Declaration
The following sections describe the function and format of an ITEM declaration.
4.3 ITEM Description
An ITEM declaration defines scalar items and single-dimensional arrays of scalar items that
are not members of aggregates. You must specify an item name and data type on the ITEM
declaration. For example:
ITEM block_list_id WORD;
This declaration specifies the scalar item block_list_id of data type WORD.
4.4 ITEM Format
An ITEM declaration has the following syntax:
ITEM item-name { data-type } [ COMMON ]
{ user-type sizeopt } [ GLOBAL ]
[ TYPEDEF ]
[ BASEALIGN basealign-option ]
[ DIMENSION [ lbound: ] hbound ]
[ PREFIX prefix-string ]
[ TAG tag-string ];
ITEM item-name
Specifies any valid OpenSDL name used to identify the item.
data-type
Is any valid OpenSDL data type (see Section 3.2.3).
user_type sizeopt
Is a user-defined data type using the DECLARE statement’s SIZEOF clause, shown and
described in Section 3.10.
[COMMON]
[GLOBAL]
[TYPEDEF]
Is the storage class of the item, if other than the default (based) storage class (see
Section 3.2.2.4).
[BASEALIGN basealign-option ]
BASEALIGN specifies the alignment of an ITEM. basealign-option is either an integer expression
in parentheses or the name of a data type.
BASEALIGN aligns the item on a multiple of the value of the basealign-option.

ITEM Declaration
[DIMENSION [lbound:]hbound]
Specifies that the item is an array. If a single value is specified, that value indicates the
number of elements in the array. Otherwise, lbound and hbound represent lower and upper
bounds of the array, respectively (see Section 3.2.2.7).
[PREFIX prefix-string]
Specifies a user-defined prefix that becomes part of the identifier. It can be any valid OpenSDL
name with 0 to 32 characters, may or may not be enclosed in quotation marks (" "), and may
be null (see Section 3.2.2.2).
[TAG tag-string]
Specifies the user-defined tag that follows the prefix used in forming the identifier. It can
be any valid OpenSDL name with 0 to 32 alphabetic or numeric characters; the tag must be
enclosed in quotation marks (" ") if it begins with a numeric character (see Section 3.2.2.2).

AGGREGATE Declaration
AGGREGATE Declaration
The following sections describe the function and format of AGGREGATE and subaggregate
declarations.
4.5 AGGREGATE Description
An AGGREGATE declaration defines nonscalar items and dimensional arrays of nonscalar
items. An aggregate must contain at least one member declaration. The body of an aggregate
can also contain local symbol assignments, CONSTANT declarations, and subaggregate
declarations.
You must specify a valid aggregate name on the AGGREGATE declaration. For example:
AGGREGATE dcb STRUCTURE;
type CHARACTER;
size WORD;
next ADDRESS;
END dcb;
You must terminate an AGGREGATE declaration with the END statement. You can optionally
specify the aggregate name on the END statement. The aggregate name is case-sensitive and
must match exactly (in case) the name specified on the AGGREGATE declaration.
An aggregate that is the target of an ADDRESS declaration must have the default (BASED)
storage class.
4.5.1 Subaggregate Declaration
Subaggregates are declared using the keyword STRUCTURE or UNION. Within an aggregate,
subaggregates can be nested up to eight levels deep. For example:
AGGREGATE tree_node STRUCTURE;
opcode WORD;
lang_bits UNION;
pli_bits STRUCTURE;
resolved BITFIELD;
psv BITFIELD;
mark1 BITFIELD;
spare_bits BITFIELD LENGTH 5;
END pli_bits;
c_bits STRUCTURE;
value_variable_size BITFIELD;
psv BITFIELD;
expanded BITFIELD;
resolved BITFIELD;
reduced BITFIELD;
spare_bits BITFIELD LENGTH 3;
END c_bits;
END lang_bits;
END tree_node;
In this example, the structures pli_bits and c_bits are both subaggregates of the union lang_
bits. Because lang_bits is a union, c_bits and pli_bits occupy the same storage.
The COMMON, GLOBAL, BASED pointer-name, and ORIGIN options are invalid for a
subaggregate. All other AGGREGATE options are valid.

AGGREGATE Declaration
4.5.2 STRUCTURE Declaration
STRUCTURE declarations produce aggregate or subaggregate declarations that are structures.
The members are not overlaid; each member has a unique offset from the beginning of the
structure, which means that members occupy consecutive storage locations.
The following shows the syntax of a first-level STRUCTURE declaration:
AGGREGATE aggregate-name STRUCTURE [ options ];
The following shows the syntax of a STRUCTURE declaration as an aggregate member, that
is, a subaggregate STRUCTURE declaration:
member-name STRUCTURE [ options ];
4.5.3 UNION Declaration
UNION declarations produce aggregate or subaggregate declarations that are unions. The
first-level members are overlaid, which means that they occupy the same storage location.
Each first-level member begins at the beginning of the union and, thus, has an offset of zero.
A UNION declaration lets you represent the same storage location using different names and
different data types.
The following shows the syntax of a first-level UNION declaration:
AGGREGATE aggregate-name UNION [ options ];
The following shows the syntax of a UNION declaration as an aggregate member, that is, a
subaggregate UNION declaration:
member-name UNION [ options ]
4.5.4 Implicit Union Declarations
You may specify data types on an AGGREGATE declaration to cause the AGGREGATE
declaration to become an implicit union declaration. An implicit union declaration has these
features:
• GivesHPSDLtheabilitytodetectsubfieldoverflowwithouttheneedtodefineextraneous
STRUCTURE and UNION declaration names.
• Makesuser-definedfillfieldsunnecessary. Thisfeatureismostusefulfordatastructures
containing substructures that are required to begin at fixed offsets.
The following OpenSDL source code shows the syntax of an implicit union (structure B defines
the implicit union declaration):
AGGREGATE A STRUCTURE;
B STRUCTURE LONGWORD;
bit_string1 BITFIELD LENGTH 1;
bit_string2 BITFIELD LENGTH 4;
END B;
last_item WORD;
END A;

AGGREGATE Declaration
This implicit union declaration would be more cumbersome if represented as shown in the
following STRUCTURE subaggregate:
AGGREGATE A STRUCTURE;
X UNION ;
B LONGWORD;
Y STRUCTURE ;
bit_string1 BITFIELD LENGTH 1;
bit_string2 BITFIELD LENGTH 4;
END Y;
END X;
last_item WORD;
END A;
In the previous example, the names X and Y become OpenSDL generated ‘‘filler’’ names in the
implicit union case.
You do not have to define the union X and the structure Y if an implicit union declaration is
used. By giving the structure Y a type, OpenSDL creates a union of field Y with the specified
type overlaid with a structure containing the fields in Y. In some language translations, such
as BLISS and MACRO, the OpenSDL-generated union and structure (X and Y above)
can be suppressed in the output because they are considered extraneous fields. In other
languages, such as PL/I and C, it is necessary to use the OpenSDL-generated union
and structure to generate the correct offsets within a structure. Because the union is of the
length specified in the structure type, no filler is necessary to ensure that subsequent fields
(for example, last_item) are at the correct offset. If the fields of a structure extend past
the size specified, OpenSDL flags the overflow. The PL/I translation for the previous
implicit union declaration example is as follows:
DCL 1 A BASED ,
2 fill_0 union,
3 B fixed binary(31),
3 fill_1 ,
4 bit_string1 bit(1),
4 bit_string2 bit(4),
4 fill_1$$v_fill_2 bit(3),
2 last_item fixed binary(15);
The OpenSDL source file EXAMPLE.SDL in SDL$EXAMPLES shows an example of an implicit
union declaration.
4.5.5 Implicit Union Declarations with the Optional DIMENSION Keyword
The following is an example of a OpenSDL structure defined with a data type and the
DIMENSION keyword:
AGGREGATE fid STRUCTURE WORD DIMENSION 3;
first WORD;
second WORD;
third WORD;
END fid;
In the previous example, a single structure is overlaid by an array of elements of the type
specified by the structure type.

AGGREGATE Declaration
The fid structure is a three-word field that can be addressed as a single field or by each
individual word so that it is easily defined in OpenSDL as represented above. The following is
the PL/I translation for the OpenSDL source code in the previous example:
DCL 1 fill_0 union BASED ,
2 fid (1:3) fixed binary(15),
2 fill_1 ,
3 first fixed binary(15),
3 second fixed binary(15);
3 third fixed binary(15);
The implicit union declaration allows structures to grow without the need to modify any
trailing fillers. OpenSDL detects any overflow that may occur if the structure grows past the
size of its data type. The size of the aggregate (in bytes) is equal to the size of the data type
(in bytes) multiplied by the upper dimension (if any). If the size of the aggregate is greater
than the sum of the size of all its members, OpenSDL still translates the declaration. However,
if the size of the members exceeds the size of the aggregate, OpenSDL issues a message that
has the following format:
%SDL-E-TOOMANYFIELDS, Structure fill_0 has too many fields [Line ?]
In the previous example, fill_0 is the OpenSDL-generated name for the first union aggregate.
4.5.6 Forcing Negative Offsets
The default origin of an aggregate is the beginning of the first aggregate member. You may
specify the ORIGIN option on a level-1 AGGREGATE declaration to indicate that the origin
is located at the beginning of any aggregate member. The resulting declaration forces all
aggregate members declared before the specified origin to be located at negative offsets from
the origin. For example:
AGGREGATE nodes STRUCTURE ORIGIN qflink;
flink ADDRESS;
blink ADDRESS;
qflink ADDRESS;
qblink ADDRESS;
END;
This declaration defines the origin of the structure nodes to be at the member qflink, so
you may address flink and blink as negative offsets from qflink. Specifying an origin does
not change the values of the current bit and byte offset symbols (^ and :). These are always
calculated as being relative to the beginning of the aggregate.
4.5.7 Forcing Data Alignment
OpenSDL forces all AGGREGATE and subaggregate declarations to begin on byte boundaries.
Thus, if an aggregate or subaggregate ends with BITFIELD declarations that do not end
on byte boundaries, OpenSDL ensures that the next aggregate begins on a byte boundary by
supplying BITFIELD declarations as fillers, if necessary.
When OpenSDL adds BITFIELD declarations, it determines the length required and provides
a unique name of the form string$V_FILL_n. The string is the prefix supplied in
the AGGREGATE declaration, or the aggregate name if no prefix was supplied. Within an
aggregate, n begins at 0 and is incremented for each filler required.

AGGREGATE Declaration
The subaggregate declarations shown in the following example declare filler bitfields to
force byte alignment at the end of each subaggregate; this programming practice makes it
unnecessary for OpenSDL to perform the alignment.
AGGREGATE tree_node STRUCTURE;
opcode WORD;
lang_bits UNION;
pli_bits STRUCTURE;
resolved BITFIELD;
psv BITFIELD;
mark1 BITFIELD;
spare_bits BITFIELD LENGTH 5;
END pli_bits;
c_bits STRUCTURE;
value_variable_size BITFIELD;
psv BITFIELD;
expanded BITFIELD;
resolved BITFIELD;
reduced BITFIELD;
spare_bits BITFIELD LENGTH 3;
END c_bits;
END lang_bits;
END tree_node;
The current bit offset is set at 0 at the beginning of each aggregate and is incremented by the
bit lengths of each structure member in the aggregate at that level. In the following example,
OpenSDL forces the structure flags to be aligned on a byte boundary.
AGGREGATE dcb STRUCTURE PREFIX dcb$;
.
.
.
uflags STRUCTURE;
context BITFIELD LENGTH 3;
local BITFIELD;
END uflags;
flags STRUCTURE;
extern BITFIELD;
relo BITFIELD;
END flags;
The PL/I translation of the OpenSDL AGGREGATE declaration in the previous example
is as follows:
%replace dcb$s_dcb by 2;
dcl 1 dcb based,
2 dcb$r_uflags ,
3 dcb$v_context bit(3),
3 dcb$v_local bit(1),
3 dcb$v_fill_0 bit(4),
2 dcb$r_flags ,
3 dcb$v_extern bit(1),
3 dcb$v_relo bit(1),
3 dcb$v_fill_1 bit(6);
The bit offsets of the members of the structures in the previous OpenSDL example are shown
in the following table.

AGGREGATE Declaration
Member Bit Offset
dcb$v_context 0
dcb$v_local 3
dcb$v_fill_0 4
dcb$v_extern 0
dcb$v_relo 1
dcb$v_fill_1 2
4.5.8 Using Offset Symbols
The period (.) represents the current byte offset from the origin in an AGGREGATE declaration.
If the ORIGIN option is specified, the value of the period is equal to the byte offset from
the member specified using the ORIGIN option. The current byte offset is useful for capturing
the size of an aggregate or a portion of it. For example, in the declaration of a variable-length
data structure, you can capture the size of the fixed-length portion.
The colon (:) represents the current byte offset relative to the first member in an
AGGREGATE declaration. The value is not affected by the presence of an ORIGIN option.
The circumflex (^) represents the current bit offset relative to the most recently declared
aggregate or byte-aligned element.
The following example shows the use of the byte offset symbols.
AGGREGATE operator STRUCTURE PREFIX opr_;
flink ADDRESS;
blink ADDRESS;
opcount WORD;
optype CHARACTER LENGTH 1;
id WORD;
flags STRUCTURE;
is_constant_size BITFIELD LENGTH 1;
is_terminator BITFIELD LENGTH 1;
context BITFIELD LENGTH 3;
filler BITFIELD LENGTH 8-^;
END;
#opsize = .;
operands LONGWORD DIMENSION(#max_args);
#instruction_size = :;
END;
CONSTANT node_size EQUALS #opsize / 2;
CONSTANT inst_size EQUALS #instruction_size;
In the previous example, the local symbol #opsize captures the byte offset following the fixedlength
portion of the structure operator. This value is subsequently used in the CONSTANT
declaration, which defines the size of the constant portion of the structure in words.
The flags structure is byte aligned by the field filler, which makes use of the current bit offset
symbol to compute the size of this field.
The CONSTANT inst_size defines the size of the entire structure.

AGGREGATE Declaration
4.6 AGGREGATE Format
An AGGREGATE declaration has the following syntax:
AGGREGATE aggregate-name { STRUCTURE } [ data-type ]
{ UNION }
[ COMMON ]
[ GLOBAL ]
[ TYPEDEF ]
[ BASED pointer-name ]
[ ALIGN ]
[ NOALIGN ]
[ BASEALIGN basealign-option ]
[ DIMENSION [ lbound: ] hbound ]
[ MARKER marker-string ]
[ PREFIX prefix-string ]
[ TAG tag-string ]
[ ORIGIN member-name ]
[ FILL ];
aggregate-body
.
.
.
END [ aggregate-name ];
AGGREGATE aggregate-name
Specifies any valid OpenSDL name used to identify the aggregate.
{STRUCTURE}
{UNION}
Is the type of aggregate (see Section 4.5).
[data-type]
If specified, causes the AGGREGATE declaration to become an implicit union declaration (see
Section 4.5).
[COMMON]
[GLOBAL]
[BASED pointer-name]
[TYPEDEF]
Is the storage class of the aggregate, if other than the default (BASED) (see Section 3.2.2.4). If
an aggregate is the object of an ADDRESS declaration, it must have either the default or the
BASED pointer-name storage class.
[ALIGN]
[NOALIGN]
[BASEALIGN basealign-option]
The ALIGN and NOALIGN keywords can be used to align (or de-align) the members of an
aggregate on their natural boundary. The BASEALIGN keyword ensures that the size of an
aggregate is a multiple of the given alignment. The BASEALIGN keyword therefore takes an

AGGREGATE Declaration
argument, which specifies the alignment, either an expression in parenthesis or the name of a
data type.
For example:
AGGREGATE MyStruct STRUCTURE ALIGN;
This aligns every member in the structure.
AGGREGATE MyStruct STRUCTURE NOALIGN;
No action will be taken to ensure that the members of the aggregate will be aligned.
AGGREGATE MyStruct STRUCTURE BASEALIGN (8);
The aggregate will be padded, so that in an array of elements of this aggregate, all elements
will have a size that is a multiple of the given alignment (256, 28).
Alignment attributes on aggregates can be partially overridden by specifying alignment
attributes on the members of the aggregate.
See also Section 3.2.2.3.
[DIMENSION [lbound:]hbound]
Specifies that the aggregate is an array. If a single value is specified, that value indicates the
number of elements in the array. Otherwise, lbound and hbound represent lower and upper
bounds of the array, respectively.
[MARKER marker-string]
Specifies the prefix used to form the aggregate name. It may be any valid OpenSDL name with
0 to 32 characters, may or may not be enclosed in quotation marks (" "), and may be null.
[PREFIX prefix-string]
Specifies the prefix used in forming the names of aggregate members. It may be any valid 
SDL name with 0 to 32 characters, may or may not be enclosed in quotation marks (" "), and
may be null (see Section 3.2.2.2).
[TAG tag-string]
Specifies the tag used to form the aggregate name. The tag is appended to the prefix, if a
prefix was specified. It can have 0 to 32 alphabetic or numeric characters; the tag must be
enclosed in quotation marks (" ") if it begins with a numeric character (see Section 3.2.2.2).
[ORIGIN member-name]
Specifies the name of a member of this aggregate that is to be used as the origin of the
aggregate.
Member declarations produce declarations of the members of an aggregate and have the
following syntax:

AGGREGATE Declaration
member-name { data-type } [ ALIGN ]
{ aggregate-name } [ NOALIGN ]
{ user-type sizeopt } [ BASEALIGN basealign-option ]
[ DIMENSION [ lbound: ] hbound ]
[ PREFIX prefix-string ]
[ TAG tag-string ]
[ FILL ];
member-name
Is any valid OpenSDL name used to identify the member.
{data-type}
Is any valid OpenSDL data type (see Section 3.2.3).
{aggregate-name}
Is the name of the previously declared aggregate to be used as a type name. The name must
be the full (OpenSDL-expanded) aggregate name, including the prefix and tag.
{user-type sizeopt}
Is a user-defined variable using the DECLARE statement’s SIZEOF clause, shown and described
in Section 3.10.
[ALIGN]
[NOALIGN]
[BASEALIGN basealign-option]
Alignment attributes on a structure can be overridden with alignment attributes on a member
declaration. For example:
StructMember1 LONGWORD SIGNED ALIGN;
This ensures that the member is aligned, even if it is within an aggregate that is not aligned.
StructMember1 LONGWORD SIGNED NOALIGN;
No action will be taken to ensure that this member will be aligned.
StructMember1 LONGWORD SIGNED BASEALIGN (4);
Here, StructMember1 will have an offset that is a multiple of 16 (24).
basealign-option can either be an expression in parentheses or the name of a data type.
See also Section 3.2.2.3.
[DIMENSION [lbound:]hbound]
Specifies that the member is an array. If a single value is specified, that value indicates the
number of elements in the array. Otherwise, lbound and hbound represent lower and upper
bounds of the array, respectively (see Section 3.2.2.7).

AGGREGATE Declaration
[PREFIX prefix-string]
Specifies the prefix used to form the member name. For subaggregates, the prefix is used
to form the names of subaggregate members. It may be any valid OpenSDL name with 0 to
32 characters, may or may not be enclosed in quotation marks (" "), and may be null (see
Section 3.2.2.2).
[TAG tag-string]
Specifies the tag used to form the member name. The tag is appended to the prefix, if a prefix
was specified. It can have 0 to 32 alphabetic or numeric characters; the tag must be enclosed
in quotation marks (" ") if it begins with a numeric character (see Section 3.2.2.2).
[FILL]
Indicates that the specified member or aggregate occurs only as a fill to force byte alignment
on the following member or aggregate, respectively. In some languages, filler member and
aggregate declarations do not appear in the output file.
aggregate-body
Is one or more of the following:
• Memberdeclaration
• Subaggregatedeclaration
• CONSTANTdeclaration
• Localsymbolassignment
END [ aggregate-name ]
Marks the end of the AGGREGATE or subaggregate declaration. The aggregate-name, if
specified, must match the name on the most recently specified AGGREGATE or subaggregate
declaration.

CONSTANT Declaration
CONSTANT Declaration
The following sections describe the function and format of a CONSTANT declaration.
4.7 CONSTANT Description
A CONSTANT declaration generates a list of one or more named constants in the output file.
You may specify a valid constant name or names and the constant values to be assigned to
them. For example:
CONSTANT block_node_size EQUALS 24;
CONSTANT Strcon EQUALS STRING "This is a string constant" PREFIX Jg$
The first declaration creates the named constant block_node_size and assigns it the value
24. The second declaration creates the named string constant Strcon and assigns it the
specified value.
The values of both declared constants (except string constants) and local symbols may be used
in OpenSDL expressions. However, there is an important difference between declared constants
and local symbols: declared constants are translated directly to the output file, whereas local
symbols are not passed directly to the output file. For example, you can define the local symbol
#block_size as follows:
#block_size = 24;
A subsequent CONSTANT declaration may refer to #block_size and use the value 24, as
follows:
CONSTANT block_node_size EQUALS #block_size;
CONSTANT declarations (except string constants) can also be specified in a comma-delimited
list, as follows:
CONSTANT
xyz EQUALS 10,
alpha EQUALS 0,
noname EQUALS 63;
To specify related constants with the same or incremental values, use a CONSTANT declaration
with the INCREMENT option. In this form, the EQUALS expression gives the value
to be assigned to the first named constant; values for subsequent constants are derived by
incrementing the first value by the specified increment and assigning the result to the next
name in the list. For example:
CONSTANT (
bits,
bytes,
words,
longs,
quads,
octas
) EQUALS 0 INCREMENT 1 PREFIX ctx$;

CONSTANT Declaration
When OpenSDL assigns incremental values, it loops until values are assigned to all the names
in a list. If there is no INCREMENT clause, the increment value is 0; thus, the same initial
value is assigned to all the names. If names are omitted from a comma-delimited list, 
SDL reserves the numbers that would be assigned to names in those positions. This lets you
reserve numeric values for later assignment of names. For example:
CONSTANT
(bad_block,bad_data,,,,
overlay,rewrite) EQUALS 0 INCREMENT 4;
In the previous example, OpenSDL assigns the values 0 and 4 to the names bad_block and
bad_data, reserves the values 8, 12, and 16, and assigns the values 20 and 24 to the names
overlay and rewrite.
The COUNTER option saves the last assigned value in a specified local symbol for subsequent
use. For example:
CONSTANT (pli,c,bliss,macro)
EQUALS 4 INCREMENT 4 PREFIX lang$
COUNTER #lang;
CONSTANT (basic,pascal,fortran)
EQUALS #lang + 4 INCREMENT 4 PREFIX lang$;
The following table shows the constant names produced by these two declarations.
Constant Name Value
lang$k_pli 4
lang$k_c 8
lang$k_bliss 12
lang$k_macro 16
lang$k_basic 20
lang$k_pascal 24
lang$k_fortran 28
You can comment individual declarations in a CONSTANT declaration list. For example:
CONSTANT(
pli, /* PL/I
c, /* C
macro /* MACRO-32
) EQUALS 4 INCREMENT 4 PREFIX lang$;
Defining Global Constants in MACRO
OpenSDL does not directly generate definitions for global symbols (constants), but instead
generates local constant definitions. The MACRO back end, however, generates all declarations
within macros so that they can be invoked with arguments that will produce global
definitions.

CONSTANT Declaration
OpenSDL also produces MACRO output declarations that can generate global definitions
when an invocation of the macro is assembled. In the following example, the OpenSDL module
$IODEF contains the following constant declarations:
CONSTANT (
nop,
unload,
loadmcode,
seek,
spacefile,
startmproc,
recal,
stop,
drvclr,
initialize) EQUALS 0 INCREMENT 1 PREFIX "io$";
The MACRO output generated by this declaration is a macro definition that must be
invoked as follows in order to result in global rather than local constant definitions:
$IODEF <= =>
This argument results in global constant definitions rather than local constant definitions. To
request that the locations of data fields be defined globally, add the argument <::> following <=
=>.
4.8 CONSTANT Format
A CONSTANT declaration has the following syntax:
CONSTANT constant-name constant-class
constant-class = { EQUALS expression numeric-options }
{ EQUALS STRING string string-options }
numeric-options = [ PREFIX prefix-string ]
[ TAG tag-string ]
[ COUNTER #local-name ]
[ TYPENAME type-name ] ;
string-options = [ PREFIX prefix-string ]
[ TAG tag-string ] ;
CONSTANT (constant-name,...) EQUALS expression
[ INCREMENT expression ]
[ PREFIX prefix-string ]
[ TAG tag-string ]
[ COUNTER #local-name ]
[ TYPENAME type-name ];
CONSTANT (constant-name,...) EQUALS expression,
.
.
.
;

CONSTANT Declaration
CONSTANT constant-name
Specifies any valid OpenSDL name used to identify the constant.
When more than one name is specified, separate the names with commas and enclose the list
in parentheses.
EQUALS expression
EQUALS STRING string
Specifies the value to be assigned to the constant.
[PREFIX prefix-string]
Specifies the prefix used to form the constant name. It may be any valid OpenSDL name with
0 to 32 characters, may or may not be enclosed in quotation marks (" "), and may be null (see
Section 3.2.2.2).
[TAG tag-string]
Specifies the tag used to form the constant name. The tag is appended to the prefix, if a prefix
was specified. It can have 0 to 32 alphabetic or numeric characters; the tag must be enclosed
in quotation marks (" ") if it begins with a numeric character (see Section 3.2.2.2).
[COUNTER #local-name]
Specifies the local symbol assigned to the last value that is assigned to a constant in the list.
[TYPENAME type-name]
Specifies a named data type that is not a OpenSDL data type.
(constant-name,...)
Is a list of valid names.
A constant-name in this list can be null, though the list itself cannot be null. If a member of
the list is null, the corresponding value is reserved.
If INCREMENT is not specified, all names are assigned the value specified in the EQUALS
expression.
[INCREMENT expression]
Specifies the value to be added to the EQUALS expression for each iteration of OpenSDL’s
generation of named CONSTANT declarations. It must be a valid OpenSDL integer expression.
OpenSDL assigns the value of the EQUALS expression to the first constant name; the value
of the INCREMENT expression is added to the EQUALS expression and assigned to the next
constant name.

ENTRY Declaration
ENTRY Declaration
The following sections describe the function and format of the ENTRY declaration.
4.9 ENTRY Description
An ENTRY declaration produces an external procedure or function declaration in the output
file. You must specify a valid entry name on the ENTRY declaration. You may also specify
any or all of the ENTRY declaration options described in Table 3–2 in Section 3.2.2 and shown
within the context of an ENTRY declaration in Section 4.10.
The following example shows the ENTRY declaration for the VMS system service SYS$GETJPI:
ENTRY SYS$GETJPI ALIAS $GETJPI PARAMETER (
LONGWORD UNSIGNED VALUE NAMED EFN DEFAULT 0 TYPENAME EFNUM,
LONGWORD UNSIGNED NAMED PIDADR IN OUT DEFAULT 0 TYPENAME PROCID,
CHARACTER DESCRIPTOR NAMED PRCNAM IN DEFAULT 0 TYPENAME PROCNAME,
ANY NAMED ITMLST IN TYPENAME ITEMLIST,
QUADWORD UNSIGNED NAMED IOSB OUT DEFAULT 0 TYPENAME IOSB,
ADDRESS(ENTRY) NAMED ASTADR DEFAULT 0 TYPENAME ASTADR,
LONGWORD UNSIGNED VALUE NAMED ASTPRM DEFAULT 0 TYPENAME USERPARM
) RETURNS LONGWORD TYPENAME CONDVALU;
4.10 ENTRY Format
An ENTRY declaration has the following syntax:
ENTRY entry-name [ ALIAS internal-name ]
[ PARAMETER (param-desc,...) ]
[ LINKAGE link-name ];
[ VARIABLE ]
[ RETURNS return-data-type [ NAMED param-name ] ]
[ TYPENAME type-name ];
ENTRY entry-name
Specifies any valid OpenSDL name used to name the external entry point.
[ALIAS internal-name]
Specifies an alternate internal name used to designate the entry point.
[PARAMETER (param-desc,...)]
Describes the parameters of the external entry, if any. Param-desc must be specified as
follows:
{ data-type } [ DESCRIPTOR ] [ IN ]
{ aggregate-name } [ RTL_STR_DESC ]
[ VALUE ] [ OUT ]
[ REFERENCE ]
[ NAMED param-name ]
[ DIMENSION expression ]
[ DEFAULT constant-value ]

ENTRY Declaration
[ TYPENAME type-name ]
[ OPTIONAL ]
[ LIST ]
{data-type}
Is any valid OpenSDL data type.
{aggregate-name}
Is the name of a previously declared aggregate that describes the data type of the parameter.
[DESCRIPTOR]
Indicates that the parameter is passed by descriptor.
[RTL_STR_DESC]
Indicates that the parameter can be passed by any of the classes of string descriptors. The
data type must be CHARACTER. For example:
ENTRY xyz PARAMETER ( CHARACTER RTL_STR_DESC );
[VALUE]
Indicates that the parameter is passed by immediate value.
[REFERENCE]
Indicates that the parameter is passed by reference. REFERENCE is the default.
[IN]
Indicates an input parameter. IN is the default.
[OUT]
Indicates an output parameter.
[NAMED param-name]
Specifies the parameter name.
[DIMENSION expression]
Is the number of elements of an array parameter.
If expression is an asterisk (*), the number of dimensions depends on the dimensions of the
actual parameter.
[DEFAULT constant-value]
Specifies a default value for a parameter. In languages supporting this option, the omission of
an actual parameter is allowed.
[TYPENAME type-name]
Specifies a named data type that is not a OpenSDL data type.

ENTRY Declaration
[OPTIONAL]
Specifies that the parameter may or may not appear in the sequence of (keyword) parameters
for a call using the entry point name. This is supported only in Ada, BASIC, 
BLISS, MACRO, and PL/I output.
[LIST]
Indicates that the routine may be called with one or more parameters of the type being
described. LIST may be specified only for the last parameter.
NOTE
All the PARAMETER options, if specified, must follow the data type or aggregatename
in the declaration.
[LINKAGE link-name]
Specifies (for MACRO only) that a special call macro (spelled ‘‘link-name’’) will be used in
the expansion of the entry macro.
[VARIABLE]
Indicates that not all parameters are described; that is, the entry point has a variable number
of parameters and not all corresponding arguments need be present in the argument list when
the entry point is invoked. See also the description of the LIST parameter option.
[RETURNS return-data-type [NAMED param-name]]
Specifies the data type and, optionally, the name of the parameter returned by the external
entry, if it is a function.
The VOID keyword cannot be used in a PARAMETER clause.
The syntax is:
return-data-type = { data-type }
{ user-type sizeopt }
{ VOID }
The argument user-type sizeopt specifies a user-defined type declared using the DECLARE
statement’s SIZEOF clause, shown and described in Section 3.10.
The return type VOID indicates that the procedure returns no value.
[TYPENAME type-name]
Specifies a named data type for the return value that is not a OpenSDL data type.

@appendix
OpenSDL Diagnostic Messages
This appendix summarizes the OpenSDL diagnostic messages. All messages indicating errors
in OpenSDL syntax specify the line number in the OpenSDL source file at which the error
occurred.
ABORT, Fatal internal error; unable to continue execution
Fatal: An internal error has occurred.
User Action: Please report the problem to HP.
ADROBJBAS, Address object object-name must have based storage class [Line n]
Error: An address item is pointing to an aggregate that is not based.
User Action: Change the storage class of the aggregate to BASED.
BADNODETYPE, internal node type is unknown for language language-name
Warning: A language backend has encountered a node type in the parsed SDL input that
reflects a SDL element which the language does not support. For example, OpenVMS
DCL does not support aggregates or entries, only constants.
User Action: Depending on your needs, ignore the warning or change the SDL input file.
BASEALIGN, Invalid expression with BASEALIGN option. Value must be in range 0 to 124.
basealign-parameter [Line n]
Error: The value for the /BASEALIGN qualifier is smaller than 0 or larger than 124.
User Action: Use a value in the range [0 ... 124].
BUGCHECK, Internal consistency failure [Line n] - please submit a bug report
Fatal: SDL has detected an internal error or inconsistency.
User Action: Please submit a bug report to Technical Languages and Environments
(TL&E).

DIMENSIONSTAR, DIMENSION * for MEMBER "member-name" has no known discriminant
[Line n]
Warning: The use of "DIMENSION *" within an aggregate is not allowed.
User Action: Use fixed values for "DIMENSION" within all aggregate.
DUPCONATT, Item item-name has duplicate or conflicting attributes [Line n]
Error: A declaration contains keywords that are not compatible.
User Action: Verify the syntax of the OpenSDL declaration, correct the declaration, and
invoke OpenSDL again.
ERREXIT, Error exit
Fatal: Previous errors prevent continuation.
User Action: Correct the errors and invoke OpenSDL again.
FILFORMUNSUPP, RMS file format error reading intermediate file.
Error: An intermediate file (.SDI) cannot be read due to wrong RMS attributes.
User Action: Make sure that the intermediate file is a sequential file, variable length,
maximum 510 bytes, longest 510 bytes, carriage return carriage control.
FIXUP, Temporary hardcoded list used to discriminate for MEMBER "member-name" [Line
n]
Informational: From the comment in the SDLADA backend:
This is informational, with the first line otherwise being identical to a warning, to aid
diagnosing problems where someone makes a copy of a construct on our hardcoded list
without changing SDL.
This message is issued together with the DIMENSIONSTAR diagnostic.
User Action: See DIMENSIONSTAR.
IDENTGTR31, SDL-generated identifier longer than 31 characters exceeds capacity of
language-name compiler [Line n]
Warning: The Pascal backend appends "$TYPE" to data types that contain "DEF". The
resulting name then can exceed 31 characters, the maximum length of Pascal type names
on OpenVMS.
User Action: Don’t use "DEF" in your type names and/or shorten your type names.
ILLFORWREF, Illegal forward reference for output language language [Line n]
Error: The specified output language does not allow forward referencing, or the language
does not allow forward referencing in this context.
User Action: Correct or remove the forward reference.

IMMGTR32, Cannot pass values larger than 32 bits by immediate mechanism [Line n]
Warning: Using VALUE is invalid for this parameter because its size is greater than that
of a longword. A reasonable translation was attempted, however.
User Action: Verify that the output file contains a satisfactory translation of the parameter
description in your OpenSDL source file.
INCDEFSTRUC, Incompletely defined structure—structure-name [Line n]
Error: A structure name has been referenced before the structure has been completely
defined.
User Action: Remove the reference and invoke OpenSDL again.
INFILOPN, Unable to open input file file-spec
Fatal: SDL cannot locate or open the SDL source file.
User Action: Verify that you correctly specified the name of the source file.
INFILSDI, File format error reading intermediate file file-spec. Possible versionmismatch
Error: An intermediate file (.SDI) could not be read.
User Action: Check the spelling of the file name, existence and protection of the file.
INTOVF, Integer overflow in expression [Line n]
Error: Evaluation of an SDL expression resulted in a value that does not fit in a longword.
User Action: Correct the expression.
INVALIGN, Illegal value for /ALIGNMENT qualifier in command line
Error: The value of the /ALIGNMENT qualifier is not a positive number.
User Action: Use a positive number as value for the /ALIGNMENT qualifier.
INVBITFLD, Invalid bitfield bitfield-name—bitfields must be aggregate members [Line n]
Error: Bit fields must be members of aggregates. They cannot be scalar items.
User Action: Incorporate the BITFIELD declaration in an aggregate.
INVDECL, Invalid DECLARE for type user-defined-name [Line n]
Error: A DECLARE statement refers to a user defined data type that is invalid.
User Action: Correct the DECLARE statement.
INVEXPR, Invalid expression—cannot be resolved to a constant as required, name-of-defineditem
[Line n]
Error: An non-constant expression has been used in a context which requires a constant
expression.
User Action: Use a constant expression.

INVFLDSIZ, Item item-name has bit field or offset length greater than 32 [Line n]
Error: SDL cannot generate bit fields larger than 32 bits or cannot generate the proper
bit mask.
User Action: Verify the BITFIELD declaration and correct it. If the BITFIELD declaration
occurs within an aggregate and you specify the MASK option, verify that the bit offset
of the start of the declaration plus the bit field size does not exceed 32 bits.
INVLISTOPT, Invalid use of LIST attribute—LIST may only appear on the last parameter.
entry-name [Line n]
Error: The LIST attribute appears on a parameter other than the last.
User Action: Remove the LIST attribute.
INVNAME, Item name is invalid
Error: The item name contains illegal characters or is specified in an illegal context.
User Action: Correct or relocate the item name.
INVOUT, Invalid attributes for output language language [Line n]
Error: An SDL construct or data type is invalid for the specified target language.
User Action: Determine whether you specified the data type or OpenSDL declaration
correctly, or whether you may be requesting language output that you do not require.
Either correct the declaration or reissue the SDL command so that the indicated language
output routine does not execute.
INVPARMTYP, Invalid parameter type for language language [Line n]
Error: A parameter specification is illegal for the specified language.
User Action: Modify the parameter specification and invoke OpenSDL again.
INVREQPARAM, Required parameter encountered after an optional parameter parametername
[Line n]
Error: Required parameters must not follow optional parameters.
User Action: Correct the error and invoke OpenSDL again.
INVSHRIMG, Shareable image not found specified-language
Error: SDL cannot find the image to support the specified language.
User Action: Verify that the language image is located in the appropriate area. 
SDL searches for the image in SYS$SHARE. Language support images are of the form
SDL$language.EXE, where language is an identifying character string for the language.
For example, the FORTRAN back end is SDL$FORTRAN.EXE, and the MACRO
back end is SDL$MACRO.EXE.

INVSYMDEF, Invalid symbol symbol-name specified in /SYMBOLS qualifier
Error: The value of the /SYMBOLS qualifier is not correct. The /SYMBOLS qualifier
expects a list of symbol definitions in the form symbol-name:value or symbol-name=value.
The error message indicates a missing comma, colon, or value.
User Action: Correct the syntax of the /SYMBOLS qualifier.
INVUNKLEN, Unknown length attribute valid only for parameter type [Line n]
Error: CHARACTER LENGTH * is only allowed in a parameter description. Specifying
an unknown length for an ITEM or AGGREGATE member is an error.
User Action: Remove the LENGTH specification or replace the "*" with a valid expression.
LANGDUP, Language name language-name appears more than once in list [Line n]
Warning: In an IFLANGUAGE or END_IFLANGUAGE statement, the name of a language
appears twice.
User Action: Remove the duplicate file name.
LANGMATCH, Language language-name does not appear in list of matching IF statement
[Line n]
Warning: The list of language specified after the END_IFLANGUAGE keyword does not
match the list of languages specified after the corresponding IFLANGUAGE keyword.
User Action: Correct the language list.
LANGMISS, Language language-name in list of matching IF statement missing from END
list [Line n]
Warning: In an END_IFLANGUAGE statement, one of the languages from the
IFLANGUAGE statement is missing.
User Action: Add the missing language to the END_IFLANGUAGE statement or remove
all languages from the END_IFLANGUAGE statement.
LISFILOPN, Unable to open listing file file-spec
Error: SDL cannot open the indicated listing file.
User Action: Verify that you have write access to the directory to which the OpenSDL
listing file is directed.
MASKTOOBIG, Cannot create correct mask value for bitfield-name [Line n]
Error: The MASK on a BITFIELD can only be used if the BITFIELD is part of a
STRUCTURE which is part of a UNION, together with an integer field large enough
to hold the mask.
User Action: Remove the MASK option, or add an integer field big enough so that it can
hold all values for the MASK.

MATCHEND, End name does not match declaration name name [Line n]
Warning: The name specified on the END_MODULE or END delimiter does not match
the most recent module name or aggregate name.
User Action: Verify that the spelling of the names specified on the END and END_
MODULE delimiters match. Check whether you have illegally nested MODULE declarations.
This is only a warning message, but it may indicate an error.
MULTDEFSYM, Multiply defined symbol—symbol-name [Line n]
Error: A structure contains a duplicate symbol name.
User Action: Remove the duplicate name and invoke OpenSDL again.
NAMTRUNC, Generated name too long - truncated to 64 characters name-to-be-truncated
Warning: The BLISSF backend appends various prefixes and suffixes to names. The
resulting name then can exceed 64 characters, the maximum length.
The DCL, TPU, and UIL backends limit the name of constants to 64.
User Action: Shorten your names.
NEGORIGIN, Aggregate aggregate-name has a negative origin - negative offset elements will
be ignored [Line n]
Informational: The ORIGIN attribute defines a member as origin which is not at the beginning
of the aggregate. This diagnostic will only be issued if the /VMS_DEVELOPMENT
qualifier is present.
User Action: Specify the first member of the aggregate as origin.
NOOFFSET, Base offset for mask value for bitfield-name [Line n] cannot be determined
Error: The MASK on a BITFIELD can only be used if the BITFIELD is part of a
STRUCTURE which is part of a UNION, together with an integer field large enough
to hold the mask.
User Action: Remove the MASK option, or make the integer field big enough so that it
can hold all values for the MASK.
NOOUTPUT, No language output produced
Warning: There were too many errors, or fatal errors, which prevented SDL from generating
any output files.
User Action: Correct the errors indicated by the accompanying messages.
NULLSTRUC, Null structure structure-name has no members [Line n]
Error: An AGGREGATE or subaggregate declaration did not have any members.
User Action: Verify that the AGGREGATE or subaggregate declaration is correctly
positioned in the file.

OFFSETEXPR, Offset or origin relative expression involves a forward or circular reference.
???-nod$t_name-??? [Line n]
Warning: The offset or origin cannot be calculated.
User Action: Correct the error and invoke OpenSDL again.
OUTFILOPN, Unable to open output file file-spec
Error: SDL cannot locate or open an SDL output file.
User Action: Verify that you correctly specified the name of the source file.
POSSCIRC, Possible circular definition for type ???-nod$t_naked-??? [Line n]
Informational: The definition for the type cannot be processed.
User Action: Correct the error and invoke OpenSDL again.
REVCHECK, Front-end / back-end version mismatch. Check installation.
Fatal: A language backend has a different version than the calling frontend.
User Action: Check your OpenSDL installation.
SIZENEST, Illegal nesting of SIZEOF clauses (Item item-name) [Line n]
Error: SIZEOF clauses cannot be nested.
User Action: Remove the nested SIZEOF clause.
SIZEQUAL, Item item-name, an aggregate, cannot be qualified by SIZEOF [Line n]
Error: The SIZEOF clause is not allowed in this context.
User Action: Remove the SIZEOF clause.
SIZEREDEF, Size or type of item item-name redefined [Line n]
Error: SDL has detected a redefinition of the size or data type of the specified item.
User Action: Remove the clause causing the redefinition.
STRINGCONST, String constant item-name used in arithmetic expression [Line n]
Error: A reference to a string constant is not allowed in the context of an arithmetic
expression.
User Action: Remove the string constant reference.
SYMALRDEF, Symbol symbol-name was already defined in command line
Error: The value of the /SYMBOLS qualifier contains a symbol name more than once.
User Action: Remove the duplicate name.

SYMNOTDEF, Symbol symbol-name was not defined in command line, value zero assumed
[Line n]
Warning: A symbol is used in an IFSYMBOL or ELSE_IFSYMBOL statement, that has
not been defined using the /SYMBOLS qualifier.
User Action: Define the symbol using the /SYMBOLS qualifier.
SYMTABOVR, Symbol table overflow
Fatal: SDL exceeded its symbol table space.
User Action: Reduce the size or complexity of the OpenSDL source file; if possible, separate
the file into several different files or modules.
SYNTAXERR, Syntax error [Line n]
Error: The SDL translator detected a syntax error. This message is accompanied by a
message indicating the type of error and tells you what type of token or keyword SDL
expected but did not find.
User Action: Determine the syntax error from the accompanying message and correct it.
TOKOVF, Token exceeds maximum size of maximum-token-length [Line n]
Error: A line in the OpenSDL source file is longer than the maximum length.
User Action: Shorten the offending line.
TOOMANYFIELDS, Structure structure-name has too many fields [Line n]
Error: The structure has too many fields.
User Action: Simplify the structure.
TYPNAM, Aggregate type name not supported [Line n]
Warning: An illegal aggregate name has been used.
User Action: Choose another aggregate name.
TYPNOTSUP, Output language does not support data type data-type-name [Line n].
Warning: The specified data type is not supported by the output language. A reasonable
translation was attempted, however.
User Action: Verify that the output file contains a satisfactory translation of the data
type you specified in your OpenSDL source file.
UNALIGNED, member-name does not align on its natural boundary [Line n]
Warning: A member does not fall on its natural alignment (if /CHECK_ALIGNMENT
is present on the command line) or on the alignment specified with the /ALIGNMENT
qualifier.
User Action: Check the layout of the aggregate in question.

UNDEFCON, Undefined constant name constant-name used in expression [Line n]
Error: In the definition of a CONSTANT, an undefined name has been used.
User Action: Verify the spelling of the name.
UNDEFFIL, Unable to open include file file-name [Line n]
Error: A file to be INCLUDEd could not be opened.
User Action: Check the spelling of the file name, existence and protection of the file.
UNDEFORG, Definition of ORIGIN name member-name not found in aggregate [Line n]
Error: The member used as argument to the ORIGIN attribute was not found within the
aggregate.
User Action: Verify the spelling of the member name.
UNDEFSYM, Undefined local symbol symbol-name used in expression [Line n]
Error: A name preceded by a pound sign (#) is not defined.
User Action: Verify that the local symbol name is spelled correctly and that it appears
before its reference in the OpenSDL source file.
UNDEFUSER, Undefined user type name type-name referenced [Line n]
Error: A DECLARE statement refers to a data type that is neither a builtin nor a known
user defined data type.
User Action: Check the spelling of the data type referenced.
WARNEXIT, Warning exit
Warning: A warning message has been issued.
User Action: Output can be compiled, but the results may be unexpected.
ZERODIV, Zero divide in expression [Line n]
Error: An expression specified in an SDL declaration resulted in a divide-by-zero exception
condition.
User Action: Verify the expression and correct it.
ZEROLEN, Item item-name has 0 or negative length [Line n]
Warning: A BITFIELD or CHARACTER declaration or a DIMENSION option specified a
length of 0 or less.
User Action: Correct the declaration. If the length or bound value was specified using a
OpenSDL expression, verify the local symbol values and the results of arithmetic operations
in the expression, if any.

@appendix
OpenSDL Language Translation Summaries
This appendix shows the translation summaries of OpenSDL language elements to their
corresponding output in each of the following supported languages:
• Ada
• BASIC
• BLISS
• C
• DATATRIEVE
• OpenVMSDCL
• FORTRAN
• MACRO
• Pascal
• PL/I
• SDML
• DECTPU
• UIL

Ada Translation Summary
Ada Translation Summary
The following table shows the OpenSDL to Ada language translation summary.
OpenSDL Declaration Ada Output
MODULE name IDENT string - - module name IDENT string
/* comment - - comment
CONSTANT x
EQUALS n; x : constant := n ;
EQUALS STRING "s"; x : constant STRING := "s";
ENTRY name procedure name
(parameter-list ...);
pragma INTERFACE (EXTERNAL, name);
pragma IMPORT_VALUED_PROCEDURE
(name,"name",)
(type,...),
(passing-mechanism,...);
PARAMETER (type,...) parameter-name : type;
.
.
.
ANY UNSIGNED_LONGWORD ;
DESCRIPTOR Generates the DESCRIPTOR passing mechanism name in the
IMPORT_VALUED_PROCEDURE pragma for the parameter.
RTL_STR_DESC Generates the DESCRIPTOR passing mechanism name in the
IMPORT_VALUED_PROCEDURE pragma for the parameter.
IN Causes the IN parameter mode to appear on the formal parameter.
OUT Causes the OUT parameter mode to appear on the formal
parameter.
NAMED param-name Parameter name. If none exists, names will be generated of the
form PARAMETER_1 ... PARAMETER_n.
VALUE Generates the VALUE passing mechanism name in the
IMPORT_VALUED_PROCEDURE pragma for the parameter.
REFERENCE Generates the REFERENCE passing mechanism name in the
IMPORT_VALUED_PROCEDURE pragma for the parameter.
DEFAULT n If DEFAULT = 0, see the table at the end of this section for
the initial values of each OpenSDL data type. If the parameter
contains the VALUE attribute and the default value is other
than 0, that := value is added to the parameter.

Ada Translation Summary
OpenSDL Declaration Ada Output
LIST Generates 10 formal parameters of the type of the parameter
being described. If optional is not specified, all but the first of
the corresponding parameter specifications contain a default
expression of the form type’NULL_PARAMETER. If optional
is specified, all 10 parameter specifications contain the default
expression. An appropriate entry for FIRST_OPTIONAL_
PARAMETER is generated.
OPTIONAL Generates a parameter specification containing a default expression
of the form type’NULL_PARAMETER. If mode is OUT (or
IN OUT), an additional parameter specification is generated to
allow for use as an output parameter. An appropriate entry for
FIRST_OPTIONAL_PARAMETER is generated.
TYPENAME type-name Specifies a non-SDL keyword data type to be used as the parameter
type.
RETURNS return-data-type The first parameter in the parameter list is the return parameter.
A comment of the form ’- - return value’ is placed beside the
return parameter.
NAMED param-name Specifies the name of a parameter in the IMPORT_VALUED_
PROCEDURE argument list that receives the return value.
VARIABLE n/a
ALIAS internal-name The internal-name is used instead of the entry name as the
identifier associated with the entry point.
LINKAGE n/a
TYPENAME type-name Specifies a non-SDL keyword data type to be used as the entry
type.
STRUCTURE A Ada record type is generated as well as a record representation
clause and an initialization constant for the record. If
any substructures exist, the record types for those structures are
generated first. Following this table, see the note on structures
for a discussion of structure to Ada record translation.
UNION A Ada record type is generated depending on the union.
See the notes following this table for a discussion of union
translations.
BYTE [SIGNED] INTEGER_8
INTEGER_BYTE [SIGNED] INTEGER_8
WORD [SIGNED] INTEGER_16
INTEGER_WORD [SIGNED] INTEGER_16
LONGWORD [SIGNED] INTEGER_32
INTEGER_LONG [SIGNED] INTEGER_32
INTEGER [SIGNED] INTEGER_32
QUADWORD [SIGNED] UNSIGNED_QUADWORD
INTEGER_QUAD [SIGNED] UNSIGNED_QUADWORD

Ada Translation Summary
OpenSDL Declaration Ada Output
INTEGER_HW [SIGNED] INTEGER_64 for /ALPHA
INTEGER_32 for /VAX
HARDWARE_INTEGER [SIGNED] INTEGER_64 for /ALPHA
INTEGER_32 for /VAX
OCTAWORD UNSIGNED_LONGWORD_ARRAY(0 .. 3)
BYTE UNSIGNED UNSIGNED_BYTE
INTEGER_BYTE UNSIGNED UNSIGNED_BYTE
WORD UNSIGNED UNSIGNED_WORD
INTEGER_WORD UNSIGNED UNSIGNED_WORD
LONGWORD UNSIGNED_LONGWORD
INTEGER_LONG UNSIGNED UNSIGNED_LONGWORD
INTEGER UNSIGNED UNSIGNED_LONGWORD
QUADWORD UNSIGNED UNSIGNED_QUADWORD
INTEGER_QUAD UNSIGNED UNSIGNED_QUADWORD
INTEGER_HW UNSIGNED UNSIGNED_QUADWORD for /ALPHA
UNSIGNED_LONGWORD for /VAX
HARDWARE_INTEGER UNSIGNED UNSIGNED_QUADWORD for /ALPHA
UNSIGNED_LONGWORD for /VAX
OCTAWORD UNSIGNED UNSIGNED_LONGWORD_ARRAY(0 .. 3)
F_FLOATING F_FLOAT
D_FLOATING D_FLOAT
G_FLOATING G_FLOAT
H_FLOATING LONG_LONG_FLOAT
F_FLOATING COMPLEX F_FLOATING_COMPLEX
D_FLOATING COMPLEX D_FLOATING_COMPLEX
G_FLOATING COMPLEX G_FLOATING_COMPLEX
H_FLOATING COMPLEX H_FLOATING_COMPLEX
DECIMAL PRECISION (p,q) This data type has not yet been implemented. A comment
appears in the output, and a message is printed to this effect.
BITFIELD BOOLEAN (one bit)
LENGTH n UNSIGNED_n if n > 1; BOOLEAN if n = 1 for /ALPHA
BIT_ARRAY (0..n-1) for /VAX
MASK prefix_M_name : constant : = 16#mask-value#;
SIGNED n/a
CHARACTER CHARACTER

Ada Translation Summary
OpenSDL Declaration Ada Output
LENGTH n STRING(1 .. n) if n > 1
LENGTH * STRING
VARYING UNSIGNED_WORD field for the string length is generated if
VARYING is specified; n/a in parameter context
ADDRESS ADDRESS
POINTER ADDRESS
POINTER_LONG ADDRESS
POINTER_HW UNSIGNED_QUADWORD for /ALPHA
ADDRESS for /VAX
HARDWARE_ADDRESS UNSIGNED_QUADWORD for /ALPHA
ADDRESS for /VAX
POINTER_QUAD UNSIGNED_QUADWORD
BOOLEAN BOOLEAN
user-type-name user-type-name_TYPE
Default storage class n/a
COMMON storage class n/a
GLOBAL storage class n/a
BASED pointer-name n/a
TYPEDEF For an ITEM, a subtype definition is generated. For an
AGGREGATE, the behavior is as though TYPEDEF had not
been specified.
DIMENSION [lbound]:hbound If other than a BITFIELD data type, append ’_ARRAY (lbound ..
hbound)’ to the type.
For BITFIELDS, a BIT_ARRAY is generated of the form BIT_
ARRAY(0 .. hbound*length-1). If lbound is not supplied, it
defaults to 1.
ORIGIN member-name n/a
Notes
1. Ada Names
Dollar signs ($) are illegal in Ada names and are replaced with underscores (_).
2. Union Criteria
If the union has the following form, it is treated as a record type:

Ada Translation Summary
A ... union;
ITEM_1 ...; /* First member is not a union or
a structure, and the size of the
first member is the same as the
size of the union.
ITEM_2 structure ...; /* Second member is a structure,
and the size of the first member
is the same as the size of the
union. (Needed so size based
on structure components is
correct.)
I_2_A ...;
I_2_B ...;
...
end ITEM_2;
ITEM_3 ...;
...
end A;
If the union does not have the form shown in the previous example, the union is ignored
and only the first member is used.
Example 1 - Criteria are satisfied:
---------
aggregate X prefix XXX$;
X_1 longword unsigned;
X_2_OVERLAY union;
X_2 longword unsigned;
X_2_FIELDS structure;
X_2_B_1 byte unsigned;
X_2_B_2 byte unsigned;
end X_2_FIELDS;
X_2_C word unsigned;
X_2_D structure;
X_2_D_1 bitfield(3);
X_2_D_2 bitfield;
end X_2_D;
end X_2_OVERLAY;
end X;
The union X_2_OVERLAY satisfies the criteria in the previous example and would be
treated as a record declaration. Source code similar to the following would be generated:
type XXX_X_2_TYPE is record
X_2_B_1 : BYTE;
X_2_B_2 : BYTE;
end record;
type XXX_X_2_D_TYPE is record
X_2_D_1 : FLAGS(1 .. 3);
X_2_D_2 : BOOLEAN;
end record;
type XXX_TYPE is record
X_1 : LONGWORD;
X_2 : XXX_X_2_TYPE;
----X_2_C overlaps X_2
----
----X_2_C : UNSIGNED_16;

Ada Translation Summary
----X_2_D overlaps X_2
----
----X_2_D : XXX_X_2_D_TYPE;
end record;
Example 2 - Criteria are not satisfied
---------
aggregate Y prefix YYY$;
Y_1 longword unsigned;
Y_2_OVERLAY union;
Y_2_A byte unsigned;
Y_2_B byte unsigned;
end Y_2_OVERLAY;
end Y;
In the previous example, the second member is not a structure, and the following source
code would be generated:
type YYY_TYPE is record
Y_1 : LONGWORD;
Y_2_A : BYTE;
----Y_2_B overlaps Y_2_A
----
----Y_2_B : BYTE;
end record;
3. IN and OUT Parameter Modes
If the mode is not explicitly given for a parameter, the default mode (IN) appears.
4. OPTIONAL Parameters
An entry for FIRST_OPTIONAL_PARAMETER is generated, naming the first trailing
optional parameter, if one exists. The appropriate signatures are generated for OPTIONAL
OUT (or IN OUT) parameters to allow for any valid combination of actual parameters to
be specified.
5. DEFAULT Values
DEFAULT generates a default expression in the parameter specification.
The following is a list of OpenSDL data types and the default Ada values for the
INITIALIZATION constant.
OpenSDL Data
Type Ada INITIALIZATION
BYTE [SIGNED] 0
INTEGER_BYTE
[SIGNED]
INTEGER_8_ZERO
WORD [SIGNED] 0
INTEGER_WORD
[SIGNED]
INTEGER_16_ZERO
LONGWORD
[SIGNED]
0
INTEGER_LONG
[SIGNED]
INTEGER_32_ZERO

Ada Translation Summary
OpenSDL Data
Type Ada INITIALIZATION
INTEGER
[SIGNED]
INTEGER_32_ZERO
INTEGER_HW
[SIGNED]
INTEGER_64_ZERO for /ALPHA
INTEGER_32_ZERO for /VAX
HARDWARE_
INTEGER
[SIGNED]
INTEGER_64_ZERO for /ALPHA
INTEGER_32_ZERO for /VAX
QUADWORD
[SIGNED]
(0, 0)
INTEGER_QUAD
[SIGNED]
UNSIGNED_QUADWORD_ZERO
OCTAWORD
[SIGNED]
(0, 0, 0, 0)
BYTE UNSIGNED 0
INTEGER_BYTE
UNSIGNED
UNSIGNED_BYTE_ZERO
WORD UNSIGNED 0
INTEGER_WORD
UNSIGNED
UNSIGNED_WORD_ZERO
LONGWORD
UNSIGNED
0
INTEGER_LONG
UNSIGNED
UNSIGNED_LONGWORD_ZERO
INTEGER
UNSIGNED
UNSIGNED_LONGWORD_ZERO
INTEGER_HW
UNSIGNED
UNSIGNED_QUADWORD_ZERO for /ALPHA
UNSIGNED_LONGWORD_ZERO for /VAX
HARDWARE_
INTEGER
UNSIGNED
UNSIGNED_ZERO for /ALPHA
UNSIGNED_LONGWORD_ZERO for /VAX
QUADWORD
UNSIGNED
(0, 0)
INTEGER_QUAD
UNSIGNED
UNSIGNED_QUADWORD_ZERO
OCTAWORD
[SIGNED]
(0, 0, 0, 0)

Ada Translation Summary
OpenSDL Data
Type Ada INITIALIZATION
CHARACTER ASCII.NUL
DECIMAL
PRECISION (p,s)
NYI_PACKED_DECIMAL_ZERO
F_FLOATING 0.0
F_FLOATING_
COMPLEX
F_FLOATING_COMPLEX_ZERO
D_FLOATING 0.0
D_FLOATING_
COMPLEX
D_FLOATING_COMPLEX_ZERO
G_FLOATING 0.0
G_FLOATING_
COMPLEX
G_FLOATING_COMPLEX_ZERO
H_FLOATING 0.0
H_FLOATING_
COMPLEX
H_FLOATING_COMPLEX_ZERO
ADDRESS ADDRESS_ZERO
POINTER ADDRESS_ZERO
POINTER_LONG ADDRESS_ZERO
POINTER_HW UNSIGNED_QUADWORD_ZERO for /ALPHA
ADDRESS_ZERO for /VAX
HARDWARE_
ADDRESS
UNSIGNED_QUADWORD_ZERO for /ALPHA
ADDRESS_ZERO for /VAX
POINTER_QUAD (0, 0)
6. Structure of Ada Record Translation
For each OpenSDL structure, the corresponding Ada translation consists of three parts:
1) a record type definition, 2) a record representation clause, and 3) an initialization
constant for the record. The three parts have the following form:
type structure-name is
record
member-name : type; ...
end record;
for structure-name use
record
member-name at offset range 0 .. size;
...
end record
for structure-name’size use total-size;
structure-name_INIT : constant structure-name :=
(member-name => initial_value,
...)

Ada Translation Summary
Size is the size of the field in bits, and total_size is the size of the entire record in bits.

BASIC Translation Summary
BASIC Translation Summary
The following table shows the OpenSDL to BASIC language translation summary.
OpenSDL Declaration BASIC Output
MODULE name IDENT string !*** MODULE name IDENT string ***
/* comment ! comment
CONSTANT x
EQUALS n; DECLARE LONG CONSTANT x = n
EQUALS STRING "s"; DECLARE STRING CONSTANT x = "s"
ENTRY name EXTERNAL SUB name
PARAMETER (type,...) ( &
type, &
.
.
)
ANY ANY
DESCRIPTOR BY DESC
RTL_STR_DESC BY DESC
IN n/a
OUT n/a
NAMED param-name n/a
VALUE BY VALUE
REFERENCE BY REF
DEFAULT n n/a
LIST Yields one explicit parameter description plus m-n commas,
where m is the maximum number of parameters allowable in
BASIC, and n is the number of parameters already specified
(including the LIST parameter description).
OPTIONAL OPTIONAL data-type
TYPENAME type-name n/a
RETURNS return-data-type EXTERNAL data-type FUNCTION name
NAMED param-name n/a
VARIABLE n/a
ALIAS n/a
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE DECLARE LONG CONSTANT markerS_structure-name = size

BASIC Translation Summary
OpenSDL Declaration BASIC Output
RECORD struct-name
type member-name
.
.
.
END RECORD struct-name
UNION DECLARE LONG CONSTANT markerS_union-name = size
RECORD union-name
VARIANT
CASE
type member-name
.
.
.
END VARIANT
END RECORD union-name
BYTE [SIGNED] BYTE
INTEGER_BYTE [SIGNED] BYTE
WORD [SIGNED] WORD
INTEGER_WORD [SIGNED] WORD
LONGWORD [SIGNED] LONG
INTEGER_LONG [SIGNED] LONG
INTEGER [SIGNED] LONG
INTEGER_HW [SIGNED] BASIC$QUADWORD for /ALPHA
LONG for /VAX
HARDWARE_INTEGER [SIGNED] BASIC$QUADWORD for /ALPHA
LONG for /VAX
QUADWORD [SIGNED] BASIC$QUADWORD
INTEGER_QUAD [SIGNED] BASIC$QUADWORD
OCTAWORD BASIC$OCTAWORD
BYTE UNSIGNED BYTE
INTEGER_BYTE UNSIGNED BYTE
WORD UNSIGNED WORD
INTEGER_WORD UNSIGNED WORD
LONGWORD UNSIGNED LONG
INTEGER_LONG UNSIGNED LONG

BASIC Translation Summary
OpenSDL Declaration BASIC Output
INTEGER UNSIGNED LONG
QUADWORD UNSIGNED BASIC$QUADWORD
INTEGER_QUAD UNSIGNED BASIC$QUADWORD
INTEGER_HW UNSIGNED BASIC$QUADWORD for /ALPHA
LONG for /VAX
HARDWARE_INTEGER UNSIGNED BASIC$QUADWORD for /ALPHA
LONG for /VAX
OCTAWORD UNSIGNED BASIC$OCTAWORD
F_FLOATING SINGLE
D_FLOATING DOUBLE
G_FLOATING GFLOAT
H_FLOATING BASIC$HFLOAT_AXP for /ALPHA
HFLOAT for /VAX
F_FLOATING COMPLEX BASIC$F_FLOATING_COMPLEX
D_FLOATING COMPLEX BASIC$D_FLOATING_COMPLEX
G_FLOATING COMPLEX BASIC$G_FLOATING_COMPLEX
H_FLOATING COMPLEX BASIC$H_FLOATING_COMPLEX_AXP for /ALPHA
BASIC$H_FLOATING_COMPLEX for /VAX
DECIMAL PRECISION (p,q) DECIMAL (p,q)
BITFIELD type name_bits ! COMMENT ADDED
BY SDL name_bits contains bits name1 through name2
LENGTH n n is used in computing size (type) of name_bits field.
MASK DECLARE LONG CONSTANT prefix$m_name = x’mask-value’
SIGNED n/a
CHARACTER STRING name = 1
LENGTH n STRING name = n
LENGTH * STRING
VARYING group name
WORD str-len
STRING str-text = n, where n is the maximum length of the
string
end group name
ADDRESS LONG name
POINTER LONG name
POINTER_LONG LONG name
POINTER_HW BASIC$QUADWORD name for /ALPHA

BASIC Translation Summary
OpenSDL Declaration BASIC Output
LONG name for /VAX
HARDWARE_ADDRESS BASIC$QUADWORD name for /ALPHA
LONG name for /VAX
POINTER_QUAD BASIC$QUADWORD name
BOOLEAN BYTE name
user-type-name user_type_name
COMMON storage class COMMON name name
GLOBAL storage class EXTERNAL name name
BASED pointer-name n/a
TYPEDEF For an ITEM, a record definition is generated. For an
AGGREGATE, the behavior is as though TYPEDEF had not
been specified.
DIMENSION [lbound:]hbound type name (lbound to hbound); if lbound was not specified in 
SDL, lbound is 1 in the BASIC output
ORIGIN member-name n/a

BLISS Translation Summary
BLISS Translation Summary
The following table shows the OpenSDL to BLISS language translation summary.
OpenSDL Declaration BLISS Output
MODULE name IDENT string !*** MODULE name IDENT string ***
/* comment ! comment
CONSTANT x
EQUALS n; LITERAL x = n;
EQUALS STRING "s"; macro x = ’s’%;
ENTRY name EXTERNAL ROUTINE name
EXTERNAL ROUTINE name: NOVALUE ;
PARAMETER (type,...) n/a
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name n/a
VALUE n/a
REFERENCE n/a
DEFAULT n Used in KEYWORDMACRO when the /VMS_DEVELOPMENT
qualifier is specified
LIST Generates invocation of special predefined macro to handle LIST
parameters
OPTIONAL Generates invocation of special predefined macro to handle
OPTIONAL parameters when the /VMS_DEVELOPMENT
qualifier is specified
TYPENAME type-name n/a
RETURNS return-data-type n/a
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name When the /VMS_DEVELOPMENT qualifier is specified,
internal-name becomes the name of the BLISS KEYWORDMACRO
generated for the ENTRY declaration.
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE and UNION Each aggregate or member declaration in OpenSDL produces a
BLISS macro declaration of the form:

BLISS Translation Summary
OpenSDL Declaration BLISS Output
MACRO name = off,pos,size,ext %;
The BLISSF back end translates each aggregate and associated
member declaration in OpenSDL to a BLISS field declaration.
The field-set-name is of the form prefix$name_FIELDSET,
where prefix is declared for the entire aggregate and name is
the aggregate name.
FIELD prefix$name_FIELDSET=
SET
member-name = [off,pos,size,ext];
.
.
.
TES;
literal prefix$s_name = size;
MACRO prefix$r_name = BLOCK
[pref$_name,BYTE]
FIELD
(prefix$name_FIELDSET)%;
off
Byte offset of this aggregate or item within the current aggregate

BLISS Translation Summary
pos
Bit position from the offset
size
Size of the aggregate of item, in bits, if the size is 4 bytes or
less. Otherwise, this field contains 0, and OpenSDL generates
the size declaration.
ext
Contains 0 if the value is zero extended, or 1 if the value is sign
extended or SIGNED bit.
The following OpenSDL data types generate field specifications of
the form "off,pos,size,ext" in various contexts. Where necessary,
constants indicating the size of the data type (field) are also
generated.
BYTE [SIGNED] off,pos,8,1
INTEGER_BYTE [SIGNED] off,pos,8,1
WORD [SIGNED] off,pos,16,1
INTEGER_WORD [SIGNED] off,pos,16,1
LONGWORD [SIGNED] off,pos,32,1
INTEGER_LONG [SIGNED] off,pos,32,1
INTEGER [SIGNED] off,pos,32,1
INTEGER_HW [SIGNED] off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,32,1 for /VAX
HARDWARE_INTEGER [SIGNED] off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,32,1 for /VAX
QUADWORD [SIGNED] off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,0,1 for /VAX
INTEGER_QUAD [SIGNED] off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,0,1 for /VAX
OCTAWORD [SIGNED] off,pos,0,1
BYTE UNSIGNED off,pos,8,0
INTEGER_BYTE UNSIGNED off,pos,8,0
WORD UNSIGNED off,pos,16,0
INTEGER_WORD UNSIGNED off,pos,16,0
LONGWORD UNSIGNED off,pos,32,0
INTEGER_LONG UNSIGNED off,pos,32,0

BLISS Translation Summary
OpenSDL Declaration BLISS Output
INTEGER UNSIGNED off,pos,32,0
INTEGER_HW UNSIGNED off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,32,0 for /VAX
HARDWARE_INTEGER UNSIGNED off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,32,0 for /VAX
QUADWORD [SIGNED] off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,0,0 for /VAX
INTEGER_QUAD [SIGNED] off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,0,0 for /VAX
OCTAWORD UNSIGNED off,pos,0,0
F_FLOATING off,pos,32,0
D_FLOATING off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,0,0 for /VAX
literal prefix$s_name = 8;
G_FLOATING off,pos,0,0 for /ALPHA
off,pos,64,0 for /ALPHA/B64
off,pos,0,0 for /VAX
literal prefix$s_name = 8;
H_FLOATING off,pos,0,0
literal prefix$s_name = 16;
If you specify /LANGUAGES=BLISSF, a special set of macros
and FIELDSETs, which define the particular COMPLEX data
type and its real and imaginary components, are generated.
F_FLOATING COMPLEX off,pos,0,0 for /ALPHA
COMPLEX off,pos,64,0 for /ALPHA/B64
COMPLEX off,pos,0,0 for /VAX
literal prefix$s_name = 8;
D_FLOATING COMPLEX off,pos,0,0
literal prefix$s_name = 16;
G_FLOATING COMPLEX off,pos,0,0
literal prefix$s_name = 16;

BLISS Translation Summary
OpenSDL Declaration BLISS Output
H_FLOATING COMPLEX off,pos,0,0
literal prefix$s_name = 32;
DECIMAL PRECISION (p,q) n/a
BITFIELD off,pos,size,0
literal prefix$_name = size;
LENGTH n off,pos,n,0
literal prefix$_name = n;
MASK literal prefix$m_name = mask-value; where mask-value is the
decmal equivalent of the binary mask
SIGNED off,pos,size,1
CHARACTER off,pos,size,0
LENGTH n literal prefix$_name = n;
LENGTH * n/a
VARYING off,pos,size,0; where size = (length + 2) * 8. If (length + 2) > 4,
then size = 0.
literal prefix$s_name = <length + 2>;
ADDRESS off,pos,32,0
POINTER off,pos,32,1
POINTER_LONG off,pos,32,1
POINTER_HW off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,32,1 for /VAX
HARDWARE_ADDRESS off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,32,1 for /VAX
POINTER_QUAD off,pos,0,1 for /ALPHA
off,pos,64,1 for /ALPHA/B64
off,pos,0,1 for /VAX
BOOLEAN off,pos,8,0
user-type-name off,pos,size,0; where size is dependent upon the type indicated
by user-type-name
Default storage class n/a
COMMON storage class EXTERNAL
with /GLOBALDEF GLOBAL
GLOBAL storage class EXTERNAL
with /GLOBALDEF GLOBAL
BASED pointer-name n/a

BLISS Translation Summary
OpenSDL Declaration BLISS Output
TYPEDEF n/a
DIMENSION [lbound:]hbound lbound and hbound are only used to determine the total size of
the item, which is reflected in: literal prefix$s_name = size;
ORIGIN member-name n/a
Notes
1. The BLISS output routine does not assign data to storage classes.
2. For all literals above, size is given in bytes.

C/C++ Translation Summary
C/C++ Translation Summary
The C backend differentiates along the qualifiers /ALPHA vs. /VAX, /[NO]VMS_DEVELOPMENT,
and /[NO]C_DEVELOPMENT.
/VMS_DEVELOPMENT and /C_DEVELOPMENT can be combined.
When /C_DEVELOPMENT is present, every definition is translated twice, once between
#ifdef __NEW_STARLET
/* translation */
#else /* __OLD_STARLET */
and once between
#else /* __OLD_STARLET */
/* possibly different translation */
#endif /* #ifdef __NEW_STARLET */
So there are 12 possibly different translations for a single data type. To make the translation
summary more readable, abbreviations are used.
Abbreviation Qualifier combination
a /ALPHA
b /ALPHA/VMS_DEVELOPMENT
c /ALPHA/VMS_DEVELOPMENT/C_DEVELOPMENT, #ifdef _ _NEW_STARLET
d /ALPHA/VMS_DEVELOPMENT/C_DEVELOPMENT, #else
e /ALPHA/C_DEVELOPMENT, #ifdef _ _NEW_STARLET
f /ALPHA/C_DEVELOPMENT, #else
g /VAX
h /VAX/VMS_DEVELOPMENT
i /VAX/VMS_DEVELOPMENT/C_DEVELOPMENT, #ifdef _ _NEW_STARLET
j /VAX/VMS_DEVELOPMENT/C_DEVELOPMENT, #else
k /VAX/C_DEVELOPMENT, #ifdef _ _NEW_STARLET
l /VAX/C_DEVELOPMENT, #else
The following table shows the OpenSDL to C/C++ language translation summary.
OpenSDL Declaration C/C++ Output
MODULE name IDENT string /*** MODULE name IDENT string ***/
/* comment /* comment */
CONSTANT x
EQUALS n; #define x n
EQUALS STRING "s"; #define x "s"

C/C++ Translation Summary
OpenSDL Declaration C/C++ Output
ENTRY name return-type name( )
PARAMETER (type,...) n/a
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name n/a
VALUE n/a
REFERENCE n/a
DEFAULT n n/a
LIST n/a
OPTIONAL n/a
TYPENAME type-name n/a
RETURNS return-type return-type name( )
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name n/a
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE struct
UNION union
name BYTE [SIGNED] char name
name INTEGER_BYTE [SIGNED] char name
name WORD [SIGNED] short int name
name INTEGER_WORD [SIGNED] short int name
name LONGWORD [SIGNED] int name
name INTEGER_LONG [SIGNED] int name
name INTEGER [SIGNED] int name
name INTEGER_HW [SIGNED] _ _int64 name for a-f
int name for g-l
name HARDWARE_INTEGER
[SIGNED]
_ _int64 name for a-f
int name for g-l
name QUADWORD [SIGNED] int name [2] for a, d, f, g, h, j, l
_ _int64 name for b, c, e, i, k

C/C++ Translation Summary
OpenSDL Declaration C/C++ Output
name INTEGER_QUAD [SIGNED] _ _int64 name for a-f
int name[2] for g-l
name OCTAWORD [SIGNED] int name [4]
name BYTE UNSIGNED unsigned char
name INTEGER_BYTE UNSIGNED unsigned char
name WORD UNSIGNED unsigned short int
name INTEGER_WORD UNSIGNED unsigned short int
name INTEGER_LONGWORD
UNSIGNED
unsigned int
name INTEGER_LONG UNSIGNED unsigned int
name INTEGER UNSIGNED unsigned int
name INTEGER_HW UNSIGNED unsigned _ _int64 name for a-f
unsigned int name for g-l
name HARDWARE_INTEGER
UNSIGNED
unsigned _ _int64 name for a-f
unsigned int name for g-l
name QUADWORD UNSIGNED unsigned int name [2] for a, d, f, g, h, j, l
unsigned _ _int64 name for b, c, e, i, k
name INTEGER_QUAD UNSIGNED unsigned _ _int64 name for a-f
unsigned int name[2] for g-l
name OCTAWORD UNSIGNED unsigned int name [4]
name F_FLOATING float name
name D_FLOATING double float name
name G_FLOATING double float name
name H_FLOATING int name [4]
name F_FLOATING COMPLEX float name [2]
name D_FLOATING COMPLEX double float name [2]
name G_FLOATING COMPLEX double float name [2]
name H_FLOATING COMPLEX int name [8]
name DECIMAL PRECISION (p,q) char name [p/2+1]
name BITFIELD unsigned name:1
LENGTH n unsigned name:n
MASK n/a
SIGNED n/a
name CHARACTER char name
LENGTH n char name [n]

C/C++ Translation Summary
OpenSDL Declaration C/C++ Output
LENGTH * n/a
VARYING struct {short string_length; char string_text[n];} name; where n
is the maximum length of the character string
name ADDRESS (object-type) object-type *name for a-c, e, g-i, k
void * for d, f, j, l
name POINTER (object-type) object-type *name for a-c, e, g-i, k
unsigned int for d, f, j, l
name POINTER_LONG (objecttype)
int for a-l
void * for b, c, e, h, i, k
name POINTER_HW (object-type) object-type *name for a, g-i, k
(1) for b-c, e
unsigned _ _int64 name for d, f
unsigned int for j, l
name HARDWARE_ADDRESS
(object-type)
object-type *name for a-l
name POINTER_QUAD (objecttype)
object-type *name for a, g
(1) for b-c, e, h, i, k
unsigned _ _int64 name for d, f
unsigned int name [2] for j, l
name BOOLEAN char name
name user-type-name user-type-name name
Default storage class struct or union with <member-name> as the tag, and no declared
variable names
COMMON storage class extern attribute
GLOBAL storage class globalref attribute
with /GLOBALDEF globaldef attribute
BASED pointer-name A pointer will be generated for the based item
TYPEDEF For an AGGREGATE, a TYPEDEF STRUCT is generated.
In this case, a pre-tag is generated as well as the post-tag.
The pre-tag consists of the structure named prefixed by an
underscore. Any reference to the structure type within the
definition (such as for forward and backward linkages) is also
output with the underscore. For an ITEM, the TYPEDEF
keyword is generated, followed by the data type of the ITEM.
1 #ifdef _ _INITIAL_POINTER_SIZE #pragma _ _required_pointer_size _ _long object-type *name; #else unsigned
_ _int64 name; #endif

C/C++ Translation Summary
OpenSDL Declaration C/C++ Output
DIMENSION [lbound:]hbound The declaration specifies an array of the number of elements
specified with subscripts ranging from 0 to (hbound - lbound +
1)
ORIGIN member-name n/a

DATATRIEVE Translation Summary
DATATRIEVE Translation Summary
The following table shows the OpenSDL to DATATRIEVE language translation summary.
OpenSDL Declaration DATATRIEVE Output
MODULE name IDENT string ! *** MODULE name IDENT string ***
/* comment ! comment
CONSTANT x EQUALS n; ! x=n
ENTRY ! name ENTRY
PARAMETER (type,...) n/a
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name n/a
VALUE n/a
REFERENCE n/a
DEFAULT n n/a
LIST n/a
OPTIONAL n/a
TYPENAME type-name n/a
RETURNS return-data-type n/a
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name n/a
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE A group field declaration. An AGGREGATE declaration is
always assigned a level number of 1; subsequent subaggregates
are assigned level numbers 2, 3, and so on.
UNION A group field declaration, with level numbers assigned as above.
All but the first union member have a REDEFINES first-fieldname
clause. The redefined fields cannot be larger than the first
union member.
BYTE [SIGNED] USAGE IS BYTE
INTEGER_BYTE [SIGNED] USAGE IS BYTE
WORD [SIGNED] USAGE IS WORD
INTEGER_WORD [SIGNED] USAGE IS WORD

DATATRIEVE Translation Summary
OpenSDL Declaration DATATRIEVE Output
LONGWORD [SIGNED] USAGE IS LONG
INTEGER_LONG [SIGNED] USAGE IS LONG
INTEGER [SIGNED] USAGE IS LONG
INTEGER_HW [SIGNED] USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
HARDWARE_INTEGER [SIGNED] USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
QUADWORD [SIGNED] USAGE IS QUAD
INTEGER_QUAD [SIGNED] USAGE IS QUAD
OCTAWORD [SIGNED] USAGE IS QUAD OCCURS 2 TIMES
BYTE UNSIGNED USAGE IS BYTE
INTEGER_BYTE UNSIGNED USAGE IS BYTE
WORD UNSIGNED USAGE IS WORD
INTEGER_WORD UNSIGNED USAGE IS WORD
LONGWORD UNSIGNED USAGE IS LONG
INTEGER_LONG UNSIGNED USAGE IS LONG
INTEGER UNSIGNED USAGE IS LONG
INTEGER_HW UNSIGNED USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
HARDWARE_INTEGER UNSIGNED USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
QUADWORD UNSIGNED USAGE IS QUAD
INTEGER_QUAD UNSIGNED USAGE IS QUAD
OCTAWORD UNSIGNED USAGE IS QUAD OCCURS 2 TIMES
F_FLOATING USAGE IS REAL
D_FLOATING USAGE IS DOUBLE
G_FLOATING USAGE IS DOUBLE
H_FLOATING USAGE IS QUAD OCCURS 2 TIMES
F_FLOATING COMPLEX USAGE IS REAL OCCURS 2 TIMES
D_FLOATING COMPLEX USAGE IS DOUBLE OCCURS 2 TIMES
G_FLOATING COMPLEX USAGE IS DOUBLE OCCURS 2 TIMES
H_FLOATING COMPLEX USAGE IS QUAD OCCURS 2 TIMES
DECIMAL PRECISION (p,q) USAGE IS PACKED PIC 9(p-q)V9(q)
BITFIELD ! name BIT position:size
See the description following the table
LENGTH n ! name BIT position:n

DATATRIEVE Translation Summary
OpenSDL Declaration DATATRIEVE Output
MASK ! maskname = value
SIGNED n/a
CHARACTER PIC X(n)
LENGTH n X(n)
LENGTH * n/a
VARYING A group field of the form:
level field-name
level+1 STRING_LENGTH USAGE IS WORD
level+1 STRING_TEXT PIC X(n)
ADDRESS USAGE IS LONG
POINTER USAGE IS LONG
POINTER_LONG USAGE IS LONG
POINTER_HW USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
HARDWARE_ADDRESS USAGE IS QUAD for /ALPHA
USAGE IS LONG for /VAX
POINTER_QUAD USAGE IS QUAD
BOOLEAN USAGE IS BYTE
Default storage class n/a
COMMON storage class n/a
GLOBAL storage class n/a
with /GLOBALDEF n/a
BASED pointer-name n/a
pointer-name USAGE IS LONG
name DIMENSION [lbound:]hbound OCCURS hbound-lbound+1 TIMES
ORIGIN member-name n/a
Notes
1. Bitfields must be an integral number of bytes, union members, or be fully contained in a
structure composed only of bit members. If they are in a structure, bit names themselves
are commented out, but the appropriate amount of storage is allocated at the structure
name level. USAGE IS BYTE, WORD, LONG, or QUAD is used when possible to allocate
the storage; otherwise, USAGE IS BYTE OCCURS n TIMES is used.
2. All items and aggregates are output as record definitions as follows:

DATATRIEVE Translation Summary
DEFINE RECORD aggregate-name_RECORD USING
1 aggregate-name.
2 member-name datatype.
.
.
.
;
The record name is composed of the top-level aggregate or item name and the string ‘‘_
RECORD’’.
3. A dollar sign ($) appearing in a name is replaced by a hyphen (-).

FORTRAN Translation Summary
FORTRAN Translation Summary
The following table shows the OpenSDL to FORTRAN language translation summary.
OpenSDL Declaration FORTRAN Output
MODULE name IDENT string !*** MODULE name IDENT string ***
/* comment ! comment
CONSTANT x
EQUALS n; PARAMETER x = n
EQUALS STRING "s"; CHARACTER*(*) x
PARAMETER (x = ’s’)
ENTRY name EXTERNAL name
PARAMETER (type,...) n/a
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name n/a
VALUE n/a
REFERENCE n/a
DEFAULT n n/a
LIST n/a
OPTIONAL n/a
TYPENAME type-name n/a
RETURNS return-data-type data-type function-name
NAMED param-name n/a
VARIABLE n/a
ALIAS internal-name n/a
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE If this is a top-level AGGREGATE declaration, a FORTRAN
STRUCTURE declaration is generated. If this is a subaggregate
declaration, no structure is generated.
UNION UNION and associated MAP declarations
name BYTE [SIGNED] BYTE name
name INTEGER_BYTE [SIGNED] INTEGER*1 name
name WORD [SIGNED] INTEGER*2 name

FORTRAN Translation Summary
OpenSDL Declaration FORTRAN Output
name INTEGER_WORD [SIGNED] INTEGER*2 name
name LONGWORD [SIGNED] INTEGER*4 name
name INTEGER_LONG [SIGNED] INTEGER*4 name
name INTEGER [SIGNED] INTEGER*4 name
name INTEGER_HW [SIGNED] INTEGER*8 for /ALPHA
INTEGER*4 name for /VAX
name HARDWARE_INTEGER
[SIGNED]
INTEGER*8 for /ALPHA
INTEGER*4 name for /VAX
name QUADWORD [SIGNED] INTEGER*4 name(2)
name INTEGER_QUAD [SIGNED] INTEGER*8 for /ALPHA
INTEGER*4 name(2) for /VAX
name OCTAWORD [SIGNED] INTEGER*4 name(4)
name BYTE UNSIGNED BYTE name
name INTEGER_BYTE UNSIGNED BYTE name
name WORD UNSIGNED INTEGER*2 name
name INTEGER_WORD UNSIGNED INTEGER*2 name
name LONGWORD UNSIGNED INTEGER*4 name
name INTEGER_LONG UNSIGNED INTEGER*4 name
name INTEGER UNSIGNED INTEGER*4 name
name INTEGER_HW UNSIGNED INTEGER*8 for /ALPHA
INTEGER*4 name for /VAX
name HARDWARE_INTEGER
UNSIGNED
INTEGER*8 for /ALPHA
INTEGER*4 name for /VAX
name QUADWORD UNSIGNED INTEGER*4 name(2)
name INTEGER_QUAD UNSIGNED INTEGER*8 for /ALPHA
INTEGER*4 name(2) for /VAX
name OCTAWORD UNSIGNED INTEGER*4 name(4)
name F_FLOATING REAL*4 name
name D_FLOATING REAL*8 name
name G_FLOATING REAL*8 name
name H_FLOATING REAL*16 name
name F_FLOATING COMPLEX COMPLEX name
name D_FLOATING COMPLEX COMPLEX*16 name
name G_FLOATING COMPLEX COMPLEX*16 name

FORTRAN Translation Summary
OpenSDL Declaration FORTRAN Output
name H_FLOATING COMPLEX BYTE %FILL (32)
DECIMAL PRECISION (p,q) Undefined data type; error INVOUT
BITFIELD Offset and size declarations with "V_" and "S_" tags
LENGTH n n specifies the size for size declaration
MASK Mask declaration, with "M" tag
SIGNED n/a
name CHARACTER CHARACTER*n name
LENGTH n CHARACTER*n name
LENGTH * n/a
VARYING STRUCTURE/name/name
INTEGER*2 LEN
CHARACTER*length TXT
END STRUCTURE
name ADDRESS INTEGER*4 name
name POINTER INTEGER*4 name
name POINTER_LONG INTEGER*4 name
name POINTER_HW INTEGER*8 name for /ALPHA
INTEGER*4 name for /VAX
name HARDWARE_ADDRESS INTEGER*8 name for /ALPHA
INTEGER*4 name for /VAX
name POINTER_QUAD INTEGER*8 name for /ALPHA
INTEGER*4 name(2) for /VAX
name BOOLEAN BYTE name
name user-type-name data-type name ! type is "user-type-name"
Default storage class Local, static
COMMON storage class RECORD /name/ name
COMMON /name/ name
GLOBAL storage class n/a
with /GLOBALDEF n/a
BASED pointer-name n/a
TYPEDEF For an ITEM, a comment is generated. For an AGGREGATE,
the behavior is as though TYPEDEF had not been specified.
DIMENSION [lbound:]hbound name(hbound - lbound)
ORIGIN member-name n/a
Note
Because FORTRAN does not have a comparable data type for BITFIELD, the 
FORTRAN back end translates bitfields to PARAMETERS with the same value as that of

FORTRAN Translation Summary
the associated structure offset. BYTE fillers (using the FORTRAN %FILL feature) are
placed in the structures for alignment.

MACRO Translation Summary
MACRO Translation Summary
The following table shows the OpenSDL to MACRO language translation summary.
OpenSDL Declaration MACRO Output
MODULE name IDENT string .MACRO name ;IDENT string
/* comment ;comment
CONSTANT x
EQUALS n; If /NOVMS_DEVELOMENT (default), generates: x’..equ’n
If /VMS_DEVELOPMENT is specified, generates: $EQU x n
EQUALS STRING "s"; See Note 2.
ENTRY If /NOVMS_DEVELOPMENT (default), generates: ;EXTERNAL
entry entry-name
If /VMS_DEVELOPMENT, generates a special set of macros
that facilitate calling of the routine using either the CALLG or
CALLS instruction.
PARAMETER (type,...) If /VMS_DEVELOPMENT, generates the formal argument list
for keyword macros associated with the ENTRY declaration
ANY n/a
DESCRIPTOR n/a
RTL_STR_DESC n/a
IN n/a
OUT n/a
NAMED param-name If /VMS_DEVELOPMENT, param-name becomes a formal
argument name used in the argument list for keyword macros
associated with the ENTRY declaration
VALUE n/a
REFERENCE n/a
DEFAULT n If /VMS_DEVELOPMENT, n becomes a default value in the
macro argument list for the parameter being described
LIST Fills the macro argument list with up to 20 parameters of the
type of the parameter being described
OPTIONAL Generates an "OPTIONAL" macro argument, which either
defaults to 0 or is truncated from the actual argument list when
the macro is expanded
TYPENAME type-name n/a
RETURNS return-data-type n/a
NAMED param-name n/a
VARIABLE If /VMS_DEVELOPMENT, causes a special form of macro to be
generated that handles a variable number of parameters. See
also LIST.

MACRO Translation Summary
OpenSDL Declaration MACRO Output
ALIAS internal-name Macro name (default is entry name)
LINKAGE Call instruction (default is CALLS)
TYPENAME type-name n/a
STRUCTURE See Note 1.
name BYTE [SIGNED] .
name INTEGER_BYTE [SIGNED] .
name WORD [SIGNED] .
name INTEGER_WORD [SIGNED] .
name LONGWORD [SIGNED] .
name INTEGER_LONG [SIGNED] .
name INTEGER [SIGNED] .
name INTEGER_HW [SIGNED] .
name HARDWARE_INTEGER
[SIGNED]
.
name QUADWORD [SIGNED] .
name INTEGER_QUADWORD
[SIGNED]
.
name OCTAWORD [SIGNED] .
name BYTE UNSIGNED .
name INTEGER_BYTE UNSIGNED .
name WORD UNSIGNED .
name INTEGER_WORD UNSIGNED .
name LONGWORD UNSIGNED .
name INTEGER_LONG UNSIGNED .
name INTEGER UNSIGNED .
name INTEGER_HW UNSIGNED .
name HARDWARE_INTEGER
UNSIGNED
.
name QUADWORD UNSIGNED .
name INTEGER_QUADWORD
UNSIGNED
.
name OCTAWORD UNSIGNED .
name F_FLOATING .
name D_FLOATING .
name G_FLOATING .
name H_FLOATING .
name F_FLOATING COMPLEX .

MACRO Translation Summary
OpenSDL Declaration MACRO Output
name D_FLOATING COMPLEX .
name G_FLOATING COMPLEX .
name H_FLOATING COMPLEX .
name DECIMAL PRECISION (p,q) .
name ADDRESS .
name POINTER .
name POINTER_LONG .
name POINTER_HW .
name HARDWARE_ADDRESS .
name POINTER_QUAD .
name BOOLEAN .
name user-type-name .
name CHARACTER .
LENGTH n n/a
LENGTH * n/a
VARYING n/a
name BITFIELD LENGTH n Bitfield identifiers are equal to the bit offset of the item, and a
prefix$_name identifier is equal to the size of the bitfield in bits;
see Note 1.
MASK Mask declarations are constants with the "m_" tag
SIGNED n/a; see Note 1.
Default storage class The aggregate is placed in the absolute Psect $ABS$, and the
value of the current location counter is set to the origin at the
beginning of the aggregate. Element names can then be used
as displacements off a register that contains the address of the
actual aggregate.
COMMON storage class An aggregate or item is placed in a Psect that has the same
name as the top-level aggregate or item, and the attributes
SHR, GBL, and OVR. Constant offsets are produced for all
aggregate members.
GLOBAL storage class Generates .EXTERNAL declaration for the top-level name, and
produces offset constants for any aggregate members.
with /GLOBALDEF Generates .GLOBAL declaration and BLKB length for top-level
name, and produces offset constants for any aggregate members.
BASED pointer-name n/a
TYPEDEF n/a
DIMENSION [lbound:]hbound Offsets are appropriately adjusted to allow for the size of the
array.

MACRO Translation Summary
OpenSDL Declaration MACRO Output
ORIGIN member-name Aggregate members preceding member-name may be referenced
using negative offsets with member-name as the base.
The MACRO output routine produces declarations that can generate either local symbol or
global symbol definitions. The following is an example of OpenSDL source code:
MODULE simple;
CONSTANT bits EQUALS 4;
ITEM field BYTE PREFIX tst$ COMMON;
END_MODULE;
The following is the resulting MACRO output:
.MACRO simple,..EQU=<=>,..COL=<:>
bits’..equ’4
.SAVE
.PSECT tst$b_field PIC,OVR,REL,GBL,-
SHR,NOEXE,RD,WRT,LONG
tst$b_field’..col’ <P>lkb 1
.RESTORE
; tst$b_field’..equ’0
.ENDM
When the macro is invoked without arguments, the resulting local definitions are as follows:
bits = 4
tst$b_field1:
blkb 1
To generate these names as global symbols, invoke the macro with the arguments <= => and
<::>, as follows:
simple ..EQU=<==> ..COL=<::>
This invocation results in the following definitions:
bits == 4
tst$b_field1::
blkb 1
The MACRO output routine always generates a size variable for bitfields, aggregates,
arrays, and character strings, using the tag S_ preceding the output identifier.
The /VMS_DEVELOPMENT qualifier on the SDL command produces special forms of macros
for entry point declarations.
Note
1. Each identifier produces a constant assignment equal to the byte offset of the item, as
follows:
name = offset-value
Offset-value is the byte offset relative to the origin of the level-1 aggregate. A constant
assignment of the following form gives the size in bytes for aggregates, arrays, and
character strings:
prefix$_name = byte-size

MACRO Translation Summary
2. If /VMS_DEVELOPMENT was specified, the CONSTANT x EQUALS STRING "s" declaration
translates to the following:
.SAVE
.PSECT module_name_STRCONST PIC,CON,REL,NOEXE,GBL,SHR,RD,NOWRT,LONG
$EQU S_x size
$DEF x .ASCII /s/
.RESTORE
If /NOVMS_DEVELOPMENT was specified (default), this declaration translates to the
following:
.SAVE
.PSECT module_name STRCONST PIC,CON,REL,NOEXE,GBL,SHR,RD,NOWRT,LONG
S_x ..equ’size
x’..col’ .ASCII /s/
.RESTORE
where size represents the number of bytes in the string.
Note:
• Ifthestringcontainsthe/character,anotherdelimitercharacter(pulledfroma
priority list) is used.
• IfthelengthofthePSECTnameexceeds31charactersafterappending_STRCONST,
the module_name is truncated appropriately before appending _STRCONST.

Pascal Translation Summary
Pascal Translation Summary
The following table shows the OpenSDL to Pascal language translation summary.
OpenSDL Declaration Pascal Output
MODULE name IDENT string (*** MODULE name IDENT string ***)
Note that when /MODULE is used, a Pascal MODULE
statement of the form MODULE name; is generated.
/* comment (* comment *)
CONSTANT x
EQUALS n; CONST x = n;
EQUALS STRING "s"; CONST x = ’s’;
ENTRY [ASYNCHRONOUS] FUNCTION
[ASYNCHRONOUS] PROCEDURE
PARAMETER (type,...) (formal param_list)
ANY %REF param-name: [UNSAFE] ARRAY [$l1..$u1:INTEGER]
OF $UBYTE
DESCRIPTOR [CLASS_S] for scalars;
[CLASS_S] for CHARACTER LENGTH 1;
[CLASS_A] for nonscalars;
%DESCR for fixed-length VARYING;
RTL_STR_DESC PACKED ARRAY [$l1..$u1:INTEGER] OF CHAR;
IN Default semantics (unless overridden by OUT)
OUT (or IN OUT) VAR, except for CHARACTER LENGTH * and ANY (which
generate %REF)
NAMED param-name Parameter name. If none is given, names will be generated of
the form $P1,...$Pn.
VALUE %IMMED
REFERENCE %REF for CHARACTER LENGTH * and ANY; VAR for all
others if mode OUT or IN OUT; otherwise (IN only) default
mechanism
DEFAULT n := %IMMED value
LIST If OPTIONAL is not specified, generates one required parameter
followed by a parameter with the [LIST] attribute;
if OPTIONAL is specified, only the parameter with [LIST] is
generated.
OPTIONAL :=%IMMED 0
TYPENAME type-name n/a
RETURNS return-data-type FUNCTION name : data-type;
NAMED param-name n/a

Pascal Translation Summary
OpenSDL Declaration Pascal Output
VARIABLE n/a
ALIAS internal-name Results in [EXTERNAL (entry-name)] and internal-name being
used as entry-name
LINKAGE n/a
TYPENAME type-name n/a
STRUCTURE RECORD
UNION RECORD CASE INTEGER OF
0: ...
.
.
n: ...
BYTE [SIGNED] $BYTE—[BYTE] -128..127
INTEGER_BYTE [SIGNED] $BYTE—[BYTE] -128..127
WORD [SIGNED] $WORD—[WORD] -32768..32767
INTEGER_WORD [SIGNED] $WORD—[WORD] -32768..32767
LONGWORD [SIGNED] INTEGER
INTEGER_LONG [SIGNED] INTEGER
INTEGER [SIGNED] INTEGER
INTEGER_HW [SIGNED] $QUAD—[QUAD,UNSAFE]RECORD L0: UNSIGNED; L1:
INTEGER; END for /ALPHA
INTEGER for /VAX
HARDWARE_INTEGER [SIGNED] $QUAD for /ALPHA
$QUAD for /ALPHA, INTEGER for /VAX
QUADWORD [SIGNED] $QUAD
INTEGER_QUADWORD [SIGNED] $QUAD
OCTAWORD [SIGNED] $OCTA—[OCTA,UNSAFE]RECORD L0,L1,L2: UNSIGNED; L3:
INTEGER; END
BYTE UNSIGNED $UBYTE—[BYTE] 0..255
INTEGER_BYTE UNSIGNED $UBYTE—[BYTE] 0..255
WORD UNSIGNED $UWORD—[WORD] 0..65535
INTEGER_WORD UNSIGNED $UWORD—[WORD] 0..65535
LONGWORD UNSIGNED UNSIGNED
INTEGER_LONG UNSIGNED UNSIGNED
INTEGER UNSIGNED UNSIGNED
INTEGER_HW UNSIGNED $UQUAD—[QUAD,UNSAFE]RECORD L0,L1: UNSIGNED;
END for /ALPHA
INTEGER for /VAX

Pascal Translation Summary
OpenSDL Declaration Pascal Output
HARDWARE_INTEGER UNSIGNED $UQUAD for /ALPHA
INTEGER for /VAX
QUADWORD UNSIGNED $UQUAD
INTEGER_QUADWORD UNSIGNED $UQUAD
OCTAWORD UNSIGNED $UOCTA—[OCTA,UNSAFE]RECORD L0,L1,L2,L3: UNSIGNED;
END
F_FLOATING SINGLE
D_FLOATING DOUBLE (D_FLOAT$$TYPE if the logical name SDLPASCAL$FLAG
is defined)
G_FLOATING DOUBLE (G_FLOAT$$TYPE if the logical name SDLPASCAL$FLAG
is defined)
H_FLOATING QUADRUPLE
F_FLOATING COMPLEX $UQAD
D_FLOATING COMPLEX $UOCTA
G_FLOATING COMPLEX $UOCTA
H_FLOATING COMPLEX $UOCTAQUAD –[OCTA(2),UNSAFE]RECORD L0,L1,L3,L4,L5,L6,L7:UNSIGNED;
END;
DECIMAL PRECISION (p,q) PACKED ARRAY [1..p+2-mod(p,2)] OF $PACKED_DEC
$PACKED_DEC—[BIT(4),UNSAFE] 0..15
BITFIELD LENGTH n $BIT1—[BIT(1), UNSAFE] BOOLEAN
$BITn—[BIT(n),UNSAFE] 0..2**n-1
MASK CONST prefixM_name = mask-value;
SIGNED n/a
CHARACTER CHAR
LENGTH n PACKED ARRAY [1..n] OF CHAR
LENGTH * PACKED ARRAY [$l..$u] OF CHAR
or VARYING [$m] OF CHAR (if VARYING is also specified)
VARYING VARYING [n] OF CHAR
or VARYING [$m] OF CHAR (if LENGTH * is also specified)
ADDRESS (object-type) ^object-type
If object type is not supplied, generates $DEFPTR, which is
defined as ^$DEFTYP; $DEFTYP is defined as [UNSAFE]
INTEGER
POINTER (object-type) ^object-type
If object type is not supplied, generates UNSIGNED
POINTER_LONG (object-type) ^object-type
If object type is not supplied, generates UNSIGNED

Pascal Translation Summary
OpenSDL Declaration Pascal Output
POINTER_HW (object-type) $QUAD for /ALPHA
INTEGER for /VAX
HARDWARE_ADDRESS (objecttype)
$QUAD for /ALPHA
INTEGER for /VAX
POINTER_QUAD (object-type) $QUAD
BOOLEAN BOOLEAN
user-type-name user-type-name
Default storage class TYPE
COMMON storage class [COMMON]
GLOBAL storage class [EXTERNAL]
with /GLOBALDEF [GLOBAL]
BASED pointer-name TYPE pointer-name = structure-name
TYPEDEF n/a
name DIMENSION [lbound:]hbound ARRAY [lbound..hbound] OF data type; if lbound is not supplied,
it defaults to 1
ORIGIN member-name n/a
Notes
1. When the /MODULE (default) qualifier is used, OpenSDL generates the Pascal
MODULE statement followed by a block of data type definitions. Both of these items
are omitted when /NOMODULE is specified. This behavior facilitates combining multiple
OpenSDL-generated Pascal output files into a single module.
2. Where type names are required (for example, in parameter lists, function return types,
and pointer data types), they will be generated in a TYPE block at the beginning of the
module. Names have the form module-name$$TYPn, where module-name is truncated to
20 characters if necessary, and n is an integer beginning at 1 and incremented by 1 for
each type generated in a module.
3. Bitfields cannot be more than 32 bits in length, so type names giving the appropriate
subranges will be generated for each possible bitfield size. Bitfields of length 1 are a
special case.
4. The mask-value generated by OpenSDL for the MASK option of the BITFIELD data type is
an integer.
5. OpenSDL generates only single-level records for Pascal. Thus, you can avoid writing
many long intermediate field names in the Pascal source program. If the outer level
is a structure, a PACKED RECORD is typically declared. If the outer level is a union, a
PACKED RECORD CASE INTEGER is declared.
In the case of multiple levels of structures or unions in OpenSDL, the entire aggregate is
transformed into a PACKED RECORD CASE INTEGER. The intermediate field-names are
themselves declared as BYTE_DATA fields. This translation scheme may result in several
fields in the record having the same name.

PL/I Translation Summary
PL/I Translation Summary
The following table shows the OpenSDL to PL/I language translation summary.
OpenSDL Declaration PL/I Output
MODULE name IDENT string /*** MODULE name IDENT string ***/
/* comment /*comment*/
CONSTANT x
EQUALS n; %REPLACE x BY n;
EQUALS STRING "s"; %REPLACE x BY ’s’;
ENTRY ENTRY
PARAMETER (type,...) (parameter-descriptor,...)
ANY ANY
DESCRIPTOR DESCRIPTOR or CHARACTER(*) for CHARACTER data type
RTL_STR_DESC ANY CHARACTER(*)
IN n/a
OUT n/a
NAMED param-name n/a
VALUE VALUE
REFERENCE n/a
DEFAULT n n/a
LIST LIST
OPTIONAL OPTIONAL or OPTIONAL TRUNCATE
TYPENAME type-name Special VMS TYPENAME values are recognized.
RETURNS return-data-type RETURNS (returns-descriptor)
NAMED param-name n/a
VARIABLE OPTIONS(VARIABLE)
ALIAS internal-name n/a
LINKAGE n/a
TYPENAME type-name Special VMS TYPENAME values are recognized.
STRUCTURE Structure declaration. An AGGREGATE declaration is always
assigned a level number of 1; subsequent subaggregates are
assigned level numbers 2, 3, and so on.
UNION UNION
BYTE [SIGNED] FIXED BINARY(7)
INTEGER_BYTE [SIGNED] FIXED BINARY(7)
WORD [SIGNED] FIXED BINARY(15)
INTEGER_WORD [SIGNED] FIXED BINARY(15)

PL/I Translation Summary
OpenSDL Declaration PL/I Output
LONGWORD [SIGNED] FIXED BINARY(31)
INTEGER_LONG [SIGNED] FIXED BINARY(31)
INTEGER [SIGNED] FIXED BINARY(31)
INTEGER_HW [SIGNED] (2) FIXED BIN(31) for /ALPHA
FIXED BIN(31) for /VAX
HARDWARE_INTEGER [SIGNED] (2) FIXED BIN(31) for /ALPHA
FIXED BIN(31) for /VAX
QUADWORD [SIGNED] BIT(64) ALIGNED
INTEGER_QUAD [SIGNED] BIT(64) ALIGNED
OCTAWORD [SIGNED] BIT(128) ALIGNED
BYTE UNSIGNED BIT(8) ALIGNED
FIXED BINARY(7) for /PLI_DEVELOPMENT
INTEGER_BYTE UNSIGNED BIT(8) ALIGNED
FIXED BINARY(7) for /PLI_DEVELOPMENT
WORD UNSIGNED BIT(16) ALIGNED
FIXED BINARY(15) for /PLI_DEVELOPMENT
INTEGER_WORD UNSIGNED BIT(16) ALIGNED
FIXED BINARY(15) for /PLI_DEVELOPMENT
LONGWORD UNSIGNED BIT(32) ALIGNED
FIXED BINARY(31) for /PLI_DEVELOPMENT
INTEGER_LONG UNSIGNED BIT(32) ALIGNED
FIXED BINARY(31) for /PLI_DEVELOPMENT
INTEGER UNSIGNED BIT(32) ALIGNED
FIXED BINARY(31) for /PLI_DEVELOPMENT
INTEGER_HW UNSIGNED BIT(64) ALIGNED for /ALPHA
(2) FIXED BIN(31)/ALPHA/PLI_DEVELOPMENT
BIT(32) ALIGNED for /VAX
FIXED BIN(31)/VAX/PLI_DEVELOPMENT
HARDWARE_INTEGER UNSIGNED BIT(64) ALIGNED for /ALPHA
(2) FIXED BIN(31)/ALPHA/PLI_DEVELOPMENT
BIT(32) ALIGNED for /VAX
FIXED BIN(31)/VAX/PLI_DEVELOPMENT
QUADWORD UNSIGNED BIT(64) ALIGNED
INTEGER_QUAD UNSIGNED BIT(64) ALIGNED
OCTAWORD UNSIGNED BIT(128) ALIGNED
F_FLOATING FLOAT BINARY (24)

PL/I Translation Summary
OpenSDL Declaration PL/I Output
D_FLOATING FLOAT BINARY(53)
G_FLOATING FLOAT BINARY(53)
H_FLOATING FLOAT BINARY(113)
F_FLOATING COMPLEX ANY except as a
D_FLOATING COMPLEX - function return type or union
G_FLOATING COMPLEX - type of a structure member
H_FLOATING COMPLEX - array type
In these cases, respective translations are:
BIT(64)
BIT(128)
BIT(128)
BIT(256)
DECIMAL PRECISION (p,q) DECIMAL (p,q)
BITFIELD LENGTH n BIT(n)
MASK %REPLACE prefixM_name BY mask-value;
SIGNED n/a
CHARACTER CHARACTER(n)
LENGTH n CHARACTER(n)
LENGTH * CHARACTER(*)
VARYING VARYING
ADDRESS POINTER
POINTER POINTER
POINTER_LONG POINTER
POINTER_HW (2) POINTER for /ALPHA
POINTER for /VAX
HARDWARE_ADDRESS (2) POINTER for /ALPHA
POINTER for /VAX
POINTER_QUAD (2) POINTER
BOOLEAN BIT(1) ALIGNED
user-type-name data-type /* user-type-name */
Default storage class BASED attribute
COMMON storage class STATIC EXTERNAL
GLOBAL storage class GLOBALREF
with /GLOBALDEF GLOBALDEF
BASED pointer-name aggregate BASED (pointer-name)
TYPEDEF n/a

PL/I Translation Summary
OpenSDL Declaration PL/I Output
name DIMENSION [lbound:]hbound name ([lbound]:hbound)
ORIGIN member-name n/a
Notes
1. In PL/I, you can access values declared using the OpenSDL UNSIGNED keyword
by specifying the name in a POSINT built-in function. The integer value of the name will
be returned; however, this will work only if the sign bit is 0.
2. The mask value generated by OpenSDL for the MASK option of the BITFIELD data type is
a bit-string constant.
3. The OpenSDL declarations BYTE UNSIGNED, WORD UNSIGNED, and LONGWORD
UNSIGNED produce the same PL/I output as the OpenSDL declarations BYTE,
WORD, and LONGWORD, when the /VMS_DEVELOPMENT qualifier is specified.

OpenVMS DCL Translation Summary
OpenVMS DCL Translation Summary
The following table shows the OpenSDL to OpenVMS DCL language translation summary.
Since OpenVMS DCL does not understand procedures or aggregates, only constants are
translated.
OpenSDL Declaration OpenVMS DCL Output
MODULE name IDENT string $ ! MODULE name
/* comment $ ! comment
CONSTANT x
EQUALS n; x = = n
EQUALS STRING "s"; x = = "s"
ENDMODULE name $ ! ENDMODULE

SDML Translation Summary
SDML Translation Summary
SDML is not a programming language; the translation is intended to be used as input to
software manuals.
For every AGGREGATE STRUCT files named aggregate-name_PIC.SDML and aggregatename_
TBL.SDML are generated. Those files also include the constants defined in the SDL file
before the AGGREGATE.
AGGREGATE UNIONs and ITEMs are written into files named PICFILE.DAT and
TBLFILE.DAT. If an SDL file contains more than one ITEM or UNION, multiple versions
of PICFILE.DAT and TBLFILE.DATE will be written.
‘‘PIC’’ files contain drawings, where every member of an AGGREGATE is drawn according to
its size and position. BITFIELDs are not drawn, their size and position are respected only
partly; members following BITFIELDS are not always positioned correctly. ‘‘TBL’’ files contain
tables with a row for every member of an AGGREGATE.
The HARDWARE_INTEGER and COMPLEX data types are not supported by the SDML
backend.
ENTRY declarations are also not supported by the SDML backend.

DECTPU Translation Summary
DECTPU Translation Summary
The following table shows the OpenSDL to DECTPU language translation summary. Since
DECTPU does not understand procedures or aggregates, only constants are translated.
OpenSDL Declaration DECTPU Output
MODULE name IDENT string MODULE name
/* comment ! comment
CONSTANT x
EQUALS n; CONSTANT x := n;
EQUALS STRING "s"; CONSTANT x := "s";
ENDMODULE name ENDMODULE

UIL Translation Summary
UIL Translation Summary
The following table shows the OpenSDL to UIL language translation summary. Since UIL does
not understand procedures or aggregates, only constants are translated.
OpenSDL Declaration UIL Output
MODULE name IDENT string ! MODULE name
/* comment ! comment
CONSTANT x
EQUALS n; VALUE x : n;
EQUALS STRING "s"; VALUE x : "s";
ENDMODULE name ! ENDMODULE


@appendix
ASCII Character Set
The following table shows the ASCII character set referred to in Section 3.3.

@multitable @columnfractions .20 .20 .60
@headitem Character @tab ASCII Decimal @tab Hexadecimal
@item NUL @tab 000 @tab 00
@item SOH @tab 001 @tab 01
@item STX @tab 002 @tab 02
@item ETX @tab 003 @tab 03
@item EOT @tab 004 @tab 04
@item ENQ @tab 005 @tab 05
@item ACK @tab 006 @tab 06
@item BEL @tab 007 @tab 07
@item BS @tab 008 @tab 08
@item HT @tab 009 @tab 09
@item LF @tab 010 @tab 0A
@item VT @tab 011 @tab 0B
@item FF @tab 012 @tab 0C
@item CR @tab 013 @tab 0D
@item SO @tab 014 @tab 0E
@item SI @tab 015 @tab 0F
@item DLE @tab 016 @tab 10
@item DC1 @tab 017 @tab 11
@item DC2 @tab 018 @tab 12
@item DC3 @tab 019 @tab 13
@item DC4 @tab 020 @tab 14
@item NAK @tab 021 @tab 15
@item SYN @tab 022 @tab 16
@item ETB @tab 023 @tab 17
@item CAN @tab 024 @tab 18
@item EM @tab 025 @tab 19
@item SUB @tab 026 @tab 1A
@item ESC @tab 027 @tab 1B
@item FS @tab 028 @tab 1C
@item GS @tab 029 @tab 1D
@item RS @tab 030 @tab 1E
@item US @tab 031 @tab 1F
@item SP @tab 032 @tab 20
@item ! @tab 033 @tab 21
@item " @tab 034 @tab 22
@item @hash @tab 035 @tab 23
@item $ @tab 036 @tab 24
@item % @tab 037 @tab 25
@item & @tab 038 @tab 26
@item ’ @tab 039 @tab 27
@item ( @tab 040 @tab 28
@item ) @tab 041 @tab 29
@item * @tab 042 @tab 2A
@item + @tab 043 @tab 2B
@item @comma @tab 044 @tab 2C
@item - @tab 045 @tab 2D
@item . @tab 046 @tab 2E
@item / @tab 047 @tab 2F
@item 0 @tab 048 @tab 30
@item 1 @tab 049 @tab 31
@item 2 @tab 050 @tab 32
@item 3 @tab 051 @tab 33
@item 4 @tab 052 @tab 34
@item 5 @tab 053 @tab 35
@item 6 @tab 054 @tab 36
@item 7 @tab 055 @tab 37
@item 8 @tab 056 @tab 38
@item 9 @tab 057 @tab 39
@item : @tab 058 @tab 3A
@item ; @tab 059 @tab 3B
@item < @tab 060 @tab 3C
@item = @tab 061 @tab 3D
@item > @tab 062 @tab 3E
@item ? @tab 063 @tab 3F
@item @@ @tab 064 @tab 40
@item A @tab 065 @tab 41
@item B @tab 066 @tab 42
@item C @tab 067 @tab 43
@item D @tab 068 @tab 44
@item E @tab 069 @tab 45
@item F @tab 070 @tab 46
@item G @tab 071 @tab 47
@item H @tab 072 @tab 48
@item I @tab 073 @tab 49
@item J @tab 074 @tab 4A
@item K @tab 075 @tab 4B
@item L @tab 076 @tab 4C
@item M @tab 077 @tab 4D
@item N @tab 078 @tab 4E
@item O @tab 079 @tab 4F
@item P @tab 080 @tab 50
@item Q @tab 081 @tab 51
@item R @tab 082 @tab 52
@item S @tab 083 @tab 53
@item T @tab 084 @tab 54
@item U @tab 085 @tab 55
@item V @tab 086 @tab 56
@item W @tab 087 @tab 57
@item X @tab 088 @tab 58
@item Y @tab 089 @tab 59
@item Z @tab 090 @tab 5A
@item [ @tab 091 @tab 5B
@item @backslash @tab 092 @tab 5C
@item ] @tab 093 @tab 5D
@item ^ @tab 094 @tab 5E
@item _ @tab 095 @tab 5F
@item ‘ @tab 096 @tab 60
@item a @tab 097 @tab 61
@item b @tab 098 @tab 62
@item c @tab 099 @tab 63
@item d @tab 100 @tab 64
@item e @tab 101 @tab 65
@item f @tab 102 @tab 66
@item g @tab 103 @tab 67
@item h @tab 104 @tab 68
@item i @tab 105 @tab 69
@item j @tab 106 @tab 6A
@item k @tab 107 @tab 6B
@item l @tab 108 @tab 6C
@item m @tab 109 @tab 6D
@item n @tab 110 @tab 6E
@item o @tab 111 @tab 6F
@item p @tab 112 @tab 70
@item q @tab 113 @tab 71
@item r @tab 114 @tab 72
@item s @tab 115 @tab 73
@item t @tab 116 @tab 74
@item u @tab 117 @tab 75
@item v @tab 118 @tab 76
@item w @tab 119 @tab 77
@item x @tab 120 @tab 78
@item y @tab 121 @tab 79
@item z @tab 122 @tab 7A
@item @{ @tab 123 @tab 7B
@item | @tab 124 @tab 7C
@item @} @tab 125 @tab 7D
@item ~ @tab 126 @tab 7E
@item DEL @tab 127 @tab 7F
@end multitable

The following table describes the ASCII character abbreviations used in the previous table.

@multitable @columnfractions .20 .20 .20 .40
@headitem Characters @tab Description @tab Characters @tab Description
@item NUL @tab Null @tab DLE @tab Data Link Escape
@item SOH @tab Start of Heading @tab DC1 @tab Device Control 1
@item STX @tab Start of Text @tab DC2 @tab Device Control 2
@item ETX @tab End of Text @tab DC3 @tab Device Control 3
@item EOT @tab End of Transmission @tab DC4 @tab Device Control 4
@item ENQ @tab Enquiry @tab NAK @tab Negative Acknowledge
@item ACK @tab Acknowledge @tab SYN @tab Synchronous Idle
@item BEL @tab Bell @tab ETB @tab End of Transmission Block
@item BS @tab Backspace @tab CAN @tab Cancel
@item HT @tab Horizontal Tabulation @tab EM @tab End of Medium
@item LF @tab Line Feed @tab SUB @tab Substitute
@item VT @tab Vertical Tab @tab ESC @tab Escape
@item FF @tab Form Feed @tab FS @tab File Separator
@item CR @tab Carriage Return @tab GS @tab Group Separator
@item SO @tab Shift Out @tab RS @tab Record Separator
@item SI @tab Shift In @tab US @tab Unit Separator
@item SP @tab Space @tab DEL @tab Delete
@end multitable

@node Index
@unnumbered Index

@printindex cp

@bye