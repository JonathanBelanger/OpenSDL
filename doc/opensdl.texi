\input texinfo    @c -*-texinfo-*-
@comment $Id@w{$}
@comment %**start of header

@include version.texi

@settitle Open Structure Definition Langauage @value{VERSION}

@allowcodebreaks false
@setchapternewpage odd
@firstparagraphindent none
@paragraphindent none

@copying
This manual is for the OpenSDL Language and Processor Utility, @value{VERSION}

Copyright @copyright{} 1985, 1987, 1989, 2007, 2018

Permission is granted to the source code and this manual, with no warrantee of
any kind, implied or otherwise.
@end copying

@titlepage
@title Guide to the Open Structure Definition Language Utility





@strong{This manual describes the Open Structure Definition Language (OpenSDL)
and the OpenSDL translator.}





@multitable @columnfractions .40 .60
@item @strong{Revision/Update Information}: @tab This revised manual supersedes
HP and VAX SDL (Structure Definition Language) Version 3.2.
@item @strong{Operating System and Version}: @tab @value{OS} @value{OSVERSION}
or later
@item @strong{Software Version}: @tab OpenSDL Version @value{VERSION}
@end multitable

@author Jonathan D. Belanger

@page
@insertcopying
This manual is for OpenSDL (version @value{VERSION}, @value{UPDATED}).

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant Sections, with no
Front-Cover Texts, and with no Back-Cover Texts.  A copy of the license is
included in the section entitled ``GNU Free Documentation License".

@strong{First Printing, June 1981}@*
@strong{Revised, June 1985}@*
@strong{Revised, November 1987}@*
@strong{Revised, May 1989}@*
@strong{Revised, October 2007}@*
@strong{Revised, November 2018}@*

Published by Digital Equipment Corporation, Compaq Computer Corporation,
Hewlett-Packard Corporation, VMS Software, Inc., and Jonathan D. Belanger
@end titlepage
@contents

@node Examples
@unnumbered Examples
@listoffloats Example

@node Figures
@unnumbered Figures
@listoffloats Figure

@node Tables
@unnumbered Tables
@listoffloats Table

@ifnottex
@node Top
@top OpenSDL Guide
This manual describes the Open Structure Definition Language (OpenSDL) and the
OpenSDL translator

@menu
* Preface:: 
* Chapter 1:: provides a brief overview of OpenSDL and the translation
process.@*
* Chapter 2:: describes how to create, edit, and process an OpenSDL source file
using any text ditor and the OpenSDL command options.@*
* Chapter 3:: describes the OpenSDL language elements that compose OpenSDL
declarations.@*
* Chapter 4:: describes the function and format of OpenSDL declarations.@*
* Appendix A:: provides a list and descriptions of OpenSDL diagnostic
messages.@*
* Appendix B:: shows translation summaries for all output languages supported
by OpenSDL.@*
* Appendix C:: is a table showing the ASCII character set.@*
* Copying::
@end menu
@end ifnottex

@unnumbered Preface
@cindex preface

This manual describes the Open Structure Definition Language (OpenSDL) and the
OpenSDL translator for use on any compatible operating systems.  OpenSDL source
code can be translated to output files in one or more target programming
languages.  OpenSDL is suitable for systems and application programming
environments that use executable programs consisting of modules written in one
or multiple programming languages.

@unnumberedsec Intended Audience

This manual is intended for users who are familiar with one or more programming
languages and who are currently involved in the design and development of
multilanguage programming applications; however, users are not required to have
previous experience with OpenSDL in order to use this manual.

@unnumberedsec Document Structure

This manual contains the following chapters and appendixes.

Chapter 1 provides a brief overview of OpenSDL and the translation process.@*
Chapter 2 describes how to create, edit, and process an OpenSDL source file.@*
Chapter 3 describes the OpenSDL language elements that compose OpenSDL
declarations.@*
Chapter 4 describes the function and format of OpenSDL declarations.@*
Appendix A provides a list and descriptions of OpenSDL diagnostic messages.@*
Appendix B shows translation summaries for all output languages supported by
OpenSDL.@*
Appendix C is a table showing the ASCII character set.@*

If OpenSDL is installed on your system, an online copy of this manual is
contained in the @strong{help/manpage} folders.  You can print a copy of the
manual file on a @strong{PostScript} or other supported printer.

@unnumberedsec Associated Documents

If OpenSDL is installed on your system, an online example of an OpenSDL source
file is contained in @file{example.sdl} in the public directory/folder
@file{/usr/lib/opensdl/examples}.

@page

@unnumberedsec Conventions

The following conventions are used in this document.

@multitable @columnfractions .3 .7
@headitem Convention @tab Meaning

@item @code{@{ STRUCTURE @}} @* @code{@{ UNION @}}
@tab Stacked items within braces indicate that you must select one of the
items.

@item @code{[ ]}
@tab Simple square brackets indicate that the enclosed item(s) are optional.

@item @code{[ COMMON ]} @* @code{[ GLOBAL ]}
@tab Stacked items within brackets indicate that only one item may be selected.

@item @code{MODULE name;}
@tab Names shown in uppercase letters in examples and format descriptions are
OpenSDL keywords that must be entered as shown.  Names and syntactic elements
shown in lowercase letters represent user-specified names and identifiers.

@item @code{arg,@dots{}}
@tab A comma followed by an ellipsis means that the preceding item may be
repeated one or more times, with commas separating two or more items.

@item @code{.} @* @code{.} @* @code{.} @*
@tab A vertical ellipsis in an example or figure indicates that not all the
statements or elements are shown.

@item @code{@strong{common storage}}
@tab Boldface words in text are used to introduce or define a new term, or to
refer to a term used in a code example.

@item @command{$ opensdl user.sdl}
@tab In interactive examples, user input is @strong{bold and mon-spaced}.
@end multitable

@unnumberedsec Software and Documentation Reporting and Distribution

If OpenSDL is installed on your system, an online copy of this manual is
contained in the @file{/usr/lib/opensdl/doc} folder.

@page

@unnumberedsec Summary of Technical Changes

The technical changes for this version of OpenSDL are described in the online
release notes file @file{opensdl@emph{0xy}.release_notes} in
@file{/usr/lib/opensdl/doc}.

The following is a summary of technical changes in OpenSDL Version
@value{VERSION}.  (For detailed descriptions and a summary of bug fixes, see
the online release notes file.)

@itemize @bullet

@item @code{DIMENSION *} now yields @code{name[]} instead of @code{name[1]} in
C language output.

@item The header that is optionally included at the beginning of an output file
now indicates that the file was created by OpenSDL instead of "HP" SDL or
"VAX" SDL.

@item The @code{DEFAULT} clause may now be specified for a parameter of an
@code{AGGREGATE} type (i.e. @code{STRUCTURE} or @code{UNION}).

@end itemize

@unnumberedsec New Features

The following is a summary of new features in OpenSDL Version @value{VERSION}.
(For detailed descriptions, see the online release notes file
@file{opensdl@emph{0xy}.release_notes} in @file{/usr/lib/opensdl/doc}.

@itemize @bullet
@item User-defined data types --- OpenSDL provides the @code{TYPEDEF} keyword
to allow you to define additional data types in some languages.  @code{TYPEDEF}
behaves like a Storage Class.

@item Entry point return types --- This feature extends the syntax of the
@code{ENTRY} statement to allow you to specify a user-defined data type as a
return type.

@item The @code{CONSTANT} declaration now includes string constants.

@item Conditional OpenSDL compilation --- OpenSDL now allows you to compile a
section of OpenSDL code conditionally, depending on whether output is being
generated for a particular language or not.

@item Text pass-through --- OpenSDL provides this feature to allow you to pass
literal text through to the output language file without translation.  This
feature allows language-specific constructs that cannot be represented in
OpenSDL to be emitted.

@item DECLARE statement --- OpenSDL provides this statement to allow you to
declare a data item of a type that you define, which may be unknown in the
current OpenSDL compilation.

@item @command{-suppress} qualifier --- OpenSDL provides this command line
qualifier to allow you to suppress the addition of prefixes and/or tags to
names.

@item @code{RADIX} modifier --- OpenSDL provides this modifier on
@code{CONSTANT} definitions to allow constant values to be written in Decimal
(@code{DEC}), Octal (@code{OCT}), or Hexadecimal (@code{HEX}) format.

@item @code{ENUMERATE} modifier --- OpenSDL provides this modifier on
@code{CONSTANT} definitions to generate enumerations instead of constants.  If
the output language does not support enumerations, this modifier is ignored.

@end itemize

@comment Chapert 1 --- Overview
@node Overview
@chapter Overview
@cindex Overview

The Open Structure Definition Language (OpenSDL) is used to write source
statements that describe data structures and that can be translated to source
statements in other languages.  You can include the resulting output files in a
corresponding target language program for subsequent compilation.

Because OpenSDL is compiler- and language-independent, it is particularly
useful for maintaining multilanguage implementations.  For example, you can
create and later modify a single OpenSDL source file that can be translated to
multilanguage output files; any number of these output files can then be
included in one or several multilanguage programming applications.

OpenSDL supports the following OpenVMS language:
@itemize @bullet
@item C/C++
@end itemize

@section The OpenSDL Translation Process
The translation of an OpenSDL source file occurs when you issue the OpenSDL
command (@ref{Processing an OpenSDL Source File}).  The OpenSDL command
activates the OpenSDL "front-end" translator (@file{opensdl.exe}), which is
stored in the @file{/usr/bin} directory/folder.  The front end parses the
OpenSDL source code and, if you specify the @command{-lang} qualifier, passes
the parsed data to one or more of the OpenSDL "back-end" translators.

Each back end translates only those OpenSDL declarations that can (or need) be
expressed in that language.  OpenSDL declarations, described in detail in
Chapter 4, translate to the following types of data items:

@itemize @bullet
@item Scalar or dimensioned scalar data items (@code{ITEM} declarations)
@item Nonscalar data items (@code{AGGREGATE} and subaggregate declarations)
@item Named constants (@code{CONSTANT} declarations)
@item External entries(@code{ENTRY} declarations)
@end itemize

@ref{OpenSDL Translation Process} shows each step in the OpenSDL translation
process, and the key following the example describes each step.
@ref{Processing an OpenSDL Source File} describes the OpenSDL command in
detail.

@float Figure, OpenSDL Translation Process

@enumerate
@item Create a properly formatted OpenSDL file (@file{.sdl}) containing a 
@code{MODULE} and @code{END_MODULE}, and one or more @code{CONSTANT},
@code{ITEM}, or @code{AGGREGATE @dots{}@emph{member}@dots{} END} statements.

@item Process the file created above using the4 @command{opensdl} command,
noting any errors that may be reported.

@item If errors are reported, then open the file in your favorite text editor
and make corrections as appropriate.  Then go back to step 2.

@item Verify that the resulting output file(s) contain the definitions
expected.  If not, then make corrections and reprocess the file.

@item Use the resulting output file(s) within the code they are defined to be
used.
@end enumerate
@end float

Key to @ref{OpenSDL Translation Process}:
@enumerate

@item The front end (@file{opensdl.exe}) parses the statements contained in the
OpenSDL source file test.sdl as a result of issuing the OpenSDL command in the
following way:

@enumerate a
@item @command{$ opensdl -lang:cc test.sdl}@*
If you specify the @command{-lang} qualifier (for example, @command{-lang:cc}),
the front end parses the source code and passes the parsed data to the back end
for the specified language.
@end enumerate

@item The specified back end (@command{cc}) produces an output file with the
default file type of @file{.h}.
@end enumerate

You can specify any or all of the language options on the @command{-lang}
qualifier, and OpenSDL produces separate output files for each language
specified.

@section Description of a Sample OpenSDL Source File

@ref{Sample OpenSDL Source File} is a typical OpenSDL source file, and the key
following the example describes each of the numbered language elements.
(Chapter 3 describes all the language elements in detail.)  You may want to
familiarize yourself with this example because it shows the source file you
will be creating in the tutorial in @ref{Getting Started with OpenSDL}.

@comment Example 1.1 --- Example, Sample OpenSDL Source File
@node Example_1_1
@float Example, Sample OpenSDL Source File
@example
MODULE opr_descriptor IDENT "Version 2.0";@sup{1}

/* define constants and node structure for operators@sup{2}
#max_args = 10;@sup{3}

CONSTANT (fixed_binary,floating,char,untyped) EQUALS 1 INCREMENT 1;@sup{4}

AGGREGATE operator STRUCTURE@sup{5}
    PREFIX "opr_";@sup{6}
    flink ADDRESS;@sup{7}
    blink ADDRESS;
    opcount WORD;
    optype CHARACTER LENGTH 1;
    id WORD;
    operands LONGWORD DIMENSION 0:#max_args-1;@sup{8}
END operator;

#opsize = .;@sup{9}

CONSTANT opr_node_size EQUALS #opsize / 2;

ITEM current_node_ptr@sup{10} ADDRESS@sup{11} GLOBAL;@sup{12}

END_MODULE opr_descriptor@sup{13};
@end example
@end float

@enumerate
@item All OpenSDL declarations are grouped within modules, and you must assign
a name to each module.  The @code{IDENT} keyword precedes any commented
information that you may want to add to describe the @code{MODULE} declaration.

@item Output comments begin with a slash and an asterisk (/*) and are written
to the language output file unless the @command{-nocomments} qualifier is
specified.

@item Local symbols begin with a pound sign (@code{#}) and are not written to
the output file.  Local symbols may be used to express values in declarations.
For example, the symbol @code{#max_args} is used in the declaration of the
array operands.

@item @code{CONSTANT} declarations produce declarations of named constants.
When the @code{INCREMENT} option and an increment value are specified, OpenSDL
automatically increments the initial value for each of the declared output
constants.  In the example, @code{fixed_binary} will be assigned the value
@code{1}, @code{floating} will be assigned the value @code{2}, and so on.

@item @code{AGGREGATE} declarations define data structures and their members.

@item When the @code{PREFIX} option and a prefix are specified, OpenSDL
concatenates the prefix and a data type code to the declared aggregate member
names in the language output files.  Compare these aggregate member name
declarations with the C output shown in
@ref{C Output File for the Sample OpenSDL Source File}.

@item Aggregate members are declared using reserved OpenSDL data type keywords.

@item An aggregate member or a scalar data item can be declared to be an array
by specifying the @code{DIMENSION} option.  In this example, the array operands
has @code{10} elements, with subscripts 0 through 9.

@item The period (@code{.}) represents the current byte offset within
an @code{AGGREGATE} declaration.  The local symbol assignment
@code{#opsize = .;} captures the size of the constant portion of the structure
operator.  The value of this local symbol is then used in the declaration of
the constant @code{opr_node_size}.

@item @code{ITEM} declarations, such as the declaration of
@code{current_node_ptr}, define scalar data items.

@item The @code{ADDRESS} keyword specifies a data type that is an address, or
pointer.

@item The @code{GLOBAL} keyword specifies global storage to override the
default language storage class for an @code{ITEM} or an @code{AGGREGATE}
declaration.

@item The @code{END_MODULE} keyword ends a @code{MODULE} declaration; you may
optionally specify the @code{MODULE} name after the @code{END_MODULE} keyword.
@end enumerate

@page

@ref{C Output File for the Sample OpenSDL Source File} shows the C/C++ language
output file that results from translation of the OpenSDL source file shown in
@ref{Sample OpenSDL Source File}.

Chapter 3 describes all the OpenSDL language elements, and Chapter 4 describes
the function and format of each of the OpenSDL declarations.

@float Example, C Output File for the Sample OpenSDL Source File
@smallexample
/******************************************************************************/
/* Created 14-NOV-2018 14:18:38 by OpenSDL V3.4-20181114                      */
/* Source: 14-NOV-2018 12:18:12 /cygdrive/g/git/OpenSDL/test/example_1_2.sdl  */
/******************************************************************************/

/*** MODULE opr_descriptor IDENT = Version 2.0 ***/
#include <ctype.h>
#include <stdint.h>
#include <stdbool.h>
#include <complex.h>

#ifndef _OPR_DESCRIPTOR_
#define _OPR_DESCRIPTOR_ 1
#ifdef __cplusplus
extern "C" {
#endif
/* define constants and node structure for operators */
#define fixed_binary    1
#define floating        2
#define char    3
#define untyped 4
#define opr_s_operator  28
struct operator
{
    void *opr_a_flink;
    void *opr_a_blink;
    int16_t opr_w_opcount;
    char opr_c_optype[1];
    int16_t opr_w_id;
    int32_t opr_l_operands;
};
#define opr_node_size   14
void *current_node_ptr __attribute__ ((aligned));

#ifdef __cplusplus
}
#endif
#endif /* _OPR_DESCRIPTOR_ */
@end smallexample
@end float

@node Creating, Editing, and Processing an OpenSDL Source File
@chapter Creating, Editing, and Processing an OpenSDL Source File
@cindex Chapter 2

This chapter describes how to create an OpenSDL source file using a basic
text editor (Notepad++) and how to process your source file using the OpenSDL
command and its qualifiers.

You can use any text editor to create your source file.

@ref{Entering Source Code} describes how to use a text editor to enter OpenSDL
source code.  @ref{Getting Started with OpenSDL} provides a tutorial to get you
started using a text editor to write OpenSDL source code.  @ref{Compiling
Source Code} describes how to compile your source code.

@ref{Processing an OpenSDL Source File} describes the OpenSDL command and the
uses of the OpenSDL command qualifiers.

@section Creating an OpenSDL Source File with Notepad++

Open Notepad++ and create a file with a filename containing a @file{.sdl} file
extension.

@float Figure, Opened File
@image{FileOpen,6in,,,.jpg}
@end float

@quotation Note
If you are unable to access OpenSDL or Notepad++, contact your system manager
to ensure that they are installed on your system.
@end quotation

@ref{Entering Source Code} describes how to enter
source code using Notepad++, and @ref{Getting Started with OpenSDL} provides a
tutorial on using a text editor to create OpenSDL source code.
@ref{Compiling Source Code} describes compiling the OpenSDL source code.

@node Entering Source Code
@subsection Entering Source Code

This section provides basic information about entering OpenSDL formatter code
into a text editor.

The parser for OpenSDl ignores most whitespace characters, including @key{SP},
@key{TAB}, and @key{ENTER}.  Therefore, these characters can be used to
structure the file for easier understanding.

The OpenSDL keywords are not case sensitive.  As such, they can be enter as all
uppercase, all lowercase, or mixed (camel) case.

The identifiers associated with various OpenSDL keywords are case sensitive,
depending upon the output language.  Within the OpenSDL parser, a lowercase
@code{AGGREGATE} @emph{ID} will @strong{not} match an uppercase (or camelcase)
@code{END} @emph{ID}, and will cause a warning message to be displayed.

Identifiers that are also an OpenSDL keyword can be used, but need to be
enclosed in double-quotes (@key{"}).  Any leading and trailing spaces will be
ignored.

@node Getting Started with OpenSDL
@subsection Getting Started with OpenSDL

This section provides a tutorial on using some common tokens and placeholders
to write OpenSDL source code.  The tutorial shows expansions of the following
OpenSDL declarations and language elements:

@itemize @bullet
@item MODULE declaration
@item Output line comment
@item Local symbol declaration
@item CONSTANT declaration
@item AGGREGATE declaration
@item ITEM declaration
@end itemize

@ref{Creating a Sample OpenSDL Source File} shows the sample OpenSDL source
file described in Chapter 1.  You will be creating this sample source file in
the following tutorial.  The numbered callouts in the example correspond
to the source code you will be entering in each step.  Following each step,
intermediate and resulting screen displays highlight the source code you just
entered.

As you step through the tutorial, refer to @ref{Entering Source Code}
for specifies about entering source code in a text editor.  You can also access
online help by typing @command{opensdl -help} at the command-line prompt.

@float Example, Creating a Sample OpenSDL Source File
@example
MODULE opr_descriptor IDENT "Version 2.0";@sup{1}

/* define constants and node structure for operators@sup{2}
#max_args = 10;@sup{3}
CONSTANT@sup{4} (fixed_binary,floating,char,untyped)@sup{5} EQUALS 1@sup{6} INCREMENT 1@sup{7};
AGGREGATE@sup{8} operator@sup{9} STRUCTURE@sup{10}
    PREFIX@sup{11} "opr_";@sup{12}
    flink@sup{13} ADDRESS;@sup{14}
    blink ADDRESS;@sup{15}
    opcount WORD;@sup{15}
    optype CHARACTER LENGTH 1;@sup{15}
    id WORD;@sup{15}
    operands LONGWORD@sup{16} DIMENSION@sup{17} 0:#max_args-1;@sup{18}
END operator;@sup{19}

#opsize = .;@sup{20}

CONSTANT@sup{21} opr_node_size@sup{22} EQUALS #opsize@sup{23} / 2;@sup{24}
ITEM@sup{25} current_node_ptr ADDRESS GLOBAL@sup{26};

END_MODULE opr_descriptor;@sup{27}
@end example
@end float

The following numbered items describe and display each step.  The numbered
superscript corresponds to the equivalent numbered items.  Not all steps will
be followed by a screen capture, some steps are combined for display purposes.

@page
@enumerate
@item Type @code{MODULE opr_descriptor IDENT "Version 2.0";} on the first
line of the OpenSDL file we are creating, then hit the @key{Enter} key.

The @code{opr_descriptor}, will be used when generating files where the file
should only be included a single time to prevent a file from being included
multiple times.  When used in this way, the string written to the
@emph{identifier} will be converted to all uppercase and an underscore @key{_}
will be added to the beginning and end of the upcased string.

The value after the @code{IDENT} keyword must always be enclosed in
double-quote characters (@key{"}).  Your screen will look as follows:

@float Figure, Module Statement File
@image{ModuleStatement,5.6in,,,.jpg}
@end float

@page
@item Insert another new-line by hitting the @key{Enter} key.  Then type in
@code{/* define constants and node structure for operators} anh hit the
@key{Enter} key.

This line contains one of the three comment formats.  Comments starting with a
brace (@key{@{} will @strong{not} be written to the output file.  Comments
starting with a forward-slash followed by an asterics @key{/*} will be written
to the output file as a line comment formatted for the output language.  The
third comment fornat is the block comment, see for more information about
comments in the OpenSDL language in sections @ref{Local Comments} and
@ref{Output Comments}.  
Your screen will look as follows:

@float Figure, Output Comment File
@image{OutputComment,5.6in,,,.jpg}
@end float

@page
@item Insert another new-line, and now we are going to defined a local
variable to be used later on in this example.  Local variable name always
starts with a hash-symbol (@key{#}), followed by alpha-numeric characters, and
is case-sensitive.  Now type in @code{#max_args = 10;} (don't forget the
semicolon at the end).  Your screen will look as follows:

@float Figure, Local Variable File
@image{LocalVariable,5.6in,,,.jpg}
@end float

@page
@item Now we are going to define a set of constants that start from a
specific value to be assigned to the first constant and then incremented by
another value to be assigned to each of the following constant definitions.
Type @code{CONSTANT}, with a trailing space character.  Your screen will look
as follows:

@float Figure, Constant Start File
@image{ConstantStart,5.6in,,,.jpg}
@end float

@page
@item Now we need to defined a set of constants to be defined.  This is a comma
separater list enclosed in an open parenthesis @key{(} and close parenthesis
@key{)}. Type in @code{(fixed_binary, floating, char, untyped)}, with a
trailing space character.  Your screen will look as follows:

@float Figure, Constant List File
@image{ConstantList,5.6in,,,.jpg}
@end float

@page
@item Now we add the value to be associated with the first constant to be
defined.  Type in @code{EQUALS 1}, followed by a space character.  Your screen
will look as follows:

@float Figure, Constant First File
@image{ConstantFirst,5.6in,,,.jpg}
@end float

@page
@item Finally we add the value to be used to increment the remaining constants
to be defined.  Type in @code{INCREMENT 1;}, making sure the semi-colon has
been included, then hit the @key{Enter} key.

@float Figure, Constant Last File
@image{ConstantRest,5.6in,,,.jpg}
@end float

@page
@item Next we are going to enter an AGGREGATE definition.  Start by typing in
@code{AGGREGATE} with a trailing space character.  Your screen will look as
follows:

@float Figure, Aggregate Start File
@image{AggregateStart,5.6in,,,.jpg}
@end float

@page
@item Now type in @code{operator}, with a trailing space character.

@item Next type in @code{STRUCTURE}, entering a @key{Enter} key.

@item Add any space or tab characters to keep the code looking clean, then type
in @code{PREFIX}, followed by a trailing space.

@item Type @code{"opr_"} followed by a semi-colon (@key{;}) and @key{Enter}
key.  Your screen will look as follows:

@float Figure, Aggregate More File
@image{AggregateMore,5.6in,,,.jpg}
@end float

@page
@item Type the first member name @code{flink}, followed by a space character.

@item Now type in @code{ADDRESS;}, not forgetting to include the semi-colon
@key{;} at the end.  Type the @key{Enter} key.  Your screen will look as
follows:

@float Figure, Aggregate Member File
@image{AggregateMember,5.6in,,,.jpg}
@end float

@page
@item Follow the steps described in the previous step for the @code{blink},
@code{opcount}, @code{optype}, and @code{id} members
shown on each line in the example callout.  Note the differences in syntax
required for some of the member names.  Your screen will look as follows:

@float Figure, Aggregate Middle File
@image{AggregateMiddle,5.6in,,,.jpg}
@end float

@page
@item Now we are going to add the last member in this particular definition.
Type in @code{operands LONGWORD} followed by a space character.

@item Next type in @code{DIMENSION} followed by a space character.  Your screen
will look as follows:

@float Figure, Aggregate Nearly Done File
@image{AggregateNear,5.6in,,,.jpg}
@end float

@page
@item Now we will defined the lower and upper bounds for the @code{DIMENSION}
definition.  For languages that do not have a lower bound, the range is
adjusted to be consistent with the particular language, and still have the
exact same number of entries.  Type in @code{0:#max_args-1;}, not forgetting
the semi-colon at the end.  Hit the @key{Enter} key (deleting any characters
inserted by the text editor, if added).  Your screen will look as follows:

@float Figure, Aggregate Last File
@image{AggregateLast,5.6in,,,.jpg}
@end float

@page
@item Finally, we are going to close off the @code{AGGREGATE} definition.  Type
in @code{END operator;} and type the @key{Enter} key.  Make sure the @emph{id}
specified on the @code{AGGREGATE} statement matches the one on the @code{END},
keeping the case the same.  @strong{Note}: Putting the @emph{id} on the
@code{END} statement is optional, but if specified, must match.  Your screen
will look as follows:

@float Figure, Aggregate End File
@image{AggregateEnd,5.6in,,,.jpg}
@end float

@page
@item Again type the @key{Enter} key.  Next we are going to define another
local variable to contain a value representing the current offset within a
@code{AGGREGATE} definition.  Type @code{#opsize = .;}, again makine sure to
include the semi-colon character.  Type the @key{Enter} key again.  Your screen
will look as follows:

@float Figure, Offset File
@image{Offset,5.6in,,,.jpg}
@end float

@page
@item Because local variables are not written to the output file, if we want
the offset values, we need to defined a @code{CONSTANT} value.  To do this we
start by typing in @code{CONSTANT} followed by a space character.

@item Type @code{opr_node_size} followed by a space character.

@item Type @code{EQUALS #opsize}, which does not have to be followed by a space
character.  We do so hear for clarity.

@item Type @code{/ 2;}, remembering to include the semi-colon, plus typing the
@key{Enter} key.  Your screen will look as follows:

@float Figure, Constant Offset File
@image{ConstantOffset,5.6in,,,.jpg}
@end float

@page
@item Now we are going to define a stand alone variable.  Type @code{ITEM}
followed by a space character.

@item Type @code{current_node_ptr ADDRESS GLOBAL;} followed by the @key{Enter}
key.  Your screen will look as followes:

@float Figure, Item File
@image{Item,5.6in,,,.jpg}
@end float

@page
@item Lastly, type the @key{Enter} key again and then type
@code{END_MODULE opr_descriptor;}, making sure the semi-colon is present.  An
@key{Enter} key can be typed again, but is not required.  Your screen will look
as follows, with the complete OpenSDL file:

@float Figure, Item File
@image{Complete,5.6in,,,.jpg}
@end float
@end enumerate

You may insert a specific copyright-statement, but for the purposes of
this tutorial, it is not being shown.

Your resulting screen display should be the OpenSDL source file shown in
@ref{Creating a Sample OpenSDL Source File}.

@node Compiling Source Code
@subsection Compiling Source Code

Compiling source code is very straightforward.  You use the command qualifiers
to read in the input file and generate one or more output files.  At a minimum
the command line consists of the following:

@enumerate
@item The @command{opensdl} command.
@item One output language (e.g. @command{-lang:cc}).
@item The input file @file{test.sdl}. 
@end enumerate

When compiling an input file, as errors are detected, the are displayed to
stderr.  Additionally, the @command{-list} qualifier can be specified to
generate a listing file, where the same errors will be displayed at the line
where the error was detected.

@quotation Note
The line numbers displayed within the error message text may not be exactly the
line of code in a listing file where the message will be written.  The error
message text will refer to the first line of a multiline statement, where this
same text will be written immediately after the line of code that actually
caused the condition to be detected.@*
@*
A single line of code can generate multiple errors, the errors will be
displayed in the order inwhich they were detected.
@end quotation

@ref{Processing an OpenSDL Source File} describes how to process an OpenSDL
source file using the OpenSDL command and all its qualifiers.

@node Processing an OpenSDL Source File
@section Processing an OpenSDL Source File

The @command{opensdl} command invokes the OpenSDL translator from the command
line to produce output files for one or more target languages.  The
@command{opensdl} command has the following format:

@command{opensdl [-qualifier[...]] file-spec[-qualifier[...]],...}

Command Parameter
@file{file-spec,...}
Specifies one or more OpenSDL source files to be translated.  A file
specification must specify a file name; if it does not include a file type,
OpenSDL uses the default file type @file{.sdl}.  You can specify one a single
input file.

Command Qualifiers
Command qualifiers may be specified following the @command{open} command.
@ref{OpenSDL Command Qualifiers and Their Defaults} lists all the optional 
@command{opensdl} command qualifiers and their defaults.

@float Table, OpenSDL Command Qualifiers and Their Defaults
@multitable @columnfractions .4 .6
@headitem Qualifier @tab Default
@item @command{-align} @tab No alignment
@item @command{-32} or @command{-64} @tab @command{-64}
@item @command{-[no]check} @tab @command{-nocheck}
@item @command{-[no]comments} @tab @command{-comments}
@item @command{-[no]copy} @tab @command{-nocopy}
@item @command{-[no]header} @tab @command{-header}
@item @command{-help} @tab Do not display help information.
@item @command{-lang} @tab No languages
@item @command{-[no]list} @tab @command{-nolist}
@item @command{-[no]member} @tab @command{-nomember}
@item @command{-[no]suppress} @tab @command{-nosuppress}
@item @command{-symbol} @tab No symbols
@item @command{-t} @tab No trace memory allocations/deallocations
@item @command{-v} @tab No verbose output
@item @command{-V} @tab Don't display OpenSDL version information.
@end multitable
@end float

@command{-align=value}@*
The assumed alignment.  Integer value greater than zero.  If specified,
diagnostic messages are emitted for data items that do not fall on the assumed
alignment.

@command{-32} or @command{-64}@*
The number of bits the represent a @code{LONGWORD}.

@command{-check}@*
@command{-nocheck}@*
If specified, diagnostic messages are emitted for data items that do not fall
on their natural alignment.

@command{-comments}@*
@command{-nocomments}@*
Controls whether output comments are included in the output file.  For more
compact target language representation, use the -nocomments qualifier to save
file space.  The default is @command{-comments}.

@command{-copy}@*
@command{-nocopy}@*
Controls whether a standard copyright header is produced in the output file.
The @command{-copy} qualifier causes the OpenSDL translator to precede the
output with a comment containing the copyright claim as specified in the
@file{/usr/lib/opensdl/copyright.sdl} file.  The default is @command{-nocopy}.

@command{-header}@*
@command{-noheader}@*
Controls whether a header containing the date and the source file name is
included at the beginning of the output file.  The default is
@command{-headear}.

@command{-help}@*
Controls whether the help/usage information is specified to standard output.

@command{-lang:@{language[=file-spec]@}}@*
@{(language[=file-spec],...)@}
Specifies a single language option listed in @ref{OpenSDL Output Language
Options and File Types} for which the OpenSDL translator is to produce a source
output file.  By default, OpenSDL writes output files into separate files in
the current default directory/folder.  The default file name for each output
file is taken from the file name of the corresponding source file and the
default target file type for each language name.  Multiple @command{-lang}
qualifiers can be specified on the command line, but each language should only
be specified once.

@float Table, OpenSDL Output Language Options and File Types
@multitable @columnfractions .33 33 .34
@headitem Language @tab Option @tab Target File Type
@item C/C++ @tab @command{-lang:cc} @tab .h
@end multitable
@end float
@*
The @command{-lang} qualifier also allows you to override the default output
file specification for a language output files.  You can specify a language
option followed by the destination file specification for that language.  You
must separate the language from the destination file specification with an
equal sign (=).

@command{-list[:file-spec]}@*
@command{-nolist}@*
Controls whether a listing file is produced.

The @command{-list} qualifier causes the OpenSDL translator to produce a
listing file with numbered lines of source code and descriptions of any
compilation errors.  The listing file has the same name as the related source
file and a file type of @file{.lis}.

@command{-member}@*
@command{-nomember}@*
Specifies that every item in aggregates should be aligned.  This is the same as
specifying @code{ALIGN} on all aggregates.

@command{-module}@*
@command{-nomodule}@*
Controls whether a module is generated in the output file for the relevant
output language.  The default is @command{-module}.

@command{-suppress:@{suppress-option@}}@*
@command{@ @ @ @ @ @ @ @ @ @ @{(suppress-option,...)@}}@*
The @command{-supress} qualifier has the following format:
@command{opensdl -suppress=prefix,tag}

Note the following:

@itemize @bullet
@item The suppress-options can be either @command{prefix} or @command{tag}.

@item The qualifier may appear anywhere in the command line where a qualifier
is valid.

@item Output in all languages in that compilation is affected.

@item Either @command{prefix} or @command{tag}, or both, may be included in the
list (with no spaces between when specifying both).

@item If both prefixes and tags are suppressed, the connecting underscore is
also suppressed.

@item The effect is as though null prefixes and/or tags had been specified
throughout the source.
@end itemize

@command{-symbol:@{symbol=value@}}@*
It is possible to specify symbols and values which can be used in the IFSYMBOL
statement (kind of conditional compilation).  Multiple @command{-symbol}
qualifiers can be specified on the command line.  If the same symbol is
specified more than ones, then the last one will be in effect.
See @code{IFSYMBOL}.

@command{-t}@*
Specifies that the OpenSDL Utility should display memory allocations and
deallocations used by the tool as it processes the input file and generates the
output file(s).

@command{-v}@*
Specifies that the OpenSDL Utility should generate verbose messages to both
standard output and standard error as it processes the input file and generates
the output file(s).  This can be used to debug issues with the utility.

@command{-V}@*
Specifies that the OpenSDL Utility should display the version information for
the utility to standard output.

Examples

The following are examples and descriptions of the @command{opensdl} command.
@enumerate
@item @command{$ opensdl blocknode.sdl -lang:cc=../block_node.h)}@*
OpenSDL translates the declarations in @file{blocknode.sdl} to C/C++ and
writes the C/C++ output to @file{block_node.h} in the parent directory/folder.

@item @command{$ opensdl -list -lang:cc iodef.src}@*
OpenSDL translates the declarations in iodef.src and writes the output to
iodef.h, while also generating the list file iodef.lis
@end enumerate

@node OpenSDL Language Elements
@chapter OpenSDL Language Elements
@cindex OpenSDL Language Elements

This chapter describes the function and syntax of the following OpenSDL
language elements that compose the OpenSDL declarations described in Chapter 4:

@itemize @bullet
@item User-specified names, which can be either local symbol names or source
program identifiers
@item Reserved OpenSDL keywords
@item Expressions
@end itemize

The following can also be used within a MODULE declaration; although they are
not OpenSDL language elements (@ref{Local Comments} through
@ref{INCLUDE Statement}):

@itemize @bullet
@item Local and output (line and Block) comments
@item INCLUDE statement
@item Conditional compilation
@item Text pass-through
@item DECLARE statement
@end itemize

The space, tab, or carriage return character delimits the language elements,
and a semicolon (;) terminates each declaration.  In MODULE and AGGREGATE
declarations, the semicolon also terminates separate parts of the declaration.

Appendix B shows language translation summaries of all the OpenSDL language
elements.

@node Names
@section Names

An OpenSDL name can be either a user-specified local symbol name that is not
translated to the output file or a user-specified source program identifier
that is translated to the output file.  Names are composed of upper- and
lowercase letters (A - Z, a - z), numbers (0 - 9), the dollar sign ($), and the
underscore (_).  Specifying a name is subject to the following rules:

@enumerate
@item Local symbol names must begin with a pound sign (#).
@item Source program identifiers must begin with an alphabetic character
(A-Z, a-z), a dollar sign ($), or an underscore (_).
@item Source program identifiers that are reserved OpenSDL keywords or that
contain invalid  OpenSDL characters must be enclosed in quotation marks (" ").
(For more information on reserved OpenSDL keywords, @ref{Keywords Used in
Declarations}).
@item OpenSDL passes all source program identifiers to the output file in the
same case in which they are defined.
@end enumerate

@node Local Symbol Names
@subsection Local Symbol Names
A local symbol name is known only within an OpenSDL source file and cannot be
translated directly to the output file.  A local symbol name can be assigned a
value anywhere within a source file, but must begin with the pound sign (#).
A local symbol is declared when it is first assigned a value.  This value can
be any valid expression (@ref{Expressions}).  If you reference a local symbol
before assigning it a value, OpenSDL displays an error message and does not
produce an output file.  A local symbol assignment has the following syntax:

@code{#local-name = expression;}

#local-name@*
Is any valid OpenSDL name.

expression@*
Is any valid OpenSDL expression resulting in a longword integer value.  Signed
integer longword data types are described in @ref{Integer Data Types}.  The
following are examples of local symbol assignments:

@example
#max_args = 255;
#counter = #counter + 1;
@end example

The values of these local symbols may be referenced by subsequent declarations,
as shown in the following example:

CONSTANT block_node_size EQUALS #max_args + #counter;

@subsection Source Program Identifiers

Source program identifiers (identifiers) specify declaration names, AGGREGATE
member names, and ENTRY parameter names that are passed to the output file.
Optional user-specified prefixes and tags can be appended to these identifiers.
If a prefix is specified without a tag, OpenSDL concatenates a default tag
(corresponding to the data type) to the identifier in the output file.
(@ref{PREFIX MARKER and TAG Keywords} describes the PREFIX. MARKER and TAG
keyword options.) The identifier block_node_size in the following example names
the CONSTANT declaration:

@code{CONSTANT block_node_size EQUALS #max_args + #counter;}

To avoid compilation errors, each reference to a particular OpenSDL identifier
must be a case sensitive match because an identifier is passed to the output
file in the same case in which it appears in the source file.  You can use
reserved OpenSDL keywords and characters that are not valid in identifiers if
you enclose them in quotation marks (" ").  For example:

@code{ITEM "length" LONGWORD;}

This declaration produces the identifier length, which is a reserved OpenSDL
keyword typically used to specify the length of a bit-string or
character-string data type (see @ref{BITFIELD Data Type} and
@ref{CHARACTER Data Type}).

@page

@node Keywords Used in Declarations
@section Keywords

Reserved OpenSDL keywords are used to specify the following:
@itemize @bullet
@item Declarations (@ref{Declaration Keywords})
@item Declaration modifiers (@ref{Declaration Modifier Keywords})
@item Prefixes, markers, and tags (@ref{PREFIX MARKER and TAG Keywords})
@item Alignment (@ref{Alignment Keywords})
@item Storage classes (@ref{Storage Class Keywords})
@item Arrays (@ref{DIMENSION Keyword})
@item Datatypes (@ref{Data Type Keywords})
@end itemize

Reserved OpenSDL keywords can be entered in either upper- or lowercase letters,
but they cannot be truncated.

The following sections describe the format and function of each of the reserved
OpenSDL keywords.

@node Declaration Keywords
@subsection Declaration Keywords

@ref{Keywords That Identify or End Declarations} alphabetically lists and
defines the keywords for the declarations described in detail in Chapter 4.

@float Table, Keywords That Identify or End Declarations
@multitable @columnfractions .3 .7
@headitem Keyword @tab Definition
@item MODULE @tab Declaration of a module
@item END_MODULE @tab Delimiter for the end of a module
@item CONSTANT @tab Declaration of a named constant
@item ITEM @tab Declaration of an item
@item AGGREGATE @tab Declaration that produces a structure or union body
@item STRUCTURE @tab Declaration that is a type of aggregate or subaggregate
@item UNION @tab Declaration that is a type of aggregate or subaggregate
@item END @tab Delimiter for the end of an aggregate body
@item ENTRY @tab Declaration of an entry
@end multitable
@end float

@node Declaration Modifier Keywords
@subsection Declaration Modifier Keywords

@ref{Keywords That Identify or End Declarations} lists and defines other
keywords that are used in declarations.  The prefix and tag, storage class, and
array keywords have special functions that are described in detail in the
sections following @ref{Keywords Used in Declarations}.  All the other keywords
defined in @ref{Keywords Used in Declarations} are described in greater detail
in Chapter 4.

@subsubsection MODULE Declaration
@float Table, MODULE Declaration
@multitable @columnfractions .25 .75
@headitem Keyword @tab Description
@item IDENT @tab Optional keyword used to pass information describing the
MODULE declaration to the output file
@end multitable
@end float

@subsubsection ITEM Declaration
@float Table, Item Declaration
@multitable @columnfractions .25 .75
@headitem Keyword @tab Description
@item ALIGN, @tab Optional keywords used to specify alignment; see
@ref{Alignment Keywords}
@item NOALIGN,
@item BASEALIGN

@item COMMON and GLOBAL @tab Optional keywords used to specify common and
global storage; see @ref{Storage Class Keywords}

@item DIMENSION @tab Optional keyword used to specify that the ITEM declaration
is an array; see @ref{DIMENSION Keyword}

@item PREFIX @tab Optional keyword used to concatenate a user-defined prefix to
ITEM names, AGGREGATE member names, and named constants; see
@ref{PREFIX MARKER and TAG Keywords}

@item TAG @tab Optional keyword used to override the default OpenVMS code
assigned to a name and to assign a user-defined tag instead; see @ref{PREFIX
MARKER and TAG Keywords}
@end multitable
@end float

@page

@subsubsection AGGREGATE Declaration
@float Table, AGGREGATE Declaration
@multitable @columnfractions .25 .75
@headitem Keyword @tab Description
@item COMMON, @tab Optional keywords used to specify common, global, or based
storage, or a TYPEDEF; see @ref{Storage Class Keywords}
@item GLOBAL,
@item BASED,
@item TYPEDEF

@item DIMENSION @tab Optional keyword used to specify that the AGGREGATE
declaration is an array; see @ref{DIMENSION Keyword}

@item FILL @tab Optional keyword used to indicate whether the associated
aggregate or member occurs only as a fill to force byte alignment on the
following member or aggregate, respectively.

@item MARKER @tab Optional keyword used to assign a user-defined prefix to the
aggregate name; see @ref{PREFIX MARKER and TAG Keywords}

@item ORIGIN @tab Optional keyword used to define the beginning of an aggregate
with respect to an aggregate member

@item PREFIX @tab Optional keyword used to concatenate a user-defined prefix to
AGGREGATE member names, ITEM names, and named constants; see @ref{PREFIX
MARKER and TAG Keywords}

@item TAG @tab Optional keyword used to override the default OpenVMS code
assigned to a name and to assign a user-defined tag instead; see @ref{PREFIX
MARKER and TAG Keywords}
@end multitable
@end float

@page

@subsubsection CONSTANT Declaration
@float Table, CONSTANT Declaration
@multitable @columnfractions .25 .75
@headitem Keyword @tab Description
@item COUNTER @tab Optional keyword that saves the last assigned value in a
local symbol declaration for subsequent use.

@item EQUALS @tab Required keyword used in assigning the value to the first
named constant STRING Optional keyword specified immediately after EQUALS to
indicate the definition of a string constant.

@item INCREMENT @tab Optional keyword used to specify constants with
incremental values

@item PREFIX @tab Optional keyword used to concatenate a user-defined prefix to
aggregate member names and named constants; see @ref{PREFIX MARKER and TAG
Keywords}

@item RADIX @tab Optional keyword used to indicate how a constant should be
written in the output file; see @ref{RADIX Keyword}

@item TAG @tab Optional keyword used to override the default OpenVMS code
assigned to a name and to assign a user-defined tag instead; see @ref{PREFIX
MARKER and TAG Keywords}

@item TYPENAME @tab Optional keyword not currently used, but may be introduced
when Ada or PL/I back-ends are developed; see @ref{User Specified TYPENAME
Keyword}
@end multitable
@end float

@page

@subsubsection ENTRY Declaration

@float Table, ENTRY Declaration
@multitable @columnfractions .25 .75
@headitem Parameter Passing@*Mechanism @tab Description
@item REFERENCE @tab Optional parameter-passing mechanism keyword used to
specify that a parameter must be passed BY REFERENCE; REFERENCE is the default

@item VALUE @tab Optional parameter-passing mechanism keyword used to specify
that the parameter must be passed BY immediate VALUE
@end multitable
@end float

@float Table, PARAMETER Declaration
@multitable @columnfractions .25 .75
@headitem Parameter@*Mode Keywords @tab Description
@item IN @tab Parameter description keyword used to indicate that a parameter
is an input parameter; can be used with OUT to indicate that the parameter is
both an input and an output parameter; IN is the default

@item OUT @tab Parameter description keyword used to indicate that a parameter
is an output parameter; can be used with IN to indicate that the parameter is
both an input and an output parameter
@end multitable
@end float

@page

@float Table, PARAMETER Modifiers
@multitable @columnfractions .25 .75
@headitem Other Parameter@*Modifier @tab Description
@item DEFAULT @tab Optional parameter description keyword used to specify a
default parameter value

@item DIMENSION @tab Optional keyword used to specify that the parameter is an
array; see @ref{DIMENSION Keyword}

@item LIST @tab Optional parameter description keyword used to indicate that
the routine may be called with one or more parameters of the type being
described

@item NAMED @tab Optional parameter description keyword used only by the Ada
back end to name the parameter

@item OPTIONAL @tab Optional parameter description keyword used to specify that
the parameter may or may not appear in the sequence of parameters using the
entry point name

@item TYPENAME @tab Optional parameter description keyword used only by the Ada
and PL/I back ends to specify a user-defined data type name; see
@ref{User Specified TYPENAME Keyword}
@end multitable
@end float

@float Table, RETURN Value Keywords
@multitable @columnfractions .25 .75
@headitem Entry Return Value@*Keywords @tab Description
@item NAMED @tab Optional keyword used to specify the name of the parameter (in
an Ada IMPORT_VALUED_PROCEDURE) into which the return value is returned

@item RETURNS @tab Optional keyword used to specify the data type returned by
the external entry

@item TYPENAME @tab Optional keyword used only by the Ada and Kednos PL/I back
ends to specify a user-defined name that is the data type returned by the
external entry; see @ref{User Specified TYPENAME Keyword}
@end multitable
@end float

@float Table, ENTRY Description Keywords
@multitable @columnfractions .25 .75
@headitem Entry Description@*Keywords @tab Description
@item ALIAS @tab Optional keyword used to indicate an alternate internal name
that can be used to designate the entry point

@item LINKAGE @tab Optional keyword used only by the MACRO back end to indicate
that a special call macro will be used in the expansion of the entry macro

@item PARAMETER @tab Optional keyword used to describe the parameters of the
external entry

@item VARIABLE @tab Optional keyword used to indicate that the entry point can
be invoked with a variable number of parameters; see also the LIST parameter
modifier keyword
@end multitable
@end float

@node User Specified TYPENAME Keyword
@subsubsection User-Specified TYPENAME keyword

The TYPENAME keyword is used to specify a data type name that is not an OpenSDL
data type.  Depending on which back end is specified, this name may or may not
override the OpenSDL data type.  The Ada and PL/I back ends use these data type
names as parameter data types, as return value data types, and as CONSTANT
declaration data types.

The TYPENAME keyword has the following syntax:@*

@code{TYPENAME name}@*

The Ada language translation (as a result of processing the OpenSDL source file
@file{/usr/lib/opensdl/example/example.sdl}) shows an example of the TYPENAME
keyword.  The following is an example of the TYPENAME keyword on each of the
parameters in an ENTRY declaration:

@example
ENTRY SYS$FAO
    ALIAS $FAO
    PARAMETER (CHARACTER REFERENCE NAMED CTRSTR IN TYPENAME CHARDESC,
        WORD UNSIGNED NAMED OUTLEN OUT DEFAULT 0 TYPENAME NUMBER,
        CHARACTER REFERENCE NAMED OUTBUF OUT TYPENAME CHARDESC,
        LONGWORD VALUE NAMED P1 OPTIONAL LIST TYPENAME VARIES)
    RETURNS LONGWORD TYPENAME CONDVALU;
@end example

@node PREFIX MARKER and TAG Keywords
@subsubsection PREFIX, MARKER, and TAG Keywords
User-defined prefixes, markers, and tags are optional character strings that
help to uniquely identify the names associated with a particular facility or
system.  When the @command{-suppress} qualifier is specified on the command
line, the inclusion of prefixes and/or tags on output symbol names is
suppressed.  See @ref{Processing an OpenSDL Source File} for a description of
the @command{-suppress} qualifier.

@subsubheading PREFIX Keyword

The PREFIX option may be specified on an AGGREGATE, subaggregate, CONSTANT, or
ITEM declaration to cause OpenSDL to concatenate a user-specified prefix and
the name specified in the declaration.

When you specify a prefix for an aggregate, OpenSDL concatenates the prefix and
the name of each member or named constant declared within the aggregate.  The
name of the aggregate itself is not altered by the use of the PREFIX option.
The PREFIX option has the following syntax:

@code{PREFIX prefix-string}@*

@strong{prefix-string}@*
Is a 0- to 32-character string that can be any valid OpenSDL identifier.
If you specify the PREFIX option, OpenSDL constructs the identifier of each
member by concatenating the prefix, a tag, an underscore, and the member name.

You can override a prefix that is currently in effect by specifying a new
prefix for a particular aggregate member.  If this member happens to be a
subaggregate, the new prefix is applied to all the members of that
subaggregate.  Otherwise, if no prefix is specified for the subaggregate, all
subaggregate members are assigned the same prefix as that specified on the
level-1 aggregate.

@subsubheading MARKER Keyword

You can use the MARKER keyword to assign a user-defined prefix to the aggregate
name.  The MARKER option has the following syntax:

@code{MARKER marker-string}@*

@strong{marker-string}@*
Is a 0- to 32-character string that can be any valid OpenSDL name that may or
may not be enclosed in quotation marks (" ") and may be null.

@subsubheading TAG Keyword

The TAG option overrides the default tags that OpenSDL uses in forming
identifiers.  You can specify tags for CONSTANT, ITEM, and AGGREGATE
declarations and aggregate members.
The tag that you specify, however, affects only the outer-level identifier.  For
example, a tag you supply in an AGGREGATE declaration affects only the
aggregate name; if you wish to change all the tags in an aggregate, you must do
it on a member-by-member basis.  The TAG option has the following syntax:

@code{TAG tag-string}@*

@strong{tag-string}@*
Is a 0- to 32-character string specifying the tag to use in forming the name.
If the TAG option is not specified, OpenSDL uses a default code based on the
data type of the name.
If you specify the TAG option, OpenSDL appends the tag-string, which may be
null (" "), and an underscore character (_) to the current prefix-string.  A
tag consisting of a single underscore character produces a single underscore
character in any resulting identifier.
The following is an example of the PREFIX, TAG, and MARKER keywords:

@example
AGGREGATE operator STRUCTURE MARKER doowop$ PREFIX beebop$ TAG shoo;
    flink ADDRESS;
    blink WORD;
END;
@end example

@ref{Default Tags Used by OpenSDL} shows the default tags that OpenSDL uses
when the TAG option is not specified on an aggregate member.

@float Table, Default Tags Used by OpenSDL
@multitable @columnfractions .4 .6
@headitem Data Type @tab Default Tag
@item CONSTANT @tab K
@item BYTE [UNSIGNED] @tab B
@item WORD [UNSIGNED] @tab W
@item LONGWORD [UNSIGNED] @tab L
@item QUADWORD @tab Q
@item OCTAWORD @tab O
@item F_FLOATING @tab F
@item D_FLOATING @tab D
@item G_FLOATING @tab G
@item H_FLOATING @tab H
@item T_FLOATING @tab T
@item S_FLOATING @tab S
@item X_FLOATING @tab X
@item F_FLOATING COMPLEX @tab FC
@item D_FLOATING COMPLEX @tab DC
@item G_FLOATING COMPLEX @tab GC
@item G_FLOATING COMPLEX @tab HC
@item T_FLOATING COMPLEX @tab TC
@item S_FLOATING COMPLEX @tab SC
@item X_FLOATING COMPLEX @tab XC
@item DECIMAL @tab P
@item BITFIELD @tab V for BITFIELD offset
@item @tab S for BITFIELD size@footnote{Identifiers with size and mask (if
MASK is specified) tags are generated regardless of whether a PREFIX or TAG
option is specified.}
@item @tab M for BITFIELD mask
@item CHARACTER @tab T
@item ADDRESS @tab A
@item BOOLEAN @tab B
@item VOID @tab Z
@item INTEGER @tab IS
@item INTEGER_BYTE @tab IB
@item INTEGER_WORD @tab IW
@item INTEGER_LONG @tab IL
@item INTEGER_QUAD @tab IQ
@item INTEGER_HW @tab IH
@item POINTER_HW @tab PH
@item POINTER_LONG @tab PL
@item POINTER @tab PS
@item POINTER_QUAD @tab PQ
@item HARDWARE_ADDRESS @tab HA
@item HARDWARE_INTEGER @tab HI
@item STRUCTURE @tab R
@item UNION @tab R
@end multitable
@end float

The following example shows the use of a user-specified prefix on an AGGREGATE
declaration:

@example
AGGREGATE operator STRUCTURE
    PREFIX opr$;

    id WORD;
    "typename" CHARACTER;
    CONSTANT (fixed_bin_,float_) EQUALS 0 INCREMENT 1;
    bits STRUCTURE;
        variable_size BITFIELD;
        size_units BITFIELD LENGTH 3;
    END bits;
END operator;
@end example

In the previous example, the member name "typename" is enclosed in quotation
marks because it is an OpenSDL keyword.

The previous declaration produces the
following names, with the prefix opr$ and default tags, in the PL/I output
file:

@example
%replace opr$k_fixed_bin_ by 0;
%replace opr$k_float_ by 1;
%replace opr$s_operator by 4;
dcl 1 operator based,
     2 opr$w_id fixed binary(15),
     2 opr$t_typename character(1),
     2 opr$r_bits ,
      3 opr$v_variable_size bit(1),
      3 opr$v_size_units bit(3),
      3 opr$v_fill_0 bit(4);
@end example

The name opr$v_fill_0 in the previous list is the result of a BITFIELD
declaration that OpenSDL supplied because the subaggregate did not end on a
byte boundary.  The name (opr$v_fill_0) ensures that the next aggregate begins
on a byte boundary.  @ref{Forcing Data Alignment} describes data alignment in
detail.  OpenSDL uses default codes followed by an underscore (_) for the tag
portion of a prefix when the TAG option is not specified.  You can override the
default OpenVMS codes by specifying a tag, which may be null (" ").  For
example:

@example
CONSTANT (abc,def,ghi) EQUALS 0 INCREMENT 1
    PREFIX new
    TAG "";
@end example

This declaration results in the names @code{new_abc}, @code{new_def}, and
@code{new_ghi}.

@node RADIX Keyword
@subsubsection RADIX Keyword
The RADIX keyword can be used to indicate how a constant value should
be written out to the output file.  It can have one of three possible values.

@itemize @bullet
@item @strong{@code{DEC}} --- for Decimal
@item @strong{@code{OCT}} --- for Octal 
@item @strong{@code{DEC}} --- for Hexadecimal
@end itemize

For example:
@example
CONSTANT MyConst EQUALS 42 RADIX HEX;
@end example

will generate the following C code header file:

@example
#define MyConst 0x2a
@end example

@quotation Note
When a @code{BITMASK} has the optional @code{MASK} keyword, constant values are
generated using the @code{RADIX HEX} keywords.
@end quotation

@node Alignment Keywords
@subsubsection Alignment Keywords
Both the ALIGN and BASEALIGN keywords can ensure that items are properly
aligned.  The BASEALIGN keyword takes an argument, which specifies the
alignment, whereas the ALIGN keyword uses the natural alignment of the item.

@itemize @bullet
@item If the ALIGN keyword is included in the definition of an aggregate, every
member will be aligned.  Both i1 and i2 will be aligned.
@example
AGGREGATE MyStruct STRUCTURE ALIGN;
    c1 CHARACTER;
    i1 LONGWORD;
    c2 CHARACTER;
    i2 LONGWORD;
END;
@end example

@item If the ALIGN keyword is included in the definition of a member of an
aggregate, this member will be aligned, even if the AGGREGATE itself does not
have the ALIGN attribute.  i2 will be aligned whereas i1 will not be aligned.
@example
AGGREGATE MyStruct STRUCTURE NOALIGN;
    c CHARACTER;
    i1 LONGWORD;
    i2 LONGWORD ALIGN;
END;
@end example

@item If the NOALIGN keyword is included in the definition of a member of
an aggregate, no action will be taken to ensure that this member will be
aligned, even if the AGGREGATE has the ALIGN attribute.  i2 will be aligned, i1
will not be aligned.
@example
AGGREGATE MyStruct STRUCTURE ALIGN;
    c CHARACTER;
    i1 LONGWORD NOALIGN;
    i2 LONGWORD;
END;
@end example

@item If the NOALIGN keyword is included in the definition of an aggregate,
no action will be taken to ensure that any member of this aggregate will be
aligned.  Neither i2 nor i1 will be aligned.
@example
AGGREGATE MyStruct STRUCTURE NOALIGN;
    c CHARACTER;
    i1 LONGWORD;
    i2 LONGWORD;
END;
@end example

@item If the BASEALIGN keyword is included in the definition of a member of an
aggregate, this member will be aligned according to the given alignment.  In
this case, i2 will have an offset of 256 (28),
@example
AGGREGATE MyStruct STRUCTURE NOALIGN;
    c CHARACTER;
    i1 LONGWORD;
    i2 LONGWORD BASEALIGN(8);
END;
@end example

@item If the BASEALIGN keyword is included in the definition of an aggregate or
an item, the aggregate or item itself will be padded, so that in an array of
elements of this aggregate or item type, all elements will be aligned
according to the given alignment.  The syntax is as follows:
@example
AGGREGATE MyStruct STRUCTURE BASEALIGN (2);
    c CHARACTER;
    i1 LONGWORD;
    i2 LONGWORD;
END;
@end example
@end itemize

The size of the aggregate will be a multiple of 4 (22), in this case 12, and
neither i1 nor i2 will be aligned.  In the following example, the item will
have a size of 8 (23).

@code{ITEM MyItem LONGWORD UNSIGNED BASEALIGN (3);}

@node Storage Class Keywords
@subsubsection Storage Class Keywords

Storage class refers to the way in which the target language compiler allocates
storage for scalar items and aggregates.  In general, declarations produce a
template describing data for which the compiler allocates storage dynamically
at run time, rather than at compile time.  This type of storage is the default
and is specified using the BASED option in some languages, although the default
storage class option is language-dependent.  The PL/I back end generates the
BASED storage class option, which has the following syntax:

@code{BASED (pointer-name)}

In languages that support the construct, you can use the BASED pointer-name
option on an AGGREGATE declaration to bind a named pointer to that aggregate.
In all target languages, the aggregate resulting from such a declaration has
the default storage class (BASED).

A subaggregate always acquires the storage class of the aggregate to which it
belongs.  The default storage class associated with any declaration is
language-dependent.  You can override the default storage class by specifying
either of the following storage classes:

@itemize @bullet
@item @strong{Common storage} is allocated in an external program section
(Psect) with the OVR option and is shared by all routines that reference it.
You declare data in common storage by using the COMMON option on an AGGREGATE
or ITEM declaration.

@item @strong{Global storage} represents data in a global storage location whose
value is defined elsewhere.  You declare global data by using the GLOBAL option
on an AGGREGATE or ITEM declaration.

@item @strong{TYPEDEF} behaves like a storage class.  In C, examples of storage
classes are static, globaldef/ref, extern, etc.  Syntactically, you can replace
a static in any declaration with typedef and have it compiled.  Storage
classes (including TYPEDEF) are mutually exclusive in an OpenSDL declaration.

Example of C type definition:
@example
typedef struct @{int jg$l_i1; int jg$l_i2;@} MyStruct ;
static MyStruct foo ;
@end example
is equivalent to:
@example
static struct @{int jg$l_i1; int jg$l_i2;@} foo ;
@end example
or:
@example
static struct MyStruct @{int jg$l_i1; int jg$l_i2;@} foo ;
@end example
or:
@example
struct MyStruct @{int jg$l_i1; int jg$l_i2;@} ;
static struct MyStruct foo ;
@end example
@end itemize

If COMMON and GLOBAL appear together in a declaration, a DUPCONATT (duplicate
or conflicting attributes) error is given.  The COMMON, GLOBAL and TYPEDEF
storage classes are mutually exclusive.

@subsubsection OpenSDL Storage Classes and Typedef Syntax
Explicit OpenSDL Storage classes are COMMON and GLOBAL.  To maintain orthogonal
syntax, TYPEDEF is permitted wherever COMMON and GLOBAL are permitted.

The Storage class definition in OpenSDL is included as an option on an ITEM or
AGGREGATE declaration.  This means that an AGGREGATE TYPEDEF for the preceding
example would be:

@example
AGGREGATE MyStruct STRUCTURE TYPEDEF PREFIX jg$ ;
    i1 LONGWORD ;
    i2 LONGWORD ;
END ;
@end example

@subsubsection Data Types
In most cases it is possible to refer to a user-defined Data Type where a
standard built-in OpenSDL Data Type (BYTE, LONGWORD etc.) can be referenced.
Reference to the type MyStruct defined in the preceding example is made as
follows:

@code{ITEM foo MyStruct ;}

@node DIMENSION Keyword
@subsubsection DIMENSION Keyword

You can apply a dimension to AGGREGATE (as well as members of aggregates and
subaggregates) and ITEM declarations, which means that you can define an array
of structures, a structure that contains one or more arrays, or an array of
structures each of which contains one or more arrays.  The DIMENSION option is
valid when specified with any of the data types described in @ref{Data Type
Keywords} and has the following syntax:

@code{DIMENSION [lbound:]hbound}

lbound@*
Is any valid OpenSDL expression giving the value of the lowest-numbered element
of the array.  If lbound is not specified, OpenSDL supplies a default lbound of
1.

hbound@*
Is any valid OpenSDL expression giving the number of elements in the array, or,
if lbound is specified, the highest-numbered element.

The following is an example of the DIMENSION option specified on an AGGREGATE
declaration:

@example
AGGREGATE array_info STRUCTURE;
    bound STRUCTURE DIMENSION 8;
        lower LONGWORD;
        upper LONGWORD;
        multiplier LONGWORD;
        constant_lower BITFIELD LENGTH 1;
        constant_upper BITFIELD LENGTH 1;
        constant_multiplier BITFIELD LENGTH 1;
        reserved BITFIELD LENGTH 13;
    END bound;
END array_info;
@end example

The subaggregate bound has eight elements.  Each element consists of the members
upper, lower, multiplier, and so on.  Because bound is an array, each of its
members (upper, lower, multiplier, and so on) can also be considered an array
of eight elements.  When you specify a single value after the DIMENSION
keyword, as in the previous example, the specified back end assumes that the
value represents the high bound value and supplies a default low bound value of
one.  You can override this default by specifying both a low bound and a high
bound value as follows:

@code{ITEM node_pointers DIMENSION 0:255 ADDRESS;}

This declaration results in a declaration of the array node_pointers, whose low
bound is 0 and whose high bound is 255.  Only one dimension can be specified for
an AGGREGATE or ITEM declaration.  This restriction ensures that there is no
interlanguage conflict in an array declaration.

You can see how OpenSDL translates the DIMENSION option for each output
language by processing the OpenSDL source file
@file{/usr/lib/opensdl/examples/example.sdl}.

@node Data Type Keywords
@subsection Data Type Keywords

Data type keywords specify the data types of scalar objects, which can be
declared as members of aggregates or as individual items.  Data type keywords
are also used to describe the data types of parameters, as well as the return
value of an ENTRY.  They can also be used in an AGGREGATE declaration to
generate an implicit union.  The data type declaration also specifies, either
implicitly or explicitly, the size of a member.

The following sections describe the data types and the keywords you use to
specify them.

@subsubsection Pointer Data Types
The keywords ADDRESS, POINTER, POINTER_LONG, POINTER_QUAD, POINTER_HW,
and HARDWARE_ADDRESS specify a data type that is an address, or pointer.  The
ADDRESS data type has the following syntax:

@code{pointer-type [ (object-type [ basealign-attribute ] ) ]}@*

pointer-type@*
is one of the keywords ADDRESS, POINTER, POINTER_LONG, POINTER_QUAD,
POINTER_HW, and HARDWARE_ADDRESS.

ADDRESS, POINTER, POINTER_LONG are 4-byte-addresses.
POINTER_HW and HARDWARE_ADDRESS are 4-byte-addresses if @command{-32} is
specified and 8-byte-addresses if @command{-64} is specified.
POINTER_QUAD is an 8-byte-address.

object-type@*
is the optional data type of the object to which the address refers.  This
construct is ignored for languages in which pointers are distinct data types.
Object-type is either a built-in object type, like LONGWORD or ANY, or a
user-defined object type, optionally followed by a DIMENSION specification, or
an ENTRY declaration.

basealign-attribute@*
Here, a BASEALIGN attribute can be specified, as described in @ref{Alignment
Keywords}

The following is an example of an aggregate with a member of pointer type:

@example
AGGREGATE any_node STRUCTURE;
    flink ADDRESS (any_node);
    blink ADDRESS (any_node);
END;
@end example

@subsubsection ANY Data Type

The ANY keyword specifies that the parameter being described in an ENTRY
declaration can be of any data type.  The ANY data type can be used only within
the context of a parameter description and has the following syntax:

@code{ANY}@*

ANY@*

Specifies that the parameter can be of any data type.
The following is an example of the use of the ANY data type:
ENTRY sys$abc PARAMETER (ANY);

@node BITFIELD Data Type
@subsubsection BITFIELD Data Type
The BITFIELD keyword specifies a bit field variable that must be a member of an
AGGREGATE declaration.  The BITFIELD data type has the following syntax:

@code{BITFIELD [LENGTH n] [MASK] [SIGNED] [RADIX x];}@*

[LENGTH n]
Is any valid OpenSDL expression giving the number of bits in the bitfield.  If
no length is specified, OpenSDL uses a default length of 1 bit.

[MASK]
Is a keyword specifying that OpenSDL generate both a bitfield variable and a
constant bit mask representing the bits defined in this field.

[SIGNED]
Is a keyword specifying that OpenSDL treat the output as a signed field.

[RADIX x]
Is a keyword where 'x' is one of @code{DEC}, @code{OCT}, or @code{HEX}.

Bitfields must be AGGREGATE declaration members.  They cannot be scalar items,
objects of ADDRESS declarations, parameters, or return data types of entries.
The following is an example of the BITFIELD keyword used in an AGGREGATE
declaration that specifies a structure with two bitfield members:

@example
AGGREGATE flags STRUCTURE PREFIX tst$;
    resolved BITFIELD MASK SIGNED;
    spare_bits BITFIELD LENGTH 5;
END;
@end example

The declaration of resolved in the previous example results in two declarations
in the output file: a declaration for the bitfield itself and a declaration of
a constant mask whose value is 1.  Because the PREFIX option is specified for
this aggregate, the source output file identifiers produced for this
declaration are tst$v_resolved and tst$m_resolved, where the tag v_ indicates
the bitfield variable and the tag m_ indicates the mask.  Prefixes and tags are
described in more detail in @ref{PREFIX MARKER and TAG Keywords}.

@subsubsection BOOLEAN Data Type

The BOOLEAN keyword specifies a Boolean data type that is a one-byte field that
can have one of two values, 0 or 1.  The BOOLEAN data type has the following
syntax:

@code{BOOLEAN}

BOOLEAN
Produces a Boolean variable in the output file.

The following is an example of the BOOLEAN keyword used in an ITEM declaration:

@code{ITEM true BOOLEAN;}

@node CHARACTER Data Type
@subsubsection CHARACTER Data Type

The CHARACTER keyword declares a character string of a given length.  The
CHARACTER data type has the following syntax:

@example
CHARACTER [LENGTH @{n@}] [VARYING]
          [       @{*@}]
@end example

[LENGTH n]@*
Is the length of the character string.  The length can be specified using any
valid OpenSDL expression.  If no length is specified, OpenSDL uses a default
length of 1 character.  You can specify a character string of unknown length
using LENGTH *.  An unknown length character string can be specified only for
parameter types.  For example:

@code{ENTRY LIB$ROUTINE PARAMETER(CHARACTER LENGTH * NAMED foo);}

[VARYING]
Is a keyword indicating that the identifier represents a varying-length
character string (for languages that support this data type).  In a
varying-length character string, the first word of the string contains its
current length; its declared length is the maximum length that it can have.

The following is an example of the CHARACTER data type used in an AGGREGATE
declaration.  The aggregate msg_buffer contains a character-string member named
message_text with a length of 256 characters.

@example
AGGREGATE msg_buffer STRUCTURE;
    message_text CHARACTER LENGTH 256 VARYING;
    severity WORD;
END;
@end example

@node COMPLEX Data Types
@subsubsection COMPLEX Data Types

The COMPLEX keyword immediately follows any of the four floating-point data
type keywords to specify any of the four COMPLEX data types.  The COMPLEX data
types have the following syntax:

@example
F_FLOATING COMPLEX
D_FLOATING COMPLEX
G_FLOATING COMPLEX
H_FLOATING COMPLEX
T_FLOATING COMPLEX
S_FLOATING COMPLEX
X_FLOATING COMPLEX
@end example

The following is an example of the T_FLOATING COMPLEX data type used in an ITEM
declaration:

@code{ITEM foo T_FLOATING COMPLEX;}

@ref{Floating Point Data Types} describes floating-point data types.

@subsubsection DECIMAL Data Type
The DECIMAL keyword specifies a packed decimal data type and the size of the
data type.  The DECIMAL data type has the following syntax:

@code{DECIMAL PRECISION (precision,scale)}

PRECISION (precision,scale)@*
Is the fixed-point decimal members precision and scale, respectively.
Precision is the total number of decimal digits, and scale is the number of
fractional digits.

Both precision and scale must be specified using valid OpenSDL expressions. 
The following is an example of the DECIMAL keyword used in an ITEM declaration
that indicates a packed decimal data type consisting of three decimal digits,
two of which are fractional:

@code{ITEM percentage DECIMAL PRECISION (3,2);}

@node Floating Point Data Types
@subsubsection Floating Point Data Types

The floating-point keywords, F_FLOATING, D_FLOATING, G_FLOATING, H_FLOATING,
T_FLOATING, S_FLOATING, and X_FLOATING, declare storage units for single-,
double-, and long-double-floating-point data, respectively.  The floating-point
data types have the following syntax:

@example
F_FLOATING --- same as T_FLOATING
D_FLOATING --- same as S_FLOATING
G_FLOATING --- same as S_FLOATING
H_FLOATING --- same as X_FLOATING
T_FLOATING
S_FLOATING
X_FLOATING
@end example

The following is an example of the T_FLOATING data type used in an ITEM
declaration:

@code{ITEM foo T_FLOATING;}

@quotation Note
F_FLOATING, D_FLOATING, G_FLOATING, and H_FLOATING are defined for backward
compatibility.  There is no attempt to support the handling of floating-point
values that are encoded using the VAX formats.
@end quotation

@ref{COMPLEX Data Types} describes COMPLEX data types.

@node Integer Data Types
@subsubsection Integer Data Types
The keywords BYTE, WORD, LONGWORD, QUADWORD, and OCTAWORD declare storage units
of 8, 16, 32, 64, and 128 bits, respectively, to represent signed integer data.
You may also specify the keyword UNSIGNED with any of these data types to
indicate unsigned integer data.

It is also possible to specify the keyword SIGNED.

The keywords INTEGER_BYTE, INTEGER_WORD, INTEGER_LONG and INTEGER_QUAD
are synonyms for BYTE, WORD, LONGWORD, QUADWORD, respectively, although some
back ends treat INTEGER_QUAD and QUADWORD different (C, FORTRAN and Kednos
PL/I).  The keyword INTEGER is also synonym for LONGWORD and INTEGER_LONG.  The
keywords INTEGER_HW and HARDWARE_INTEGER describe integer data types whose size
depends on the underlying hardware.  If the qualifier @command{-32} is
specified, they are 4 bytes wide, and if @command{-64} is specified, they are 8
bytes wide.

The integer data types have the following syntax:

@example
BYTE             [ UNSIGNED | SIGNED ]
INTEGER_BYTE     [ UNSIGNED | SIGNED ]
WORD             [ UNSIGNED | SIGNED ]
INTEGER_WORD     [ UNSIGNED | SIGNED ]
LONGWORD         [ UNSIGNED | SIGNED ]
INTEGER_LONG     [ UNSIGNED | SIGNED ]
INTEGER          [ UNSIGNED | SIGNED ]
QUADWORD         [ UNSIGNED | SIGNED ]
INTEGER_QUAD     [ UNSIGNED | SIGNED ]
OCTAWORD         [ UNSIGNED | SIGNED ]
INTEGER_HW       [ UNSIGNED | SIGNED ]
HARDWARE_INTEGER [ UNSIGNED | SIGNED ]
@end example

The following are examples of the LONGWORD and BYTE data types used in an ITEM
declaration:

@example
ITEM foo LONGWORD UNSIGNED;
ITEM bar BYTE;
@end example

@node Expressions
@section Expressions

An OpenSDL expression evaluates to an arithmetic value and can consist of any of
the following syntax elements:

@itemize @bullet
@item Numeric values are, by default, expressed in decimal notation.  You can
override this default by preceding a constant with one of the prefixes in the
following table.

@multitable @columnfractions .2 .3 .5
@headitem Prefix @tab Interpretation @tab Valid Characters
@item %X @tab Hexadecimal @tab 0-9, A-F, a-f
@item %O @tab Octal @tab 0-7
@item %B @tab Binary @tab 0 and 1
@item %A@footnote{The %A operator takes the ASCII value of any ASCII character
that follows it.} @tab ASCII value @tab Any ASCII character (see
@ref{ASCII Character Set})
@end multitable

OpenSDL treats decimal constants as signed integer longword values.

You can also use a string of up to four characters as a numeric constant by
enclosing the string in quotation marks (" ").  OpenSDL inserts the ASCII
value of each character into the byte field corresponding to that character's
position in the string.  If the string you specify has fewer than four
characters, OpenSDL pads the string with the null character, which has the
ASCII code of zero.
@item Local symbols and output constants are assigned integer longword values
that are available within the context (that is, during processing) of the input
file.
@item Operators perform arithmetic and logical operations on numeric values,
local symbols, and output constants.  The following table lists the operators in
order of precedence, with the operators of higher precedence listed first.

@multitable @columnfractions .2 .8
@headitem Operator @tab Meaning
@item unary - @tab Arithmetic negation
@item * @tab Arithmetic multiplication
@item / @tab Arithmetic division
@item + @tab Arithmetic addition
@item - @tab Arithmetic subtraction
@item @@ @tab Logical shiftx@@y shifts the value of x to the left y places; if
y is negative, the value of x is shifted y places to the right
@item & @tab Logical AND
@item | @tab Logical OR
@item ~ @tab Logical NOT
@end multitable

@item Offset symbols are used in expressions specified in AGGREGATE
declarations:

@itemize @minus
@item The period (@code{.}) represents the current byte offset from the origin
in an  AGGREGATE declaration.  If the ORIGIN option is specified, the value of
the period is equal to the byte offset from the member specified using the
ORIGIN option.

@item The colon (@code{:}) represents the current byte offset relative to the
first member in an AGGREGATE declaration.  The value is not affected by the
presence of an ORIGIN option.

@item The circumflex (@code{^}) represents the current bit offset relative to
the most recently declared aggregate or byte-aligned element.
@ref{Using Offset Symbols} describes the use of offset symbols in AGGREGATE
declarations in more detail.
@end itemize

@item Parentheses group expressions to define the order of evaluation.
Expressions within the innermost set of parentheses are evaluated first.
The following is an example of an expression used in a CONSTANT declaration,
which appears in the context of an AGGREGATE declaration:

@code{CONSTANT foo EQUALS %Ag + 72 / (#abc * boo + .);}
@end itemize

@node Local Comments
@section Local Comments

A comment that is local to the OpenSDL source file is not written to the output
file.  Local comments begin with the left brace (@code{@{}) and extend to the
end of the line.  They can appear anywhere within the source file (not
necessarily within a module) where white space (a space, tab, or carriage
return) is allowed.  The following is an example of a local comment:

@example
@{ Assigning the value 255 to #max_args.
@end example

@node Output Comments
@section Output Comments

There are two types of output comments, Line Comments and Block Comments.

@subsection Line Comments

Line comments appearing on lines by themselves are typically written to the
output file as separate comment lines.  Line comments appearing at the end of a
line are output at the end of the corresponding target source line, if
possible.

Line comments begin with a slash and an asterisk (/*) and terminate at the
end of the current line.  They can appear in the following contexts:
@itemize @bullet
@item Outside MODULE declarations

@item At the end of a line containing a declaration, that is, following the 
semicolon terminator(;)

@item On lines by themselves between member, CONSTANT, ENTRY, ITEM, and
AGGREGATE declarations

@item Between declarations with in an aggregate

@item Following individual constant names with in a comma-delimited list of
CONSTANT declarations
@end itemize

The following is an example of an output comment:

@example
/* Get Job/Process Information System Service.
@end example

@subsection Block Comments

Block comments are those that appear as a large multi-line comment and are
written to the output file as multiple comment lines.

Block comments begin with a slash and a plus sign (/+) and end with a slash and
a minus sign (/-).  Within these begin and end comments, lines beginning with a
double slash (//) will be prefixed with a middle comment (if the target
language supports it).  These comments can appear anywhere Output Comments can
appear.

The following are two examples of a block comments:

@example
/+
// Get Job/Process Information System Service.
/-

/+
 Copyright 2018.
/-
@end example

@node INCLUDE Statement
@section INCLUDE Statement

The INCLUDE statement specifies that the contents of an external file are to be
incorporated in the OpenSDL input file directly following the INCLUDE
statement.  The INCLUDE statement has the following syntax:

@code{INCLUDE "file-spec";}

"file-spec"@*
Is any valid VMS file specification enclosed in quotation marks (" ").  An
INCLUDE statement cannot appear embedded within an AGGREGATE declaration, but
can appear anywhere else within the module.  If a directory is not included in
the file specification, the current default directory is used.

When OpenSDL encounters an INCLUDE statement, it stops reading from the current
file and reads the statements in the included file.  When it reaches the end of
the included file, OpenSDL resumes translation with the source statement
immediately following the INCLUDE statement.

@node Conditional OpenSDL Compilation
@section Conditional OpenSDL Compilation

@subsection Conditional OpenSDL Compilation using the IFLANGUAGE statement

This feature allows a section of OpenSDL source code to be conditionally
compiled, depending on whether output is being generated for a particular
language or not.

The syntax for conditional compilation has the format:

@example
IFLANGUAGE language-name [ language-name ...  ] ;
    .
    .
    .
[ELSE ;
    .
    .
    .
]
END_IFLANGUAGE [ language-name [ language-name ...  ] ] ;
@end example

Note the following:

@itemize @bullet
@item The three keywords may appear wherever a statement is valid.

@item Conditional compilation statements may not be nested.

@item The list of language-names on the END_IFLANGUAGE is optional, but if it
Is included, it must match the list on the IFLANGUAGE statement.  The languages
need not necessarily appear in the same order.

@item Language names may not be abbreviated.

@item The validity of language names is not checked.  This is in keeping with
the philosophy of OpenSDL that new back ends may be added without changes to
the front end.

@item A comment on the same line as the IF_LANGUAGE statement is only output
for languages which satisfy the condition.  A comment on the same line as the
END_IFLANGUAGE statement is always output, as this is considered to be outside
the body of the conditional.
@end itemize

In the following example, OpenSDL generates a translation of the ITEM statement
if output is being generated for Pascal, Ada, or FORTRAN.  For other languages,
OpenSDL does not generate a translation of the ITEM statement.

@example
IFLANGUAGE PASCAL ADA FORTRAN;
    ITEM foo LONGWORD;
END_IFLANGUAGE PASCAL ADA FORTRAN;
@end example

@subsection Conditional OpenSDL Compilation using the IFSYMBOL statement

This feature allows a section of OpenSDL source code to be conditionally compiled,
depending on symbols specified with the command line qualifier
@command{-symbol}.  The syntax for conditional compilation has the format:

@example
IFSYMBOL symbol-name ;
    .
    .
    .
[ ELSE_IFSYMBOL symbol-name ;
    .
    .
    .
]
[ELSE ;
    .
    .
    .
]
END_IFSYMBOL ;
@end example

Note the following:
@itemize @bullet
@item The four keywords may appear wherever a statement is valid.
@item Conditional compilation statements may not be nested.
@item A comment on the same line as the IFSYMBOL statement is only output if
this symbol is specified on the command line.  A comment on the same line as the
END_IFSYMBOL statement is always output, as this is considered to be outside
the body of the conditional.
@end itemize

With the following example:

@example
IFSYMBOL s1;
    <sdl code 1>
END_IFSYMBOL;
IFSYMBOL s2;
    <sdl code 2>
ELSE_IFSYMBOL s3;
    <sdl code 3>
ELSE;
    <sdl code 4>
END_IFSYMBOL;
@end example

@command{$ opensdl -lang:cc -symbol=s1:0 -symbol:s2=0 -symbol=s3:0 <file-spec>}

produces

@example
<sdl code 4>
@end example

@command{$ opensdl -lang:cc -symbol=s1:1 -symbol:s2=0 -symbol=s3:0 <file-spec>}

produces

@example
<sdl code 1>
<sdl code 4>
@end example

@command{$ opensdl -lang:cc -symbol=s1:1 -symbol:s2=1 -symbol=s3:0 <file-spec>}

produces

@example
<sdl code 1>
<sdl code 2>
@end example

@command{$ opensdl -lang:cc -symbol=s1:1 -symbol:s2=0 -symbol=s3:1 <file-spec>}

produces

@example
<sdl code 1>
<sdl code 3>
@end example

@section Text Pass-through

Text pass-through allows literal text to be passed through to the output
language file without translation.  It is normally used in conjunction with
conditional compilation for a specific target language.  The purpose is to
allow language-specific constructs, which cannot be represented in OpenSDL, to
be emitted.

The syntax for text pass-through is:

@example
LITERAL;
Any number of lines to be passed directly to
the output stream without translation
END_LITERAL;
@end example

Note the following:
@itemize @bullet
@item The keywords LITERAL and END_LITERAL may appear wherever a statement is
valid.
@item The keyword END_LITERAL terminates a literal construct, and therefore
cannot be included in a line of literal text.  Any text preceding END_LITERAL
on the same line is output as a line of literal text.
@end itemize

Literal text is processed identically in all back ends.  The literal text is
merely written directly to the output file.

The following is an example of text pass-through for the C language.

@example
IFLANGUAGE CC
LITERAL
#define ctext "This appears in C language output only"
END_LITERAL
END_IFLANGUAGE CC
@end example

Literal text within an @code{AGGREGATE} that contains a member definition, will
not be taking into account when calculating offsets.  It is recommended to use
conditional compilation @ref{Conditional OpenSDL Compilation} around text
pass-through and include a local variable @ref{Local Symbol Names} to account
for the added offset and then add this local variable when using the offset
after the text pass-through.  Also, do not forget to define the local variable
set to zero when the conditional code is not included, so that there an error
message will not be generated as the result of the missing variable.

@node DECLARE Statement
@section DECLARE Statement

The DECLARE statement allows you to declare a data item of a type that you
define, which may be unknown in the current OpenSDL compilation.  When you use
DECLARE, the type is made known when the target language source is compiled.

The DECLARE statement uses the SIZEOF clause to allow you to specify the size
of the user-defined data type being declared.  The parameter you specify in the
SIZEOF clause may be a built-in OpenSDL data type, a user-defined type defined
in the current OpenSDL compilation, or an expression.

The DECLARE statement has the following syntax:

@example
DECLARE user-type SIZEOF @{ data-type @}     [ PREFIX prefix-string ]
                         @{ user-type @}     [ TAG tag-string ]
                         @{ ( expression ) @}
@end example

user-type@*
Represents the unknown data type name you wish to declare.

SIZEOF@*
A clause that must be appended to user-type.  The SIZEOF clause may be specified
in several ways, as shown, to indicate the size of the user-defined type being
declared.

data-type@*
Represents either a built-in OpenSDL data type, a user-defined type that is
known at OpenSDL compile time, or a data type that has been sized by a previous
SIZEOF clause.

user-type@*
Represents a user-defined data type.

( expression )@*
Represents an expression.  If specified, the expression must specify the number
of bytes to be reserved for this data type.  If the data type is dimensioned,
the SIZEOF clause must specify the size of a single element.  When you specify
an expression, always enclose it in parentheses, as shown in this syntax.

Notes:
@enumerate
@item DECLARE identifies the size of the data type when included in an
AGGREGATE declaration.  (OpenSDL needs to know its equivalent predefined type
so that the correct default tag letter, if required, can be output.)

@item You may declare a user-defined data type more than once (either
explicitly or implicitly), but any subsequent declaration must match the first.

@item The default tag letter for the unknown variable being sized is derived
from the type specified in the SIZEOF clause.  If you use an expression in
place of a data type to reserve a fixed number of bytes, the default tag letter
is T.  You may override the default tag by using an explicit TAG option.

@item SIZEOF clauses cannot be nested.

@item You cannot qualify a reference to the name of a previously-declared
aggregate using the SIZEOF clause.

@item Although DECLARE statements and implicit SIZEOF declarations appear in
the output tree for use by the back ends, these do not result in specific
generated code.

@item Do not use the SIZEOF clause for data types that are aggregate names.
Also, do not nest SIZEOF clauses where the syntax would otherwise allow
aggregate names.  For example, the following statements are valid:
@end enumerate

@example
DECLARE type SIZEOF ADDRESS (CHARACTER);
ITEM type ADDRESS (bar SIZEOF LONGWORD);
@end example

However, the following statement generates an error message:

@code{DECLARE type SIZEOF ADDRESS (bar SIZEOF LONGWORD);}

@strong{Examples}@*

A database contains information on a number of forests in a region, each of
which contains a number of different types of trees.  The definition of the tree
structure is held in a different OpenSDL file from the other definitions.  When
the second OpenSDL file is compiled, the composition of the tree structure is
unknown --- the definitions will only come together when the output files are
included in a compilation in the target language.  The following shows the two
OpenSDL files and the corresponding output in C.

@*
@strong{tree1.sdl:}@*
@example
AGGREGATE tree STRUCTURE TYPEDEF;
    flink ADDRESS (tree);
    blink ADDRESS (tree);
    height LONGWORD;
    age LONGWORD;
END;
@end example

@strong{tree2.sdl:}@*
@example
DECLARE tree SIZEOF (16);
AGGREGATE forest STRUCTURE TYPEDEF;
    oak tree;
    ash tree;
    elm tree;
    conifers tree DIMENSION 6;
END;
ITEM tree_pointer ADDRESS (tree);
ITEM tree_storage tree DIMENSION 1000;
ITEM region forest DIMENSION 4; @{No SIZEOF, since forest defined here @}
@end example

@strong{tree1.h:}@*
@example
typedef struct _tree
@{
    _tree *flink;
    _tree *blink;
    long int height;
    long int age;
@} tree;
@end example

@strong{tree2.h:}@*
@example
typedef struct _forest
@{
    tree oak;
    tree ash;
    tree elm;
    tree conifers[6];
@} forest;
tree *tree_pointer;
tree tree_storage[1000];
forest region[4];
@end example

Note that the SIZEOF information is discarded by C, but is used in offset
calculations.

@node OpenSDL Declarations
@chapter OpenSDL Declarations
@cindex OpenSDL Declarations

This chapter describes the function and format of each of the following OpenSDL
declarations:
@itemize @bullet
@item MODULE declaration
@item ITEM declaration
@item AGGREGATE and subaggregate declarations
@item CONSTANT declaration
@item ENTRY declaration
@end itemize

OpenSDL declarations are composed of the language elements described in
Chapter 3.  The output generated by each OpenSDL declaration depends on which
back end is used for the translation.

Online examples of output files for each language are available by processing
the OpenSDL source file @file{/usr/lib/opensdl/examples/example.sdl}.  Appendix
B provides translation summaries for each output language.

MODULE Declaration

The following sections describe the function and format of a MODULE
declaration.

@section MODULE Description

A MODULE declaration groups all related symbols and data structures.  All
declarations (other than local symbol assignments and local and output
comments) must occur within a module, which is delimited by the @code{MODULE}
and @code{END_MODULE} keywords.  An OpenSDL source file may contain multiple
MODULE declarations, but modules may not be nested.  You must specify a module
name on the MODULE declaration; this name corresponds to the name of a macro or
module in a given output language.  (@ref{Names} describes the syntax for
names.) For example:

@code{MODULE $modef;}

This declaration generates the beginning of the declaration for the macro or
module named $modef.

You can use the IDENT option on a MODULE declaration to pass a version number
or other information that must be enclosed in quotation marks (" ") to the
output file.  For example:

@code{MODULE params IDENT "V2.0";}

You can optionally specify the module name on the END_MODULE statement; this is
particularly useful if you place more than one MODULE declaration in the same
OpenSDL source file.  The module name is case-sensitive and must match exactly
(in case) the name specified on the MODULE declaration.

@page

@section MODULE Format
A MODULE declaration has the following syntax:

@example
MODULE module-name [ IDENT "ident-string" ];
    [ module-body ];
        .
        .
        .
END_MODULE [ module-name ];
@end example

@strong{MODULE module-name}@*
Specifies any valid OpenSDL identifier you want to use to identify the module.

@strong{[IDENT "ident-string"]}@*
Specifies any valid OpenSDL identifier, or a string of any characters, that
must be enclosed in quotation marks (" ") and that either further identifies
the module or is a version number.

@strong{[module-body]}@*
Is one or more of the following:
@itemize @bullet
@item ITEM declaration
@item AGGREGATE declaration
@item CONSTANT declaration
@item ENTRY declaration
@item Local symbol assignment
@item Local or output comment
@item INCLUDE statement
@item DECLARE statement
@item READ statement
@item IFLANGUAGE construct
@item IFSYMBOL construct
@item LITERAL construct
@end itemize

@strong{END_MODULE [module-name]}@*
Marks the end of the MODULE declaration.  The module-name, if specified, must
match the name on the most recently specified MODULE declaration.

@page

@unnumberedsec ITEM Declaration

The following sections describe the function and format of an ITEM declaration.

@section ITEM Description
An ITEM declaration defines scalar items and single-dimensional arrays of
scalar items that are not members of aggregates.  You must specify an item name
and data type on the ITEM declaration.  For example:

@code{ITEM block_list_id WORD;}

This declaration specifies the scalar item block_list_id of data type WORD.

@section ITEM Format

An ITEM declaration has the following syntax:

@example
ITEM item-name @{ data-type @}         [ COMMON ]
               @{ user-type sizeopt @} [ GLOBAL ]
                                       [ TYPEDEF ]

                                       [ BASEALIGN basealign-option ]

                                       [ DIMENSION [ lbound: ] hbound ]

                                       [ PREFIX prefix-string ]

                                       [ TAG tag-string ];
@end example

ITEM item-name@*
Specifies any valid OpenSDL name used to identify the item.

data-type@*
Is any valid OpenSDL data type (see @ref{Data Type Keywords}).

user_type sizeopt@*
Is a user-defined data type using the DECLARE statements SIZEOF clause, shown
and described in @ref{DECLARE Statement}.

[COMMON]@*
[GLOBAL]@*
[TYPEDEF]@*
Is the storage class of the item, if other than the default (based) storage
class (see @ref{Storage Class Keywords}).

[BASEALIGN basealign-option ]@*
BASEALIGN specifies the alignment of an ITEM.  basealign-option is either an
integer expression in parentheses or the name of a data type.
BASEALIGN aligns the item on a multiple of the value of the basealign-option.

[DIMENSION [lbound:]hbound]@*
Specifies that the item is an array.  If a single value is specified, that value
indicates the number of elements in the array.  Otherwise, lbound and hbound
represent lower and upper bounds of the array, respectively (see
@ref{DIMENSION Keyword}).

[PREFIX prefix-string]@*
Specifies a user-defined prefix that becomes part of the identifier.  It can be
any valid OpenSDL name with 0 to 32 characters, may or may not be enclosed in
quotation marks (" ") and may be null (see @ref{PREFIX MARKER and TAG
Keywords}.

[TAG tag-string]@*
Specifies the user-defined tag that follows the prefix used in forming the
identifier.  It can be any valid OpenSDL name with 0 to 32 alphabetic or numeric
characters; the tag must be enclosed in quotation marks (" ") if it begins with
a numeric character (see @ref{PREFIX MARKER and TAG Keywords}.

@unnumberedsec AGGREGATE Declaration

The following sections describe the function and format of AGGREGATE and
subaggregate declarations.

@node AGGREGATE Description
@section AGGREGATE Description

An AGGREGATE declaration defines nonscalar items and dimensional arrays of
nonscalar items.  An aggregate must contain at least one member declaration.  The
body of an aggregate can also contain local symbol assignments, CONSTANT
declarations, and subaggregate declarations.

You must specify a valid aggregate name on the AGGREGATE declaration.  For
example:

@example
AGGREGATE dcb STRUCTURE;
    type CHARACTER;
    size WORD;
    next ADDRESS;
END dcb;
@end example

You must terminate an AGGREGATE declaration with the END statement.  You can
optionally specify the aggregate name on the END statement.  The aggregate name
is case-sensitive and must match exactly (in case) the name specified on the
AGGREGATE declaration.

An aggregate that is the target of an ADDRESS declaration must have the default
(BASED) storage class.

@subsection Subaggregate Declaration

Subaggregates are declared using the keyword STRUCTURE or UNION.  For example:

@example
AGGREGATE tree_node STRUCTURE;
    opcode WORD;
    lang_bits UNION;
        pli_bits STRUCTURE;
            resolved BITFIELD;
            psv BITFIELD;
            mark1 BITFIELD;
            spare_bits BITFIELD LENGTH 5;
        END pli_bits;
        c_bits STRUCTURE;
            value_variable_size BITFIELD;
            psv BITFIELD;
            expanded BITFIELD;
            resolved BITFIELD;
            reduced BITFIELD;
            spare_bits BITFIELD LENGTH 3;
        END c_bits;
    END lang_bits;
END tree_node;
@end example

In this example, the structures pli_bits and c_bits are both subaggregates of
the union lang_bits.  Because lang_bits is a union, c_bits and pli_bits occupy
the same storage.

The COMMON, GLOBAL, BASED pointer-name, and ORIGIN options are invalid for a
subaggregate.  All other AGGREGATE options are valid.

@subsection STRUCTURE Declaration

STRUCTURE declarations produce aggregate or subaggregate declarations that are
structures.  The members are not overlaid; each member has a unique offset from
the beginning of the structure, which means that members occupy consecutive
storage locations.

The following shows the syntax of a first-level STRUCTURE declaration:

@code{AGGREGATE aggregate-name STRUCTURE [ options ];}

The following shows the syntax of a STRUCTURE declaration as an aggregate
member, that is, a subaggregate STRUCTURE declaration:

@code{member-name STRUCTURE [ options ];}

@subsection UNION Declaration

UNION declarations produce aggregate or subaggregate declarations that are
unions.  The first-level members are overlaid, which means that they occupy the
same storage location.

Each first-level member begins at the beginning of the union and, thus, has an
offset of zero.  A UNION declaration lets you represent the same storage
location using different names and different data types.

The following shows the syntax of a first-level UNION declaration:

@code{AGGREGATE aggregate-name UNION [ options ];}

The following shows the syntax of a UNION declaration as an aggregate member,
that is, a subaggregate UNION declaration:

@code{member-name UNION [ options ]}

@subsection Implicit Union Declarations

You may specify data types on an AGGREGATE declaration to cause the AGGREGATE
declaration to become an implicit union declaration.  An implicit union
declaration has these features:

@itemize @bullet
@item Gives OpenSDL the ability to detect subfield overflow without the need to 
define extraneous STRUCTURE and UNION declaration names.
@item Makes user-defined fill fields unnecessary.  This feature is most useful
for data structures containing substructures that are required to begin at
fixed offsets.
@end itemize

The following OpenSDL source code shows the syntax of an implicit union
(structure B defines the implicit union declaration):

@example
AGGREGATE A STRUCTURE;
    B STRUCTURE LONGWORD;
        bit_string1 BITFIELD LENGTH 1;
        bit_string2 BITFIELD LENGTH 4;
    END B;
    last_item WORD;
END A;
@end example

This implicit union declaration would be more cumbersome if represented as
shown in the following STRUCTURE subaggregate:

@example
AGGREGATE A STRUCTURE;
    X UNION ;
        B LONGWORD;
        Y STRUCTURE ;
            bit_string1 BITFIELD LENGTH 1;
            bit_string2 BITFIELD LENGTH 4;
        END Y;
    END X;
    last_item WORD;
END A;
@end example

In the previous example, the names X and Y become OpenSDL generated filler
names in the implicit union case.

You do not have to define the union X and the structure Y if an implicit union
declaration is used.  By giving the structure Y a type, OpenSDL creates a union
of field Y with the specified type overlaid with a structure containing the
fields in Y.  In some language translations, such as BLISS and MACRO, the
OpenSDL-generated union and structure (X and Y above) can be suppressed in the
output because they are considered extraneous fields.  In C, it is necessary to
use the OpenSDL-generated union and structure to generate the correct offsets
within a structure.  Because the union is of the length specified in the
structure type, no filler is necessary to ensure that subsequent fields (for
example, last_item) are at the correct offset.  If the fields of a structure
extend past the size specified, OpenSDL flags the overflow.  The PL/I
translation for the previous implicit union declaration example is as follows:

@example
DCL 1 A BASED ,
     2 fill_0 union,
      3 B fixed binary(31),
      3 fill_1 ,
       4 bit_string1 bit(1),
       4 bit_string2 bit(4),
       4 fill_1$$v_fill_2 bit(3),
     2 last_item fixed binary(15);
@end example

The OpenSDL source file @file{/usr/lib/opensdl/examples/example.sdl} shows an
example of an implicit union declaration.

@subsection Implicit Union Declarations with the Optional DIMENSION Keyword

The following is an example of an OpenSDL structure defined with a data type and
the DIMENSION keyword:

@example
AGGREGATE fid STRUCTURE WORD DIMENSION 3;
    first WORD;
    second WORD;
    third WORD;
END fid;
@end example

In the previous example, a single structure is overlaid by an array of elements
of the type specified by the structure type.

The fid structure is a three-word field that can be addressed as a single field
or by each individual word so that it is easily defined in OpenSDL as
represented above.  The following is the PL/I translation for the OpenSDL
source code in the previous example:

@example
DCL 1 fill_0 union BASED ,
     2 fid (1:3) fixed binary(15),
     2 fill_1 ,
      3 first fixed binary(15),
      3 second fixed binary(15);
      3 third fixed binary(15);
@end example

The implicit union declaration allows structures to grow without the need to
modify any trailing fillers.  OpenSDL detects any overflow that may occur if the
structure grows past the size of its data type.  The size of the aggregate (in
bytes) is equal to the size of the data type (in bytes) multiplied by the upper
dimension (if any).  If the size of the aggregate is greater than the sum of the
size of all its members, OpenSDL still translates the declaration.  However, if
the size of the members exceeds the size of the aggregate, OpenSDL issues a
message that has the following format:

@code{%SDL-E-TOOMANYFIELDS, Structure fill_0 has too many fields [Line ?]}

In the previous example, fill_0 is the OpenSDL-generated name for the first
union aggregate.

@subsection Forcing Negative Offsets

The default origin of an aggregate is the beginning of the first aggregate
member.  You may specify the ORIGIN option on a level-1 AGGREGATE declaration to
indicate that the origin is located at the beginning of any aggregate member.
The resulting declaration forces all aggregate members declared before the
specified origin to be located at negative offsets from the origin.  For
example:

@example
AGGREGATE nodes STRUCTURE ORIGIN qflink;
    flink ADDRESS;
    blink ADDRESS;
    qflink ADDRESS;
    qblink ADDRESS;
END;
@end example

This declaration defines the origin of the structure nodes to be at the member
qflink, so you may address flink and blink as negative offsets from qflink.
Specifying an origin does not change the values of the current bit and byte
offset symbols (@code{^} and @code{:}).  These are always calculated as being
relative to the beginning of the aggregate.

@node Forcing Data Alignment
@subsection Forcing Data Alignment

OpenSDL forces all AGGREGATE and subaggregate declarations to begin on byte
boundaries.  Thus, if an aggregate or subaggregate ends with BITFIELD
declarations that do not end on byte boundaries, OpenSDL ensures that the next
aggregate begins on a byte boundary by supplying BITFIELD declarations as
fillers, if necessary.

When OpenSDL adds BITFIELD declarations, it determines the length required and
provides a unique name of the form string$V_FILL_n.  The string is the prefix
supplied in the AGGREGATE declaration, or the aggregate name if no prefix was
supplied.  Within an aggregate, n begins at 0 and is incremented for each filler
required.

The subaggregate declarations shown in the following example declare filler
bitfields to force byte alignment at the end of each subaggregate; this
programming practice makes it unnecessary for OpenSDL to perform the alignment.

@example
AGGREGATE tree_node STRUCTURE;
    opcode WORD;
    lang_bits UNION;
        pli_bits STRUCTURE;
            resolved BITFIELD;
            psv BITFIELD;
            mark1 BITFIELD;
            spare_bits BITFIELD LENGTH 5;
        END pli_bits;
        c_bits STRUCTURE;
            value_variable_size BITFIELD;
            psv BITFIELD;
            expanded BITFIELD;
            resolved BITFIELD;
            reduced BITFIELD;
            spare_bits BITFIELD LENGTH 3;
        END c_bits;
    END lang_bits;
END tree_node;
@end example

The current bit offset is set at 0 at the beginning of each aggregate and is
incremented by the bit lengths of each structure member in the aggregate at that
level.  In the following example, OpenSDL forces the structure flags to be
aligned on a byte boundary.

@example
AGGREGATE dcb STRUCTURE PREFIX dcb$;
        .
        .
        .
    uflags STRUCTURE;
        context BITFIELD LENGTH 3;
        local BITFIELD;
    END uflags;
    flags STRUCTURE;
        extern BITFIELD;
        relo BITFIELD;
    END flags;
@end example

The PL/I translation of the OpenSDL AGGREGATE declaration in the previous
example is as follows:

@example
%replace dcb$s_dcb by 2;
dcl 1 dcb based,
     2 dcb$r_uflags ,
      3 dcb$v_context bit(3),
      3 dcb$v_local bit(1),
      3 dcb$v_fill_0 bit(4),
     2 dcb$r_flags ,
      3 dcb$v_extern bit(1),
      3 dcb$v_relo bit(1),
      3 dcb$v_fill_1 bit(6);
@end example

The bit offsets of the members of the structures in the previous OpenSDL
example are shown in the following table.

@multitable @columnfractions .2 .8
@headitem Member @tab Bit Offset
@item dcb$v_context @tab 0
@item dcb$v_local @tab 3
@item dcb$v_fill_0 @tab 4
@item dcb$v_extern @tab 0
@item dcb$v_relo @tab 1
@item dcb$v_fill_1 @tab 2
@end multitable

@node Using Offset Symbols
@subsection Using Offset Symbols

The period (@code{.}) represents the current byte offset from the origin in an
AGGREGATE declaration.  If the ORIGIN option is specified, the value of the
period is equal to the byte offset from the member specified using the ORIGIN
option.  The current byte offset is useful for capturing the size of an
aggregate or a portion of it.  For example, in the declaration of a
variable-length data structure, you can capture the size of the fixed-length
portion.

The colon (@code{:}) represents the current byte offset relative to the first
member in an AGGREGATE declaration.  The value is not affected by the presence
of an ORIGIN option.

The circumflex (@code{^}) represents the current bit offset relative to the
most recently declared aggregate or byte-aligned element.

The following example shows the use of the byte offset symbols.

@example
AGGREGATE operator STRUCTURE PREFIX opr_;
    flink ADDRESS;
    blink ADDRESS;
    opcount WORD;
    optype CHARACTER LENGTH 1;
    id WORD;
    flags STRUCTURE;
        is_constant_size BITFIELD LENGTH 1;
        is_terminator BITFIELD LENGTH 1;
        context BITFIELD LENGTH 3;
        filler BITFIELD LENGTH 8-^;
    END;
    #opsize = .;
    operands LONGWORD DIMENSION(#max_args);
    #instruction_size = :;
END;

CONSTANT node_size EQUALS #opsize / 2;
CONSTANT inst_size EQUALS #instruction_size;
@end example

In the previous example, the local symbol #opsize captures the byte offset
following the fixed length portion of the structure operator.  This value is
subsequently used in the CONSTANT declaration, which defines the size of the
constant portion of the structure in words.  The flags structure is byte
aligned by the field filler, which makes use of the current bit offset symbol
to compute the size of this field.  The CONSTANT inst_size defines the size of
the entire structure.

@section AGGREGATE Format

An AGGREGATE declaration has the following syntax:

@example
AGGREGATE aggregate-name @{ STRUCTURE @} [ data-type ]
                         @{ UNION @}
                                         [ COMMON ]
                                         [ GLOBAL ]
                                         [ TYPEDEF ]
                                         [ BASED pointer-name ]

                                         [ ALIGN ]
                                         [ NOALIGN ]
                                         [ BASEALIGN basealign-option ]

                                         [ DIMENSION [ lbound: ] hbound ]

                                         [ MARKER marker-string ]

                                         [ PREFIX prefix-string ]

                                         [ TAG tag-string ]

                                         [ ORIGIN member-name ]

                                         [ FILL ];
    aggregate-body
        .
        .
        .
END [ aggregate-name ];
@end example

AGGREGATE aggregate-name@*
Specifies any valid OpenSDL name used to identify the aggregate.

@{STRUCTURE@}@*
@{UNION@}@*
Is the type of aggregate (see @ref{AGGREGATE Description}).

[data-type]@*
If specified, causes the AGGREGATE declaration to become an implicit union
declaration (see @ref{AGGREGATE Description}).

[COMMON]@*
[GLOBAL]@*
[BASED pointer-name]@*
[TYPEDEF]@*
Is the storage class of the aggregate, if other than the default (BASED) (see
@ref{Storage Class Keywords}).  If an aggregate is the object of an ADDRESS declaration, it
must have either the default or the BASED pointer-name storage class.

[ALIGN]@*
[NOALIGN]@*
[BASEALIGN basealign-option]@*
The ALIGN and NOALIGN keywords can be used to align (or de-align) the members
of an aggregate on their natural boundary.  The BASEALIGN keyword ensures that
the size of an aggregate is a multiple of the given alignment.  The BASEALIGN
keyword therefore takes an argument, which specifies the alignment, either an
expression in parenthesis or the name of a data type.

For example:

@code{AGGREGATE MyStruct STRUCTURE ALIGN;}

This aligns every member in the structure.

@code{AGGREGATE MyStruct STRUCTURE NOALIGN;}

No action will be taken to ensure that the members of the aggregate will be
aligned.

@code{AGGREGATE MyStruct STRUCTURE BASEALIGN (8);}

The aggregate will be padded, so that in an array of elements of this
aggregate, all elements will have a size that is a multiple of the given
alignment (256, 28).  Alignment attributes on aggregates can be partially
overridden by specifying alignment attributes on the members of the aggregate.
See also @ref{Alignment Keywords}.

[DIMENSION [lbound:]hbound]@*
Specifies that the aggregate is an array.  If a single value is specified, that
value indicates the number of elements in the array.  Otherwise, lbound and
hbound represent lower and upper bounds of the array, respectively.

[MARKER marker-string]@*
Specifies the prefix used to form the aggregate name.  It may be any valid
OpenSDL name with 0 to 32 characters, may or may not be enclosed in quotation
marks (" ") and may be null.

[PREFIX prefix-string]@*
Specifies the prefix used in forming the names of aggregate members.  It may be
any valid OpenSDL name with 0 to 32 characters, may or may not be enclosed in
quotation marks (" ") and may be null (see @ref{PREFIX MARKER and TAG
Keywords}).

[TAG tag-string]@*
Specifies the tag used to form the aggregate name.  The tag is appended to the
prefix, if a prefix was specified.  It can have 0 to 32 alphabetic or numeric
characters; the tag must be enclosed in quotation marks (" ") if it begins with
a numeric character (see @ref{PREFIX MARKER and TAG Keywords}).

[ORIGIN member-name]@*
Specifies the name of a member of this aggregate that is to be used as the
origin of the aggregate.

Member declarations produce declarations of the members of an aggregate and
have the following syntax:

@example
member-name @{ data-type @}         [ ALIGN ]
            @{ aggregate-name @}    [ NOALIGN ]
            @{ user-type sizeopt @} [ BASEALIGN basealign-option ]

                                    [ DIMENSION [ lbound: ] hbound ]

                                    [ PREFIX prefix-string ]

                                    [ TAG tag-string ]

                                    [ FILL ];
@end example

member-name@*
Is any valid OpenSDL name used to identify the member.

@{data-type@}@*
Is any valid OpenSDL data type (see @ref{Data Type Keywords}).

@{aggregate-name@}@*
Is the name of the previously declared aggregate to be used as a type name.  The
name must be the full (OpenSDL-expanded) aggregate name, including the prefix
and tag.

@{user-type sizeopt@}@*
Is a user-defined variable using the DECLARE statements SIZEOF clause, shown
and described in @ref{DECLARE Statement}.

[ALIGN]@*
[NOALIGN]@*
[BASEALIGN basealign-option]@*
Alignment attributes on a structure can be overridden with alignment attributes
on a member declaration.  For example:

@code{StructMember1 LONGWORD SIGNED ALIGN;}

This ensures that the member is aligned, even if it is within an aggregate that
is not aligned.

@code{StructMember1 LONGWORD SIGNED NOALIGN;}

No action will be taken to ensure that this member will be aligned.

@code{StructMember1 LONGWORD SIGNED BASEALIGN (4);}

Here, StructMember1 will have an offset that is a multiple of 16 (24).

basealign-option can either be an expression in parentheses or the name of a
data type.  See also @ref{Alignment Keywords}.

[DIMENSION [lbound:]hbound]@*
Specifies that the member is an array.  If a single value is specified, that
value indicates the number of elements in the array.  Otherwise, lbound and
hbound represent lower and upper bounds of the array, respectively (see 
@ref{DIMENSION Keyword}).

[PREFIX prefix-string]@*
Specifies the prefix used to form the member name.  For subaggregates, the
prefix is used to form the names of subaggregate members.  It may be any valid
OpenSDL name with 0 to 32 characters, may or may not be enclosed in quotation
marks (" ") and may be null (see @ref{PREFIX MARKER and TAG Keywords}).

[TAG tag-string]@*
Specifies the tag used to form the member name.  The tag is appended to the
prefix, if a prefix was specified.  It can have 0 to 32 alphabetic or numeric
characters; the tag must be enclosed in quotation marks (" ") if it begins with
a numeric character (see @ref{PREFIX MARKER and TAG Keywords}).

[FILL]@*
Indicates that the specified member or aggregate occurs only as a fill to force
byte alignment on the following member or aggregate, respectively.  In some
languages, filler member and aggregate declarations do not appear in the output
file.

aggregate-body@*
Is one or more of the following:
@itemize @bullet
@item Member declaration
@item Subaggregate declaration
@item CONSTANT declaration
@item Local symbol assignment
@end itemize

END [ aggregate-name ]@*
Marks the end of the AGGREGATE or subaggregate declaration.  The aggregate-name,
if specified, must match the name on the most recently specified AGGREGATE or
subaggregate declaration.

@unnumberedsec CONSTANT Declaration

The following sections describe the function and format of a CONSTANT
declaration.

@section CONSTANT Description
A CONSTANT declaration generates a list of one or more named constants in the
output file.  You may specify a valid constant name or names and the constant
values to be assigned to them.  For example:

@example
CONSTANT block_node_size EQUALS 24;

CONSTANT Strcon EQUALS STRING "This is a string constant" PREFIX Jg$
@end example

The first declaration creates the named constant block_node_size and assigns it
the value 24.  The second declaration creates the named string constant Strcon
and assigns it the specified value.

The values of both declared constants (except string constants) and local
symbols may be used in OpenSDL expressions.  However, there is an important
difference between declared constants and local symbols: declared constants are
translated directly to the output file, whereas local symbols are not passed
directly to the output file.  For example, you can define the local symbol
#block_size as follows:

@code{#block_size = 24;}

A subsequent CONSTANT declaration may refer to #block_size and use the value
24, as follows:

@code{CONSTANT block_node_size EQUALS #block_size;}

CONSTANT declarations (except string constants) can also be specified in a
comma-delimited list, as follows:

@example
CONSTANT
    xyz EQUALS 10,
    alpha EQUALS 0,
    noname EQUALS 63;
@end example

To specify related constants with the same or incremental values, use a
CONSTANT declaration with the INCREMENT option.  In this form, the EQUALS
expression gives the value to be assigned to the first named constant; values
for subsequent constants are derived by incrementing the first value by the
specified increment and assigning the result to the next name in the list.  For
example:

@example
CONSTANT (
    bits,
    bytes,
    words,
    longs,
    quads,
    octas
    ) EQUALS 0 INCREMENT 1 PREFIX ctx$;
@end example

When OpenSDL assigns incremental values, it loops until values are assigned to
all the names in a list.  If there is no INCREMENT clause, the increment value
is 0; thus, the same initial value is assigned to all the names.  If names are
omitted from a comma-delimited list, OpenSDL reserves the numbers that would be
assigned to names in those positions.  This lets you reserve numeric values for
later assignment of names.  For example:

@example
CONSTANT
    (bad_block,bad_data,,,,
     overlay,rewrite) EQUALS 0 INCREMENT 4;
@end example

In the previous example, OpenSDL assigns the values 0 and 4 to the names
bad_block and bad_data, reserves the values 8, 12, and 16, and assigns the
values 20 and 24 to the names overlay and rewrite.

The COUNTER option saves the last assigned value in a specified local symbol
for subsequent use.  For example:

@example
CONSTANT (pli,c,bliss,macro)
    EQUALS 4 INCREMENT 4 PREFIX lang$
    COUNTER #lang;

CONSTANT (basic,pascal,fortran)
    EQUALS #lang + 4 INCREMENT 4 PREFIX lang$;
@end example

The following table shows the constant names produced by these two
declarations.

@multitable @columnfractions .3 .7
@headitem Constant Name @tab Value
@item lang$k_pli @tab 4
@item lang$k_c @tab 8
@item lang$k_bliss @tab 12
@item lang$k_macro @tab 16
@item lang$k_basic @tab 20
@item lang$k_pascal @tab 24
@item lang$k_fortran @tab 28
@end multitable

You can comment individual declarations in a CONSTANT declaration list.  For
example:

@example
CONSTANT(
    pli, /* PL/I
    c, /* C
    macro /* MACRO-32
    ) EQUALS 4 INCREMENT 4 PREFIX lang$;
@end example

@strong{Defining Global Constants in MACRO}

OpenSDL does not directly generate definitions for global symbols (constants),
but instead generates local constant definitions.  The MACRO back end, however,
generates all declarations within macros so that they can be invoked with
arguments that will produce global definitions.

OpenSDL also produces MACRO output declarations that can generate global
definitions when an invocation of the macro is assembled.  In the following
example, the OpenSDL module $IODEF contains the following constant
declarations:

@example
CONSTANT (
    nop,
    unload,
    loadmcode,
    seek,
    spacefile,
    startmproc,
    recal,
    stop,
    drvclr,
    initialize) EQUALS 0 INCREMENT 1 PREFIX "io$";
@end example

The MACRO output generated by this declaration is a macro definition that must
be invoked as follows in order to result in global rather than local constant
definitions:

@code{$IODEF <= =>}

This argument results in global constant definitions rather than local constant
definitions.  To request that the locations of data fields be defined globally,
add the argument @code{<::>} following @code{<= =>}.

@section CONSTANT Format

A CONSTANT declaration has the following syntax:

@example
CONSTANT constant-name constant-class
    constant-class = @{ EQUALS expression numeric-options @}
                     @{ EQUALS STRING string string-options @}

    numeric-options = [ PREFIX prefix-string ]

                      [ TAG tag-string ]

                      [ COUNTER #local-name ]

                      [ TYPENAME type-name ]

                      [ RADIX radix-name ]

                      [ ENUMERATE enum-name ];

    string-options =  [ PREFIX prefix-string ]

                      [ TAG tag-string ] ;

CONSTANT (constant-name,...) EQUALS expression

                      [ INCREMENT expression ]

                      [ PREFIX prefix-string ]

                      [ TAG tag-string ]

                      [ COUNTER #local-name ]

                      [ TYPENAME type-name ]

                      [ ENUMERATE enum-name ];

CONSTANT (constant-name,...) EQUALS expression,
        .
        .
        .
    ;
@end example

CONSTANT constant-name@*

Specifies any valid OpenSDL name used to identify the constant.
When more than one name is specified, separate the names with commas and
enclose the list in parentheses.

EQUALS expression@*
EQUALS STRING string@*
Specifies the value to be assigned to the constant.

[PREFIX prefix-string]@*
Specifies the prefix used to form the constant name.  It may be any valid
OpenSDL name with 0 to 32 characters, may or may not be enclosed in quotation
marks (" ") and may be null (see @ref{PREFIX MARKER and TAG Keywords}).

[TAG tag-string]@*
Specifies the tag used to form the constant name.  The tag is appended to the
prefix, if a prefix was specified.  It can have 0 to 32 alphabetic or numeric
characters; the tag must be enclosed in quotation marks (" ") if it begins with
a numeric character (see @ref{PREFIX MARKER and TAG Keywords}).

[COUNTER #local-name]@*
Specifies the local symbol assigned to the last value that is assigned to a
constant in the list.

[TYPENAME type-name]@*
Specifies a named data type that is not an OpenSDL data type.

[RADIX radix-name]@*
Specifies how the number should be written out to the output file.  It can
take one of three possible values:

@multitable @columnfractions .4 .6
@headitem radix-name @tab Description
@item DEC @tab Write the value out in decimal format (the is the default)
@item @tab @code{#define constant-name    123}
@item OCT @tab Write the value out in octal format
@item @tab @code{#define constant-name    %O175}
@item HEX @tab Write the value out in hexadecimal format
@item @tab @code{#define constant-name    %X7D}
@end multitable

(constant-name,...)@*
Is a list of valid names.
A constant-name in this list can be null, though the list itself cannot be
null.  If a member of the list is null, the corresponding value is reserved.
If INCREMENT is not specified, all names are assigned the value specified in
the EQUALS expression.

[INCREMENT expression]@*
Specifies the value to be added to the EQUALS expression for each iteration of
OpenSDLs generation of named CONSTANT declarations.  It must be a valid
OpenSDL integer expression.  OpenSDL assigns the value of the EQUALS expression
to the first constant name; the value of the INCREMENT expression is added to
the EQUALS expression and assigned to the next constant name.

[ENUMERATE enum-name]@*
Rather than a constant being created, an enumeration is created instead, if the
output language supports enumerations.

@unnumberedsec ENTRY Declaration

The following sections describe the function and format of the ENTRY
declaration.

@section ENTRY Description

An ENTRY declaration produces an external procedure or function declaration in
the output file.  You must specify a valid entry name on the ENTRY declaration.
You may also specify any or all of the ENTRY declaration options described in
@ref{Keywords Used in Declarations} in @ref{Declaration Modifier Keywords} and
shown within the context of an ENTRY declaration in @ref{ENTRY Format}.

The following example shows the ENTRY declaration for the VMS system service
SYS$GETJPI:

@example
ENTRY SYS$GETJPI ALIAS $GETJPI PARAMETER (
    LONGWORD UNSIGNED VALUE NAMED EFN DEFAULT 0 TYPENAME EFNUM,
    LONGWORD UNSIGNED NAMED PIDADR IN OUT DEFAULT 0 TYPENAME PROCID,
    CHARACTER REFERENCE NAMED PRCNAM IN DEFAULT 0 TYPENAME PROCNAME,
    ANY NAMED ITMLST IN TYPENAME ITEMLIST,
    QUADWORD UNSIGNED NAMED IOSB OUT DEFAULT 0 TYPENAME IOSB,
    ADDRESS(ENTRY) NAMED ASTADR DEFAULT 0 TYPENAME ASTADR,
    LONGWORD UNSIGNED VALUE NAMED ASTPRM DEFAULT 0 TYPENAME USERPARM
    ) RETURNS LONGWORD TYPENAME CONDVALU;
@end example

@node ENTRY Format
@section ENTRY Format

An ENTRY declaration has the following syntax:

@example
ENTRY entry-name [ ALIAS internal-name ]

                 [ PARAMETER (param-desc,...) ]

                 [ LINKAGE link-name ];

                 [ VARIABLE ]

                 [ RETURNS return-data-type [ NAMED param-name ] ]

                 [ TYPENAME type-name ];
@end example

ENTRY entry-name@*
Specifies any valid OpenSDL name used to name the external entry point.

[ALIAS internal-name]@*
Specifies an alternate internal name used to designate the entry point.

[PARAMETER (param-desc,...)]@*
Describes the parameters of the external entry, if any.  Param-desc must be
specified as follows:

@example
@{ data-type @}      [ VALUE ]         [ IN ]
@{ aggregate-name @} [ REFERENCE ]     [ OUT ]
                                       [ NAMED param-name ]
                                       [ DIMENSION expression ]
                                       [ DEFAULT constant-value ]
                                       [ TYPENAME type-name ]
                                       [ OPTIONAL ]
                                       [ LIST ]
@end example

@{data-type@}@*
Is any valid OpenSDL data type.

@{aggregate-name@}@*
Is the name of a previously declared aggregate that describes the data type of
the parameter.

[VALUE]@*
Indicates that the parameter is passed by immediate value.

[REFERENCE]@*
Indicates that the parameter is passed by reference.  REFERENCE is the default.

[IN]@*
Indicates an input parameter.  IN is the default.

[OUT]@*
Indicates an output parameter.

[NAMED param-name]@*
Specifies the parameter name.

[DIMENSION expression]@*
Is the number of elements of an array parameter.
If expression is an asterisk (*), the number of dimensions depends on the
dimensions of the actual parameter.

[DEFAULT constant-value]@*
Specifies a default value for a parameter.  In languages supporting this option,
the omission of an actual parameter is allowed.

[TYPENAME type-name]@*
Specifies a named data type that is not an OpenSDL data type.

[OPTIONAL]@*
Specifies that the parameter may or may not appear in the sequence of (keyword)
parameters for a call using the entry point name.

[LIST]@*
Indicates that the routine may be called with one or more parameters of the
type being described.  LIST may be specified only for the last parameter.

@quotation NOTE
All the PARAMETER options, if specified, must follow the data type or aggregate
name in the declaration.
@end quotation

[LINKAGE link-name]@*
Specifies (for MACRO only) that a special call macro (spelled link-name)
will be used in the expansion of the entry macro.

[VARIABLE]@*
Indicates that not all parameters are described; that is, the entry point has a
variable number of parameters and not all corresponding arguments need be
present in the argument list when the entry point is invoked.  See also the
description of the LIST parameter option.

[RETURNS return-data-type [NAMED param-name]]@*
Specifies the data type and, optionally, the name of the parameter returned by
the external entry, if it is a function.

The VOID keyword cannot be used in a PARAMETER clause.

The syntax is:

@example
return-data-type = @{ data-type @}
                   @{ user-type sizeopt @}
                   @{ VOID @}
@end example

The argument user-type sizeopt specifies a user-defined type declared using the
DECLARE statements SIZEOF clause, shown and described in @ref{DECLARE
Statement}.

The return type VOID indicates that the procedure returns no value.

[TYPENAME type-name]@*
Specifies a named data type for the return value that is not an OpenSDL data
type.

@node OpenSDL Diagnostic Messages
@appendix OpenSDL Diagnostic Messages
@cindex OpenSDL Diagnostic Messages

This appendix summarizes the OpenSDL diagnostic messages.  All messages
indicating errors in OpenSDL syntax specify the line number in the OpenSDL
source file at which the error occurred.

@strong{ABORT, Fatal internal error. unable to continue execution}@*
@strong{Fatal:} An internal error has occurred.@*
@strong{User Action:} Please report the problem to the GitHub Issues for this
utility.

@strong{ADROBJBAS, Address object <object-name> must have based storage class
[Line n]}@{
@strong{Error:} An address item is pointing to an aggregate that is not
based.@*
@strong{User Action:} Change the storage class of the aggregate to
@code{BASED}.

@strong{BADNODETYPE, internal node type is unknown for language
<language-name>}@*
@strong{Warning:} A language backend has encountered a node type in the parsed
OpenSDL input that reflects an OpenSDL element which the language does not
support.@*
@strong{User Action:} Depending on your needs, ignore the warning or change the
OpenSDL input file.

@strong{BASEALIGN, Invalid expression with BASEALIGN option.  Value must be in
range 0 to 124. <basealign-parameter> [Line n]}@*
@strong{Error:} The value for the @command{-align} qualifier is smaller than 0
or larger than 124.@*
@strong{User Action:} Use a value in the range [0 ... 124].

@strong{BUGCHECK, Internal consistency failure [Line n] - please submit a bug
report}@*
@strong{Fatal:} OpenSDL has detected an internal error or inconsistency.@*
@strong{User Action:} Please submit a bug report to GitHub Repository.

@strong{BYTSIZ, Aggregate <aggr-name> must be integral byte size [Line n]}@*
@strong{Error:} An aggregate is required to be an specific number of bytes
long.@*
@strong{User Action:} Add one or more members to the aggregate with the
@code{FILL} option to correct the size, in bytes, of the indicated
@code{AGGREGATE}, and invoke OpenSDL again.

@strong{DIMENSIONSTAR, DIMENSION * for MEMBER <"member-name"> has no known
discriminant [Line n]}@*
@strong{Warning:} The use of "DIMENSION *" within an aggregate is not
allowed.@*
@strong{User Action:} Use fixed values for "DIMENSION" within all aggregate.

@strong{DUPCONATT, Item <item-name> has duplicate or conflicting attributes
[Line n]}@*
@strong{Error:} A declaration contains keywords that are not compatible.@*
@strong{User Action:} Verify the syntax of the OpenSDL declaration, correct the
declaration, and invoke OpenSDL again.

@strong{DUPLANG, Language name <language> appears more than once on the command
line}@*
@strong{Error:} The indicated language was detected on the command-line more
than once.@*
@strong{User Action:} Remove the duplicate languages from the command line, and
invoke OpenSDL again.

@strong{DUPLISTQUAL, '-list' qualifier specified more than once on the command
line}@*
@strong{Error:} Multiple @command{-list} qualifiers were detected on the
command-line.@*
@strong{User Action:} Remove the duplicate qualifiers from the command line,
and invoke OpenSDL again.

@strong{ERREXIT, Error exit}@*
@strong{Fatal:} Previous errors prevent continuation.@*
@strong{User Action:} Correct the errors and invoke OpenSDL again.

@strong{FILLNEGLEN, Fill item <item-name> has a negative length [Line n]}@*
@strong{Warning:} The @code{FILL} is generating a negative fill length.  The
generated output may not be as expected or desired.@*
@strong{User Action:} Correct the waraning and invoke OpenSDL again.

@strong{FILLZEROLEN, Fill item <item-name> has a zero length [Line n]}@*
@strong{Informational:} The @code{FILL} is generating a zero fill length.  The
generated output may not be as expected or desired.@*
@strong{User Action:} Correct the waraning and invoke OpenSDL again.

@strong{FIXUP, Temporary hardcoded list used to discriminate for MEMBER
<"member-name"> [Line n]}@*
@strong{Informational:} From the comment in the Ada backend:
This is informational, with the first line otherwise being identical to a
warning, to aid diagnosing problems where someone makes a copy of a construct
on our hardcoded list without changing OpenSDL.@*
This message is issued together with the DIMENSIONSTAR diagnostic.@*
@strong{User Action:} See DIMENSIONSTAR.

@strong{IDENTGTR31, SDL-generated identifier longer than 31 characters exceeds
capacity of <language-name> compiler [Line n]}@*
@strong{Warning:} The Pascal backend appends "$TYPE" to data types that contain
"DEF".  The resulting name then can exceed 31 characters, the maximum length of
Pascal type names.@*
@strong{User Action:} Dont use "DEF" in your type names and/or shorten your
type names.

@strong{ILLFORWREF, Illegal forward reference for output language <language>
[Line n]}@*
@strong{Error:} The specified output language does not allow forward
referencing, or the language does not allow forward referencing in this
context.@*
@strong{User Action:} Correct or remove the forward reference.

@strong{IMMGTR32, Cannot pass values larger than 32 bits by immediate mechanism
[Line n]}@*
@strong{Warning:} Using VALUE is invalid for this parameter because its size is
greater than that of a longword.  A reasonable translation was attempted,
however.@*
@strong{User Action:} Verify that the output file contains a satisfactory
translation of the parameter description in your OpenSDL source file.

@strong{INCDEFSTRUC, Incompletely defined structure -- <structure-name> [Line
n]}@*
@strong{Error:} A structure name has been referenced before the structure has
been completely defined.@*
@strong{User Action:} Remove the reference and invoke OpenSDL again.

@strong{INFILOPN, Unable to open input file <file-spec>}@*
@strong{Fatal:} OpenSDL cannot locate or open the OpenSDL source file.@*
@strong{User Action:} Verify that you correctly specified the name of the source file.

@strong{INFILSDI, File format error reading intermediate file file-spec.
Possible version mismatch}@*
@strong{Error:} An intermediate file (@file{.sdi}) could not be read.@*
@strong{User Action:} @code{READ} is not supported by this implementation.
Therefore, this error is not emitted by OpenSDL.

@strong{INTOVF, Integer overflow in expression [Line n]}@*
@strong{Error:} Evaluation of an OpenSDL expression resulted in a value that
does not fit in a quadword.@*
@strong{User Action:} Correct the expression.

@strong{INVACTSTA, Invalid action for internal state [Line n]}@*
@strong{Error:} The parsing of the input file detected an unsupported action in
the current state of parsing.@*
@strong{User Action:} If there is a coding error at the line indicated, then
correct the error, and invoke OpenSDL again.  If there is no coding error,
please submit a support request.

@strong{INVAGGRNAM, Invalid or no aggregate name specified}@*
@strong{Error:} The id provided on the @code{AGGREGATE} is either invalid or
missing.@*
@strong{User Action:} Correct the error, and invoke OpenSDL again.

@strong{INVALIGN, Illegal value for -align qualifier in command line}@*
@strong{Error:} The value of the @command{-align} qualifier is not a positive
number.@*
@strong{User Action:} Use a positive number as value for the @command{-align}
qualifier.

@strong{INVBITFLD, Invalid bitfield <bitfield-name> -- bitfields> must be
aggregate members [Line n]}@*
@strong{Error:} Bit fields must be members of aggregates.  They cannot be
scalar items.@*
@strong{User Action:} Incorporate the @code{BITFIELD} declaration in an
aggregate.

@strong{INVCONDST, Invalid condition state [Line %d]}@*
@strong{Error:} An invalid condition state was detected.@*
@strong{User Action:} Correct the condition, and invoke OpenSDL again.

@strong{INVDECL, Invalid DECLARE for type <user-defined-name> [Line n]}@*
@strong{Error:} A DECLARE statement refers to a user defined data type that is
invalid.@*
@strong{User Action:} Correct the DECLARE statement, and invoke OpenSDL again.

@strong{INVENUMNAM, Invalid or no enumeration name specified}@*
@strong{Error:} The id provided on the @code{CONSTANT...ENUMERATE} is either
invalid or missing.@*
@strong{User Action:} Correct the error, and invoke OpenSDL again.

@strong{INVEXPR, Invalid expression -- cannot be resolved to a constant as
required, <name-of-defined-item> [Line n]}@*
@strong{Error:} A non-constant expression has been used in a context which
requires a constant expression.@*
@strong{User Action:} Use a constant expression.

@strong{INVFLDSIZ, Item <item-name> has bit field or offset length greater than
32 or 64 [Line n]}@*
@strong{Error:} OpenSDL cannot generate bit fields larger than 32 or 64 bits or
cannot generate the proper bit mask.@*
@strong{User Action:} Verify the BITFIELD declaration and correct it.  If the
BITFIELD declaration occurs within an aggregate and you specify the @code{MASK}
option, verify that the bit offset of the start of the declaration plus the bit
field size does not exceed 32 bits (when using @command{-32}) or 64 bits (when
using @command{-64}).

@strong{INVLISTOPT, Invalid use of LIST attribute -- LIST may only appear on
the last parameter.}@*
entry-name [Line n]
@strong{Error:} The @code{LIST} attribute appears on a parameter other than the
last.@*
@strong{User Action:} Remove the @code{LIST} attribute.

@strong{INVNAME, Item name is invalid}@*
@strong{Error:} The item name contains illegal characters or is specified in an
illegal context.@*
@strong{User Action:} Correct or relocate the item name.

@strong{INVOUT, Invalid attributes for output language <language> [Line n]}@*
@strong{Error:} An OpenSDL construct or data type is invalid for the specified
target language.@*
@strong{User Action:} Determine whether you specified the data type or OpenSDL
declaration correctly, or whether you may be requesting language output that
you do not require.  Either correct the declaration or reissue the OpenSDL
command so that the indicated language output routine does not execute.

@strong{INVPARMTYP, Invalid parameter type for language <language> [Line n]}@*
@strong{Error:} A parameter specification is illegal for the specified
language.@*
@strong{User Action:} Modify the parameter specification and invoke OpenSDL
again.

@strong{INVQUAL, Invalid qualifier, <qualifier>, specified on the command
line}@*
@strong{Error:} An invalid or unrecognized qualifier was specified on the
command line.@*
@strong{User Action:} Either correct or remove the qualifier, and invoke
OpenSDL again.

@strong{INVREQPARAM, Required parameter encountered after an optional parameter
<parameter-name>}@*
@strong{Error:} Required parameters must not follow optional parameters.@*
@strong{User Action:} Correct the error and invoke OpenSDL again.

@strong{INVSHRIMG, Shareable image not found specified-language}@*
@strong{Error:} OpenSDL does know know about the specified language.@*
@strong{User Action:} Verify that the language is supported. 

@strong{INVSYMDEF, Invalid symbol <symbol-name> specified in -symbol
qualifier}@*
@strong{Error:} The value of the @command{-symbol} qualifier is not correct.
The @command{-symbol} qualifier expects a single symbol definition in the form
symbol-name=value.  The error message indicates a missing value.@*
@strong{User Action:} Correct the syntax of the @command{-symbol} qualifier.

@strong{INVUNKLEN, Unknown length attribute valid only for parameter type [Line
n]}@*
@strong{Error:} CHARACTER LENGTH * is only allowed in a parameter description.
Specifying an unknown length for an ITEM or AGGREGATE member is an error.@*
@strong{User Action:} Remove the LENGTH specification or replace the "*" with a
valid expression.

@strong{LANGDUP, Language name <language-name> appears more than once in list
[Line n]}@*
@strong{Warning:} In an @code{IFLANGUAGE} or @code{END_IFLANGUAGE} statement,
the name of a language appears twice.@*
@strong{User Action:} Remove the duplicate language name.

@strong{LANGMATCH, Language <language-name> does not appear in list of matching
IF statement [Line n]}@*
@strong{Warning:} The list of language specified after the
@code{END_IFLANGUAGE} keyword does not match the list of languages specified
after the corresponding @code{IFLANGUAGE} keyword.@*
@strong{User Action:} Correct the language list.

@strong{LANGMISS, Language <language-name> in list of matching IF statement
missing from END list [Line n]}@*
@strong{Warning:} In an @code{END_IFLANGUAGE} statement, one of the languages
from the @code{IFLANGUAGE} statement is missing.@*
@strong{User Action:} Add the missing language to the @code{END_IFLANGUAGE}
statement or remove all languages from the @code{END_IFLANGUAGE} statement.

@strong{LISFILOPN, Unable to open listing file <file-spec>}@*
@strong{Error:} OpenSDL cannot open the indicated listing file.@*
@strong{User Action:} Verify that you have write access to the directory to
which the OpenSDL listing file is directed.

@strong{MATCHEND, End name does not match declaration name <name> [Line n]}@*
@strong{Warning:} The name specified on the @code{END_MODULE} or @code{END}
delimiter does not match the most recent module name or aggregate name.@*
@strong{User Action:} Verify that the spelling of the names specified on the
@code{END} and @code{END_MODULE} delimiters match.  Check whether you have
illegally nested @code{MODULE} declarations.@*
This is only a warning message, but it may indicate an error.

@strong{MULTDEFSYM, Multiply defined symbol -- <symbol-name> [Line n]}@*
@strong{Error:} A structure contains a duplicate symbol name.@*
@strong{User Action:} Remove the duplicate name and invoke OpenSDL again.

@strong{NAMTRUNC, Generated name too long - truncated to 64 characters
<name-to-be-truncated>}@*
@strong{Warning:} OpenSDL appends various prefixes and suffixes to names.  The
resulting name then can exceed 64 characters, the maximum length.@*
@strong{User Action:} Shorten your names.

@strong{NEGORIGIN, Aggregate <aggregate-name> has a negative origin - negative
offset elements will be ignored [Line n]}@*
@strong{Informational:} The @code{ORIGIN} attribute defines a member as origin
which is not at the beginning of the aggregate.@*
@strong{User Action:} Specify the first member of the aggregate as origin.

@strong{NOCOPYFIL, No copyright input file}@*
@strong{Error:} The @command{-copy} command line qualifier was specified on the command
line, but OpenSDL could not open the @file{copyright.sdl} file.@*
@strong{User Action:} Verify that the @file{copyright.sdl} is located in the
@file{/usr/lib/opensdl} directory and can be opened for reading.  If the file
is not there, or cannot be opened for reading, then either correct the error
or remove the4 @command{-copy} qualifier, and invoke OpenSDL again.

@strong{NOINPFIL, No input file specified}@*
@strong{Error:} OpenSDL needs an input file for it's processing and one was not
specified on the command line.@*
@strong{User Action:} Add the input file to the command line when invoking
OpenSDL again.

@strong{NOOUTPUT, No language output produced}@*
@strong{Warning:} There were too many errors, or fatal errors, which prevented
OpenSDL from generating any output files.@*
@strong{User Action:} Correct the errors indicated by the accompanying
messages.

@strong{NULLSTRUC, Null structure <structure-name> has no members [Line n]}@*
@strong{Error:} An AGGREGATE or subaggregate declaration did not have any
members.@*
@strong{User Action:} Verify that the AGGREGATE or subaggregate declaration is\
correctly positioned in the file.

@strong{OFFSETEXPR, Offset or origin relative expression involves a forward or
circular reference. <member-name> [Line n]}@*
@strong{Warning:} The offset or origin cannot be calculated.@*
@strong{User Action:} Correct the error and invoke OpenSDL again.

@strong{OUTFILOPN, Unable to open output file <file-spec>}@*
@strong{Error:} OpenSDL cannot locate or open an OpenSDL output file.@*
@strong{User Action:} Verify that you correctly specified the name of the
source file.

@strong{PARSEERR, Parse error, <parse-string>, detected}@*
@strong{Error:} An error occurred while parsing the input file.@*
@strong{User Action:} Correct the error, and invoke OpenSDL again.

@strong{POSSCIRC, Possible circular definition for type <type-name> [Line n]}@*
@strong{Informational:} The definition for the type cannot be processed.@*
@strong{User Action:} Correct the error and invoke OpenSDL again.

@strong{REVCHECK, Front-end / back-end version mismatch.  Check
installation.}@*
@strong{Fatal:} A language backend has a different version than the calling
frontend.@*
@strong{User Action:} This error is not emitted by this implementation.  It is
here for consistency with VSI SDL.

@strong{SIZENEST, Illegal nesting of SIZEOF clauses (Item <item-name>) [Line
n]}@*
@strong{Error:} SIZEOF clauses cannot be nested.@*
@strong{User Action:} Remove the nested SIZEOF clause.

@strong{SIZEQUAL, Item <item-name>, an aggregate, cannot be qualified by SIZEOF
[Line n]}@*
@strong{Error:} The SIZEOF clause is not allowed in this context.@*
@strong{User Action:} Remove the SIZEOF clause.

@strong{SIZEREDEF, Size or type of item <item-name> redefined [Line n]}@*
@strong{Error:} OpenSDL has detected a redefinition of the size or data type of
the specified item.@*
@strong{User Action:} Remove the clause causing the redefinition.

@strong{STRINGCONST, String constant <item-name> used in arithmetic expression
[Line n]}@*
@strong{Error:} A reference to a string constant is not allowed in the context
of an arithmetic expression.@*
@strong{User Action:} Remove the string constant reference.

@strong{SYMALRDEF, Symbol <symbol-name> was already defined in command line}@*
@strong{Error:} The value of the @command{-symbol} qualifier with the same
symbol name is repeated more than once.@*
@strong{User Action:} Remove the duplicate name.

@strong{SYMNOTDEF, Symbol <symbol-name> was not defined in command line, value
zero assumed [Line n]}@*
@strong{Warning:} A symbol is used in an @code{IFSYMBOL} or
@code{ELSE_IFSYMBOL} statement, that has not been defined using the
@command{-symbol} qualifier.@*
@strong{User Action:} Define the symbol using the @command{-symbol} qualifier.

@strong{SYMTABOVR, Symbol table overflow}@*
@strong{Fatal:} OpenSDL exceeded its symbol table space.@*
@strong{User Action:} Reduce the size or complexity of the OpenSDL source file;
if possible, separate the file into several different files or modules.

@strong{SYNTAXERR, Syntax error [Line n]}@*
@strong{Error:} The OpenSDL translator detected a syntax error.  This message
is accompanied by a message indicating the type of error and tells you what
type of token or keyword OpenSDL expected but did not find.@*
@strong{User Action:} Determine the syntax error from the accompanying message
and correct it.

@strong{TOKOVF, Token exceeds maximum size of <maximum-token-length> [Line
n]}@*
@strong{Error:} A line in the OpenSDL source file is longer than the maximum
length.@*
@strong{User Action:} Shorten the offending line.

@strong{TOOMANYFIELDS, Structure <structure-name> has too many fields [Line
n]}@*
@strong{Error:} The structure has too many fields.@*
@strong{User Action:} Simplify the structure.

@strong{TYPNAM, Aggregate type name not supported [Line n]}@*
@strong{Warning:} An illegal aggregate name has been used.@*
@strong{User Action:} Choose another aggregate name.

@strong{TYPNOTSUP, Output language does not support data type <data-type-name>
[Line n]}@*
@strong{Warning:} The specified data type is not supported by the output
language.  A reasonable translation was attempted, however.@*
@strong{User Action:} Verify that the output file contains a satisfactory
translation of the data type you specified in your OpenSDL source file.

@strong{UNALIGNED, <member-name> does not align on its natural boundary [Line
n]}@*
@strong{Warning:} A member does not fall on its natural alignment (if
@command{-check} is present on the command line) or on the alignment specified
with the @command{-align} qualifier.@*
@strong{User Action:} Check the layout of the aggregate in question.

@strong{UNDEFCON, Undefined constant name <constant-name> used in expression
[Line n]}@*
@strong{Error:} In the definition of a CONSTANT, an undefined name has been
used.@*
@strong{User Action:} Verify the spelling of the name.

@strong{UNDEFFIL, Unable to open include file <file-name> [Line n]}@*
@strong{Error:} A file to be INCLUDEd could not be opened.@*
@strong{User Action:} Check the spelling of the file name, existence and
protection of the file.

@strong{UNDEFORG, Definition of ORIGIN name <member-name> not found in
aggregate [Line n]}@*
@strong{Error:} The member used as argument to the ORIGIN attribute was not
found within the aggregate.@*
@strong{User Action:} Verify the spelling of the member name.

@strong{UNDEFSYM, Undefined local symbol <symbol-name> used in expression [Line
n]}@*
@strong{Error:} A name preceded by a pound sign (#) is not defined.@*
@strong{User Action:} Verify that the local symbol name is spelled correctly
and that it appears before its reference in the OpenSDL source file.

@strong{UNDEFUSER, Undefined user type name <type-name> referenced [Line n]}@*
@strong{Error:} A DECLARE statement refers to a data type that is neither a
built-in nor a known user defined data type.@*
@strong{User Action:} Check the spelling of the data type referenced.

@strong{UNKNCOSTTYP, Unknown constant type <type-value> [Line n]}@*
@strong{Error:} A @code{CONSTANT} can only be a value or a string
(@code{STRING}).@*
@strong{User Action:} Correct the error, and invoke OpenSDL again.

@strong{UNKRADIX, Unknown radix <radix-value> [Line n]}@*
@strong{Error:} A value for the @code{RADIX} keyword is not known.@*
@strong{User Action:} The qualifier for the @code{RADIX} keyword can only be
@code{DEC} (for decimal), @code{OCT} (for octal), or @code{HEX}
(for hexadecimal).  Supply the correct qualifier on the indicated line, and
invoke OpenSDL again.

@strong{UNKOPTION, Unknown option specified [Line %d]}@*
@strong{Error:} An unrecognized option was specified in the OpenSDL file.@*
@strong{User Action:} Correct the erro, and invoke OpenSDL again.

@strong{WARNEXIT, Warning exit}@*
@strong{Warning:} A warning message has been issued.@*
@strong{User Action:} Output can be compiled, but the results may be
unexpected.

@strong{ZERODIV, Zero divide in expression [Line n]}@*
@strong{Error:} An expression specified in an OpenSDL declaration resulted in a
divide-by-zero exception condition.@*
@strong{User Action:} Verify the expression and correct it.

@strong{ZEROLEN, Item <item-name> has 0 or negative length [Line n]}@*
@strong{Warning:} A @code{BITFIELD} or @code{CHARACTER} declaration or a
@code{DIMENSION} option specified a length of 0 or less.@*
@strong{User Action:} Correct the declaration.  If the length or bound value was
specified using an OpenSDL expression, verify the local symbol values and the
results of arithmetic operations in the expression, if any.

@node OpenSDL Language Translation Summaries
@appendix OpenSDL Language Translation Summaries
@cindex OpenSDL Language Translation Summaries

This appendix shows the translation summaries of OpenSDL language elements to
their corresponding output in each of the following supported languages:
@itemize @bullet
@item C
@end itemize

@unnumberedsec C/C++ Translation Summary

The following table shows the OpenSDL to C/C++ language translation summary.

@multitable @columnfractions .35 .65
@headitem OpenSDL Declaration @tab C/C++ Output
@item MODULE name IDENT string @tab /*** MODULE name IDENT string ***/
@item @tab #include <ctype.h>@*#include <stdint.h>@*#include <stdbool.h>@*
#include <complex.h>
@item /* comment @tab /* comment */
@item /+ @tab /*
@item // @tab  *
@item /- @tab  */
@item CONSTANT @tab
@item EQUALS n; @tab #define x n
@item EQUALS STRING "s"; @tab #define x "s"
@item ENTRY name @tab return-type name( )
@item @tab return-type name(parameters...)
@item PARAMETER (type,...) @tab type param-name
@item ANY @tab void
@item IN @tab n/a
@item OUT @tab n/a
@item NAMED param-name @tab n/a
@item VALUE @tab n/a
@item REFERENCE @tab *type
@item DEFAULT n @tab n/a
@item LIST @tab n/a
@item OPTIONAL @tab n/a
@item TYPENAME type-name @tab n/a
@item RETURNS return-type @tab return-type name( )
@item @tab return-type name(parameters...)
@item NAMED return-name @tab n/a
@item VARIABLE @tab n/a
@item ALIAS internal-name @tab n/a
@item LINKAGE @tab n/a
@item TYPENAME type-name @tab n/a
@item STRUCTURE @tab struct
@item UNION @tab union
@item name BYTE [SIGNED] @tab int8_t name
@item name BYTE UNSIGNED @tab uint8_t name
@item name INTEGER_BYTE [SIGNED] @tab int8_t name
@item name INTEGER_BYTE UNSIGNED @tab uint8_t name
@item name WORD [SIGNED] @tab int16_t int name
@item name WORD UNSIGNED @tab uint16_t int name
@item name INTEGER_WORD [SIGNED] @tab int16_t int name
@item name INTEGER_WORD UNSIGNED @tab uint16_t int name
@item name LONGWORD [SIGNED] @tab int32_t name
@item name LONGWORD UNSIGNED @tab uint32_t name
@item name INTEGER_LONG [SIGNED] @tab int32_t name
@item name INTEGER_LONG UNSIGNED @tab uint32_t name
@item name INTEGER [SIGNED] @tab int name
@item name INTEGER UNSIGNED @tab unsigned int name
@item name INTEGER_HW [SIGNED] @tab int32_t name (32-bit)
@item @tab int64_t name (64-bit)
@item name INTEGER_HW UNSIGNED @tab uint32_t name (32-bit)
@item @tab uint64_t name (64-bit)
@item name HARDWARE_INTEGER [SIGNED] @tab int32_t name (32-bit)
@item @tab int64_t name (64-bit)
@item name HARDWARE_INTEGER UNSIGNED @tab uint32_t name (32-bit)
@item @tab uint64_t name (64-bit)
@item name QUADWORD [SIGNED] @tab int64_t name
@item name QUADWORD UNSIGNED @tab uint64_t name
@item name INTEGER_QUAD [SIGNED] @tab int64_t name
@item name INTEGER_QUAD UNSIGNED @tab uint64_t name
@item name OCTAWORD [SIGNED] __int128_t name
@item name OCTAWORD UNSIGNED __uint128_t name
@item name F_FLOATING @tab float name
@item name D_FLOATING @tab double float name
@item name G_FLOATING @tab double float name
@item name H_FLOATING @tab long double float name
@item name T_FLOATING @tab float name
@item name S_FLOATING @tab double float name
@item name X_FLOATING @tab long double float name
@item name F_FLOATING COMPLEX @tab float complex name
@item name D_FLOATING COMPLEX @tab double float complex name
@item name G_FLOATING COMPLEX @tab double float complex name
@item name H_FLOATING COMPLEX @tab long double float complex name
@item name T_FLOATING COMPLEX @tab double float complex name
@item name S_FLOATING COMPLEX @tab double float complex name
@item name X_FLOATING COMPLEX @tab long double float complex name
@item name DECIMAL PRECISION (p,q) @tab char name [p/2+1]
@item name BITFIELD @tab uint8_t name:1 (bitfields of 1 to 8 bits)
@item @tab uint16_t name : 1 (bitfields of 9 to 16 bits)
@item @tab uint32_t name : 1 (bitfields of 17 to 32 bits)
@item @tab uint64_t name : 1 (bitfields of 33 to 64 bits)
@item @tab __uint128_t name:1 (bitfields of 65 to 128 bits)
@item      LENGTH n @tab uint8_t name:n
@item      MASK @tab #define <pref>_m_name <hex-value>
@item      SIGNED @tab int8_t name : 1 (bitfields of 1 to 8 bits)
@item @tab int16_t name : 1 (bitfields of 9 to 16 bits)
@item @tab int32_t name : 1 (bitfields of 17 to 32 bits)
@item @tab int64_t name : 1 (bitfields of 33 to 64 bits)
@item @tab __int128_t name : 1 (bitfields of 65 to 128 bits)
@item name CHARACTER @tab char name
@item      LENGTH n @tab char name[n]
@item      LENGTH * @tab n/a
@item VARYING @tab struct @{short string_length; char string_text[n];@} name;
where n is the maximum length of the character string
@item name ADDRESS (object-type) @tab object-type *name
@item name POINTER (object-type) @tab object-type *name
@item name POINTER_LONG (object-type) @tab uint32_t
@item name POINTER_HW (object-type) @tab uint32_t name (32-bit)
@item @tab uint64_t name (64-bit)
@item name HARDWARE_ADDRESS (object-type) @tab uint32_t name (32-bit)
@item @tab uint64_t name (64-bit)
@item name POINTER_QUAD (object-type) @tab uint64_t name
@item name BOOLEAN @tab bool
@item name user-type-name @tab user-type-name name
@item Default storage class @tab struct or union with <member-name> as the tag,
and no declared variable names
@item COMMON storage class @tab extern attribute
@item GLOBAL storage class @tab n/a
@item BASED pointer-name @tab A pointer will be generated for the based item
@item TYPEDEF @tab For an AGGREGATE, a TYPEDEF STRUCT is generated.  In this
case, a pre-tag is generated as well as the post-tag.  The pre-tag consists of
the structure named prefixed by an underscore.  Any reference to the structure
type within the definition (such as for forward and backward linkages) is also
output with the underscore.  For an ITEM, the TYPEDEF keyword is generated,
followed by the data type of the ITEM.
1 
@item DIMENSION [lbound:]hbound The declaration specifies an array of the number of
elements specified with subscripts ranging from 0 to (hbound - lbound + 1)
@item ORIGIN member-name n/a
@end multitable

@node ASCII Character Set
@appendix ASCII Character Set
@cindex ASCII Character Set

The following table shows the ASCII character set referred to in
@ref{Expressions}.

@multitable @columnfractions .20 .20 .60
@headitem Character @tab ASCII Decimal @tab Hexadecimal
@item NUL @tab 000 @tab 00
@item SOH @tab 001 @tab 01
@item STX @tab 002 @tab 02
@item ETX @tab 003 @tab 03
@item EOT @tab 004 @tab 04
@item ENQ @tab 005 @tab 05
@item ACK @tab 006 @tab 06
@item BEL @tab 007 @tab 07
@item BS @tab 008 @tab 08
@item HT @tab 009 @tab 09
@item LF @tab 010 @tab 0A
@item VT @tab 011 @tab 0B
@item FF @tab 012 @tab 0C
@item CR @tab 013 @tab 0D
@item SO @tab 014 @tab 0E
@item SI @tab 015 @tab 0F
@item DLE @tab 016 @tab 10
@item DC1 @tab 017 @tab 11
@item DC2 @tab 018 @tab 12
@item DC3 @tab 019 @tab 13
@item DC4 @tab 020 @tab 14
@item NAK @tab 021 @tab 15
@item SYN @tab 022 @tab 16
@item ETB @tab 023 @tab 17
@item CAN @tab 024 @tab 18
@item EM @tab 025 @tab 19
@item SUB @tab 026 @tab 1A
@item ESC @tab 027 @tab 1B
@item FS @tab 028 @tab 1C
@item GS @tab 029 @tab 1D
@item RS @tab 030 @tab 1E
@item US @tab 031 @tab 1F
@item SP @tab 032 @tab 20
@item ! @tab 033 @tab 21
@item " @tab 034 @tab 22
@item # @tab 035 @tab 23
@item $ @tab 036 @tab 24
@item % @tab 037 @tab 25
@item & @tab 038 @tab 26
@item  @tab 039 @tab 27
@item ( @tab 040 @tab 28
@item ) @tab 041 @tab 29
@item * @tab 042 @tab 2A
@item + @tab 043 @tab 2B
@item @comma{} @tab 044 @tab 2C
@item - @tab 045 @tab 2D
@item . @tab 046 @tab 2E
@item / @tab 047 @tab 2F
@item 0 @tab 048 @tab 30
@item 1 @tab 049 @tab 31
@item 2 @tab 050 @tab 32
@item 3 @tab 051 @tab 33
@item 4 @tab 052 @tab 34
@item 5 @tab 053 @tab 35
@item 6 @tab 054 @tab 36
@item 7 @tab 055 @tab 37
@item 8 @tab 056 @tab 38
@item 9 @tab 057 @tab 39
@item : @tab 058 @tab 3A
@item ; @tab 059 @tab 3B
@item < @tab 060 @tab 3C
@item = @tab 061 @tab 3D
@item > @tab 062 @tab 3E
@item ? @tab 063 @tab 3F
@item @@ @tab 064 @tab 40
@item A @tab 065 @tab 41
@item B @tab 066 @tab 42
@item C @tab 067 @tab 43
@item D @tab 068 @tab 44
@item E @tab 069 @tab 45
@item F @tab 070 @tab 46
@item G @tab 071 @tab 47
@item H @tab 072 @tab 48
@item I @tab 073 @tab 49
@item J @tab 074 @tab 4A
@item K @tab 075 @tab 4B
@item L @tab 076 @tab 4C
@item M @tab 077 @tab 4D
@item N @tab 078 @tab 4E
@item O @tab 079 @tab 4F
@item P @tab 080 @tab 50
@item Q @tab 081 @tab 51
@item R @tab 082 @tab 52
@item S @tab 083 @tab 53
@item T @tab 084 @tab 54
@item U @tab 085 @tab 55
@item V @tab 086 @tab 56
@item W @tab 087 @tab 57
@item X @tab 088 @tab 58
@item Y @tab 089 @tab 59
@item Z @tab 090 @tab 5A
@item [ @tab 091 @tab 5B
@item @backslashchar{} @tab 092 @tab 5C
@item ] @tab 093 @tab 5D
@item ^ @tab 094 @tab 5E
@item _ @tab 095 @tab 5F
@item  @tab 096 @tab 60
@item a @tab 097 @tab 61
@item b @tab 098 @tab 62
@item c @tab 099 @tab 63
@item d @tab 100 @tab 64
@item e @tab 101 @tab 65
@item f @tab 102 @tab 66
@item g @tab 103 @tab 67
@item h @tab 104 @tab 68
@item i @tab 105 @tab 69
@item j @tab 106 @tab 6A
@item k @tab 107 @tab 6B
@item l @tab 108 @tab 6C
@item m @tab 109 @tab 6D
@item n @tab 110 @tab 6E
@item o @tab 111 @tab 6F
@item p @tab 112 @tab 70
@item q @tab 113 @tab 71
@item r @tab 114 @tab 72
@item s @tab 115 @tab 73
@item t @tab 116 @tab 74
@item u @tab 117 @tab 75
@item v @tab 118 @tab 76
@item w @tab 119 @tab 77
@item x @tab 120 @tab 78
@item y @tab 121 @tab 79
@item z @tab 122 @tab 7A
@item @{ @tab 123 @tab 7B
@item | @tab 124 @tab 7C
@item @} @tab 125 @tab 7D
@item ~ @tab 126 @tab 7E
@item DEL @tab 127 @tab 7F
@end multitable

The following table describes the ASCII character abbreviations used in the previous table.

@multitable @columnfractions .20 .20 .20 .40
@headitem Characters @tab Description @tab Characters @tab Description
@item NUL @tab Null @tab DLE @tab Data Link Escape
@item SOH @tab Start of Heading @tab DC1 @tab Device Control 1
@item STX @tab Start of Text @tab DC2 @tab Device Control 2
@item ETX @tab End of Text @tab DC3 @tab Device Control 3
@item EOT @tab End of Transmission @tab DC4 @tab Device Control 4
@item ENQ @tab Enquiry @tab NAK @tab Negative Acknowledge
@item ACK @tab Acknowledge @tab SYN @tab Synchronous Idle
@item BEL @tab Bell @tab ETB @tab End of Transmission Block
@item BS @tab Backspace @tab CAN @tab Cancel
@item HT @tab Horizontal Tabulation @tab EM @tab End of Medium
@item LF @tab Line Feed @tab SUB @tab Substitute
@item VT @tab Vertical Tab @tab ESC @tab Escape
@item FF @tab Form Feed @tab FS @tab File Separator
@item CR @tab Carriage Return @tab GS @tab Group Separator
@item SO @tab Shift Out @tab RS @tab Record Separator
@item SI @tab Shift In @tab US @tab Unit Separator
@item SP @tab Space @tab DEL @tab Delete
@end multitable

@node Index
@unnumbered Index

@printindex cp

@bye
